```json
{
  "exam_name": "CS232_Fall_2000_Final_Exam",
  "problems": [
    {
      "problem": "1. Multiple Choice Problems",
      "parts": [
        {
          "part": "A",
          "subproblem": [
            {
              "subproblem_question": "Choose the one untrue statement about MIPS addressing modes:"
            }
          ],
          "answer": [
            {
              "solution": "a. Pseudo-direct addressing, used for jumps, gets the upper 4 bits of the address from the PC"
            }
          ]
        },
        {
          "part": "B",
          "subproblem": [
            {
              "subproblem_question": "For each of the MIPS code sequences below, indicate if the memory accesses show temporal locality, spatial locality, both, or neither (by checking the corresponding boxes).",
              "subproblem_figures": ["TABLE"]
            }
          ],
          "answer": [
            {
              "solution": "a. [X] temporal locality, [ ] spatial locality, [ ] both, [ ] neither",
              "solution_figures": ["TABLE"]
            },
            {
              "solution": "b. [ ] temporal locality, [ ] spatial locality, [X] both, [ ] neither",
              "solution_figures": ["TABLE"]
            },
            {
              "solution": "c. [ ] temporal locality, [X] spatial locality, [ ] both, [ ] neither",
              "solution_figures": ["TABLE"]
            }
          ]
        },
        {
          "part": "C",
          "subproblem": [
            {
              "subproblem_question": "The following problems relate to the various characteristics of a cache."
            }
          ],
          "answer": [
            {
              "solution": "a) For each of the following characteristics of a cache, mark if it's a good characteristic, or a bad one.",
              "solution_figures": ["TABLE"]
            },
            {
              "solution": "b) Mark how the characteristics would change if we increased the block size.",
              "solution_figures": ["TABLE"]
            },
            {
              "solution": "c) Mark how increasing the associativity of the cache would affect its behavior.",
              "solution_figures": ["TABLE"]
            }
          ]
        }
      ]
    },
    {
      "problem": "2. Short Answer Problems",
      "parts": [
        {
          "part": "2",
          "subproblem": [
            {
              "subproblem_question": "Write 2.5 in the standard IEEE 754 single precision floating point binary representation.",
              "subproblem_figures": ["TABLE"]
            }
          ],
          "answer": [
            {
              "solution": "| 0 | 10000000 | 01000000000000000000000 |",
              "solution_figures": ["TABLE"]
            }
          ]
        },
        {
          "part": "3",
          "subproblem": [
            {
              "subproblem_question": "Write down a sentence on the characteristic feature of each of the following datapath implementations that differentiate one from the other."
            }
          ],
          "answer": [
            {
              "solution": "Single cycle: One instruction takes one cycle. Clock cycle time is the maximum of the execution times of the instructions. There are separate functional units for each stage within an instruction."
            },
            {
              "solution": "Multi-cycle: Number of cycles vary for each instruction, and therefore performance is better. Describes FSM in detail. Functional units are combined. Says something about 'many stuff'. The cycles are shorter."
            },
            {
              "solution": "Pipelined: Different instructions in different execution stages run simultaneously. Just 'more than one instruction at a time'."
            },
            {
              "solution": "Superscalar: Execute multiple instructions in the same cycle. Load/stores and ALU instructions done simultaneously."
            },
            {
              "solution": "Superpipelining: Just more stages to pipelining."
            }
          ]
        }
      ]
    },
    {
      "problem": "4. Long Answer Problems",
      "problem_context": "Consider a modification to the register file in the pipelined MIPS datapath. This modification allows the register file to do only one operation in each cycle: i.e. it can be either read from or written to in a single cycle. This modification introduces structural hazards into MIPS. Show how a sequence of instructions that have NO data or control hazards would now be executed using the following diagram. Show at least the next five instructions.",
      "problem_figures": ["IMAGE"],
      "parts": [
        {
          "part": "4",
          "subproblem": [
            {
              "subproblem_question": "Show how a sequence of instructions that have NO data or control hazards would now be executed using the following diagram. Show at least the next five instructions."
            }
          ],
          "answer": [
            {
              "solution": "Show the diagram with the sequence of instructions.",
              "solution_figures": ["IMAGE"]
            }
          ]
        }
      ]
    },
    {
      "problem": "5. Long Answer Problems",
      "problem_context": "Consider a simple, non-pipelined, single-cycle implementation of MIPS. Assume instruction fetch from memory takes the same time as data fetch from memory. The operation time for the major functional units for this machine are as follows: Memory units: 6 ns, ALU and adders: 4 ns, Register file (read or write): 2 ns",
      "parts": [
        {
          "part": "a",
          "subproblem": [
            {
              "subproblem_question": "Put a mark in the each blank to indicate the stages of the critical path taken by the following instructions.",
              "subproblem_figures": ["TABLE"]
            }
          ],
          "answer": [
            {
              "solution": "Mark the stages of the critical path.",
              "solution_figures": ["TABLE"]
            }
          ]
        },
        {
          "part": "b",
          "subproblem": [
            {
              "subproblem_question": "Assuming that no other delays arise from the memory system, internal control unit, program counter access, etc., find the clock cycle time for the single cycle datapath. Write a line about how you determined the clock cycle time."
            }
          ],
          "answer": [
            {
              "solution": "The longest instruction is load word, and it takes 6+2+4+6+2=20 ns. So, 20 ns is the clock cycle time."
            }
          ]
        },
        {
          "part": "c",
          "subproblem": [
            {
              "subproblem_question": "For the given an instruction mix compare the performance of the pipelined and multi-cycle implementation of the datapath above."
            }
          ],
          "answer": [
            {
              "solution": "Compare the performance of the pipelined and multi-cycle implementation."
            }
          ]
        }
      ]
    },
    {
      "problem": "6. Long Answer Problems",
      "problem_context": "Given the C code below, fill in the blank lines in the MIPS code below so it will execute the C code properly. You may use only the blanks provided.",
      "parts": [
        {
          "part": "6",
          "subproblem": [
            {
              "subproblem_question": "Fill in the blank lines in the MIPS code below so it will execute the C code properly.",
              "subproblem_figures": ["TABLE"]
            }
          ],
          "answer": [
            {
              "solution": "Fill in the blanks in the MIPS code.",
              "solution_figures": ["TABLE"]
            }
          ]
        }
      ]
    },
    {
      "problem": "7. Long Answer Problems",
      "problem_context": "Consider the single-cycle datapaths shown below, highlight clearly the paths to show the flow of both the data and the PC for the instructions given, then fill in the blanks for the control bits (0 = cleared, 1 = set, x = don't care). For the ALUOp field, use the following: 00 = 'add', 01 = 'subtract', 10 = 'do the funct field operation'.",
      "parts": [
        {
          "part": "a",
          "subproblem": [
            {
              "subproblem_question": "Instruction: lw $1, 100 ($2)",
              "subproblem_figures": ["IMAGE"]
            }
          ],
          "answer": [
            {
              "solution": "| PCSrc | RegDst | RegWrite | ALUSrc | ALUOp | MemWrite | MemRead | MemtoReg |\n| 1 | 1 | 1 | 0 | 00 | 0 | 1 | 1 |",
              "solution_figures": ["IMAGE"]
            }
          ]
        },
        {
          "part": "b",
          "subproblem": [
            {
              "subproblem_question": "Instruction: beq $2, $2, loop",
              "subproblem_figures": ["IMAGE"]
            }
          ],
          "answer": [
            {
              "solution": "| Branch | RegDst | RegWrite | ALUSrc | ALUOp | MemWrite | MemRead | MemtoReg |\n| 1 | X | 0 | 0 | 01 | 0 | X | X |",
              "solution_figures": ["IMAGE"]
            }
          ]
        }
      ]
    },
    {
      "problem": "8. Long Answer Problems",
      "problem_context": "Referring to both of the diagrams from problem number 7, assume that the operation time for the major functional units are following: Memory units: 3 ns, Register file (read or write): 1 ns, General ALU: 2ns, Adder for PC+4: X ns, Adder for branch address computation: Y ns. Assume other units have no delay",
      "parts": [
        {
          "part": "a",
          "subproblem": [
            {
              "subproblem_question": "If X=4 ns, Y=4 ns, what are the cycle times for the lw and beq instructions?"
            }
          ],
          "answer": [
            {
              "solution": "cycle time for beq: 4+4=8 ns\ncycle time for lw: 3+1+2+3+1=10 ns\nWhat would be the cycle time of a datapath that supports only these two instructions? 10 ns"
            }
          ]
        },
        {
          "part": "b",
          "subproblem": [
            {
              "subproblem_question": "If X=2 ns, and Y=10 ns, what are the cycle times for the beq and lw instructions?"
            }
          ],
          "answer": [
            {
              "solution": "cycle time for beq: 13 ns (takes 10 ns + waiting for 2 inputs takes max(3,2)=3 ns)\ncycle time for lw: 10 ns\nWhat would be the cycle time of a datapath that supports only these two instructions?"
            }
          ]
        }
      ]
    },
    {
      "problem": "9. Long Answer Problems",
      "problem_context": "Identify all the hazards in the following code, and state the type of each hazard.",
      "problem_figures": ["IMAGE"],
      "parts": [
        {
          "part": "9",
          "subproblem": [
            {
              "subproblem_question": "Identify all the hazards in the following code, and state the type of each hazard.",
              "subproblem_figures": ["IMAGE"]
            }
          ],
          "answer": [
            {
              "solution": "Identify the hazards and their types.",
              "solution_figures": ["IMAGE"]
            }
          ]
        }
      ]
    },
    {
      "problem": "10. Long Answer Problems",
      "problem_context": "Given two pieces of code, the recursive fibonacci code (MP1 - used recursion and function return values) and the memoizing fibonacci code (MP2 - filled in an array recursively) we wrote, compare the performance of the two machines described below. Ignore the instructions that are used to maintain the stack. Both machines run at the same clock rate",
      "parts": [
        {
          "part": "10",
          "subproblem": [
            {
              "subproblem_question": "Compare the performance of the two machines described below."
            }
          ],
          "answer": [
            {
              "solution": "Recursive fibonacci: Same speed\nArray-based fibonacci: Superscalar is faster"
            }
          ]
        }
      ]
    },
    {
      "problem": "11. Long Answer Problems",
      "problem_context": "Consider a set-associative cache as given in the diagram below. We are using a write-back policy on this cache, and we are using an extra dirty bit ('D') to mark those blocks that actually need to be written back when replaced, similar to what is done in virtual memory. Note that the dirty bit is examined on each replacement. The replacement policy is LRU (i.e. replace the least recently used block). Assuming that the cache is empty at the beginning, show how the cache changes for the following code sequence. There is a set of tables on the next page for this purpose. (continued on next page)",
      "problem_figures": ["IMAGE"],
      "parts": [
        {
          "part": "a",
          "subproblem": [
            {
              "subproblem_question": "Show how the cache changes for the following code sequence.",
              "subproblem_figures": ["TABLE"]
            }
          ],
          "answer": [
            {
              "solution": "Fill in the tables to show the cache changes.",
              "solution_figures": ["TABLE"]
            }
          ]
        }
      ]
    }
  ]
}
```