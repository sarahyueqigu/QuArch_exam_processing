[
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_10/a",
        "context": "You are trying to reverse-engineer the characteristics of a cache in a system, so that you can design a more efficient, machine-specific implementation of an algorithm you are working on. To do so, you have come up with three sequences of memory accesses to various bytes in the system in an attempt to determine the following four cache characteristics:\n\n\u02c6 Cache block size (8, 16, 32, 64, or 128B).\n\n\u02c6 Cache associativity (2-, 4-, or 8-way).\n\n\u02c6 Cache replacement policy (LRU or FIFO).\n\n\u02c6 Cache size (4 or 8KiB).\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of memory accesses. Here is what you observe:\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n1. 0 16 24 25 1024 255 1100 305 2/8\n2. 31 65536 65537 131072 262144 8 305 1060 3/8\n3. 262145 65536 4 2/3\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning of the second and third sequence. The sequences are executed back-to-back, i.e., no other accesses take place in between sequences. Thus, at the beginning of the second sequence, the contents are the same as at the end of the first sequence. At the beginning of the third sequence, the contents are the same as at the end of the second sequence.\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\n",
        "context_figures": [
            "chart_p23_0.png"
        ],
        "question": "Cache block size (8, 16, 32, 64, or 128B)?",
        "solution": "16 B.\n\nExplanation:\nCache hit rate is 2/8 in sequence 1. This means that there are 2 hits. Depending on the cache block size, we can group addresses that belong to the same cache block as follows:\n\n\u02c6 8B: {0}, {16}, {24,25}, {255}, {305}, {1024}, {1100}. \u2234 Number of possible hits = 1.\n\n\u02c6 16B: {0}, {16,24,25}, {255}, {305}, {1024}, {1100}. \u2234 Number of possible hits = 2.\n\u02c6 32B: {0,16,24,25}, {255}, {305}, {1024}, {1100}. \u2234 Number of possible hits = 3.\n\u02c6 64B: {0,16,24,25}, {255,305}, {1024}, {1100}. \u2234 Number of possible hits = 4.\n\u02c6 128B: {0,16,24,25}, {255,305}, {1024,1100}. \u2234 Number of possible hits = 5.\n\nTherefore, we can know that the cache block size is 16B.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_10/b",
        "context": "You are trying to reverse-engineer the characteristics of a cache in a system, so that you can design a more efficient, machine-specific implementation of an algorithm you are working on. To do so, you have come up with three sequences of memory accesses to various bytes in the system in an attempt to determine the following four cache characteristics:\n\n\u02c6 Cache block size (8, 16, 32, 64, or 128B).\n\n\u02c6 Cache associativity (2-, 4-, or 8-way).\n\n\u02c6 Cache replacement policy (LRU or FIFO).\n\n\u02c6 Cache size (4 or 8KiB).\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of memory accesses. Here is what you observe:\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n1. 0 16 24 25 1024 255 1100 305 2/8\n2. 31 65536 65537 131072 262144 8 305 1060 3/8\n3. 262145 65536 4 2/3\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning of the second and third sequence. The sequences are executed back-to-back, i.e., no other accesses take place in between sequences. Thus, at the beginning of the second sequence, the contents are the same as at the end of the first sequence. At the beginning of the third sequence, the contents are the same as at the end of the second sequence.\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\n",
        "context_figures": [
            "chart_p23_0.png"
        ],
        "question": "Cache associativity (2-, 4-, or 8-way)?",
        "solution": "2-way.\n\nExplanation:\n\nCache hit rate is 3/8 in sequence 2, which means that there are 3 hits.\nWe already know that the cache block size is 16B. Thus, there are 4 offset bits.\n\nThe access to address 31 in sequence 2 would hit because the cache block would not be replaced.\nThe access to address 305 in sequence 2 would hit because the cache block would not be replaced.\nThe access to address 65537 in sequence 2 would hit because the cache block would not be replaced.\n\nTherefore, all the other accesses should miss.\nThe access to address 65536, 131072 and 262144 in sequence 2 would miss because addresses 65536, 131072 and 262144 do not belong to any cache block previously accessed.\nAddresses 65536, 131072 and 262144 would be placed in set 0 if the cache associativity is 2-way, 4-way, or 8-way, independently of the cache size.\nAddress 8 must be a miss, so its cache block must be replaced by cache blocks that map to set 0 (addresses 65536, 131072 and 262144). For this to happen, the associativity must be 2-way.\nTherefore, the cache is 2-way associative.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_10/c",
        "context": "You are trying to reverse-engineer the characteristics of a cache in a system, so that you can design a more efficient, machine-specific implementation of an algorithm you are working on. To do so, you have come up with three sequences of memory accesses to various bytes in the system in an attempt to determine the following four cache characteristics:\n\n\u02c6 Cache block size (8, 16, 32, 64, or 128B).\n\n\u02c6 Cache associativity (2-, 4-, or 8-way).\n\n\u02c6 Cache replacement policy (LRU or FIFO).\n\n\u02c6 Cache size (4 or 8KiB).\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of memory accesses. Here is what you observe:\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n1. 0 16 24 25 1024 255 1100 305 2/8\n2. 31 65536 65537 131072 262144 8 305 1060 3/8\n3. 262145 65536 4 2/3\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning of the second and third sequence. The sequences are executed back-to-back, i.e., no other accesses take place in between sequences. Thus, at the beginning of the second sequence, the contents are the same as at the end of the first sequence. At the beginning of the third sequence, the contents are the same as at the end of the second sequence.\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\n",
        "context_figures": [
            "chart_p23_0.png"
        ],
        "question": "Cache replacement policy (LRU or FIFO)?",
        "solution": "FIFO.\n\nExplanation:\nFrom questions (a) and (b), we already know the following facts:\n\n\u02c6 The cache block size is 16 B.\n\u02c6 The cache is 2-way.\n\nCache hit rate is 2/3 in sequence 3, which means that there are 2 hits.\nWith the LRU policy only the access to address 262145 in sequence 3 would hit. With the FIFO policy, accesses to addresses 262145 and 4 in sequence 3 would hit.\nTherefore, the cache adopts the FIFO policy.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_10/d",
        "context": "You are trying to reverse-engineer the characteristics of a cache in a system, so that you can design a more efficient, machine-specific implementation of an algorithm you are working on. To do so, you have come up with three sequences of memory accesses to various bytes in the system in an attempt to determine the following four cache characteristics:\n\n\u02c6 Cache block size (8, 16, 32, 64, or 128B).\n\n\u02c6 Cache associativity (2-, 4-, or 8-way).\n\n\u02c6 Cache replacement policy (LRU or FIFO).\n\n\u02c6 Cache size (4 or 8KiB).\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of memory accesses. Here is what you observe:\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n1. 0 16 24 25 1024 255 1100 305 2/8\n2. 31 65536 65537 131072 262144 8 305 1060 3/8\n3. 262145 65536 4 2/3\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning of the second and third sequence. The sequences are executed back-to-back, i.e., no other accesses take place in between sequences. Thus, at the beginning of the second sequence, the contents are the same as at the end of the first sequence. At the beginning of the third sequence, the contents are the same as at the end of the second sequence.\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\n",
        "context_figures": [
            "chart_p23_0.png"
        ],
        "question": "To identify the cache size (4 or 8KiB), you can access two addresses right after sequence 3 (i.e., the contents are the same as at the end of the third sequence) and measure the cache hit rate. Which two addresses would you choose? Explain your answer (there may be several correct answers).",
        "solution": "Address 2048 and address 0 (there are other correct answers as well)\n\nExplanation:\nFrom questions (a), (b) and (c), we already know the following facts:\n\n\u02c6 The cache block size is 16 B.\n\u02c6 The cache is 2-way.\n\u02c6 FIFO replacement policy\n\nWe know that there are 4 bits for indexing the byte in a block, and there are 7 bits (if the cache size is 4KiB) or 8 bits (if the cache size is 8 KiB). Therefore, address 2048 would be in set 0 only if the cache size is 4KiB: we can access address 2048, and then check if a block in set 0 was replaced by address 2048 by accessing address 0. If it is a miss, the cache size is 4KiB, and if it is a hit, the cache size is 8KiB.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_11/(a)",
        "context": "A runahead execution processor is designed with an unintended hardware bug: every other instruction in runahead mode is dropped by the processor after the fetch stage. Recall that the runahead mode is the speculative processing mode where the processor executes instructions solely to generate prefetch requests. All other behavior of the runahead mode is exactly as we described in lectures. When a program is executed, which of the following scenarios could happen compared to a runahead processor without the hardware bug and why? Circle YES if there is a possibility to observe the described behavior and explain in the box (either if you answer YES or NO). Assume that the program has no bug in it and executes correctly on the processor without the hardware bug.\n",
        "context_figures": [],
        "question": "The buggy runahead processor finishes the program correctly and faster than the non-buggy runahead processor.",
        "solution": "Dropping instructions enables the discovery of more cache misses than not dropping the instructions.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_11/(b)",
        "context": "A runahead execution processor is designed with an unintended hardware bug: every other instruction in runahead mode is dropped by the processor after the fetch stage. Recall that the runahead mode is the speculative processing mode where the processor executes instructions solely to generate prefetch requests. All other behavior of the runahead mode is exactly as we described in lectures. When a program is executed, which of the following scenarios could happen compared to a runahead processor without the hardware bug and why? Circle YES if there is a possibility to observe the described behavior and explain in the box (either if you answer YES or NO). Assume that the program has no bug in it and executes correctly on the processor without the hardware bug.\n",
        "context_figures": [],
        "question": "The buggy runahead processor finishes the program correctly and slower than the non-buggy runahead processor.",
        "solution": "The buggy runahead processor is not able to generate cache misses that are dependent on dropped instructions.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_11/(c)",
        "context": "A runahead execution processor is designed with an unintended hardware bug: every other instruction in runahead mode is dropped by the processor after the fetch stage. Recall that the runahead mode is the speculative processing mode where the processor executes instructions solely to generate prefetch requests. All other behavior of the runahead mode is exactly as we described in lectures. When a program is executed, which of the following scenarios could happen compared to a runahead processor without the hardware bug and why? Circle YES if there is a possibility to observe the described behavior and explain in the box (either if you answer YES or NO). Assume that the program has no bug in it and executes correctly on the processor without the hardware bug.\n",
        "context_figures": [],
        "question": "The buggy runahead processor executes the program incorrectly.",
        "solution": "Not possible as all executions in runahead mode is purely speculative and do not commit. Hence it cannot affect the correctness of the program.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_12",
        "context": "A systolic array consists of 4x4 Processing Elements (PEs), interconnected as shown in Figure 1. The inputs of the systolic array are labeled as H0, H1, H2, H3 and V0, V1, V2, V3. Figure 2 shows the PE logic, which performs a multiply and accumulate MAC operation and saves the result to an internal register (reg). Figure 2 also shows how each PE propagates its inputs. We make the following assumptions:\n\n\u02c6 The latency of each MAC operation is one cycle.\n\n\u02c6 The propagation of the values from i0 to o0, and from i1 to o1, takes one cycle.\n\n\u02c6 The initial values of all internal registers is zero.\n\nYour goal is to use the example systolic array shown in Figure 1 to perform the convolution (~) of a 3x3 image (matrix I3x3) with four 2x2 filters (matrices A2x2, B2x2, C2x2, and D2x2), to obtain four 2x2 outputs (matrices W2x2, X2x2, Y2x2, and Z2x2):\n\nI00 I01 I02\nI10 I11 I12\nI20 I21 I22\n\n(~)\nA00 A01\nA10 A11\n=\nW00 W01\nW10 W11\n\nI00 I01 I02\nI10 I11 I12\nI20 I21 I22\n\n(~)\nB00 B01\nB10 B11\n=\nX00 X01\nX10 X11\n\nI00 I01 I02\nI10 I11 I12\nI20 I21 I22\n\n(~)\nC00 C01\nC10 C11\n=\nY00 Y01\nY10 Y11\n\nI00 I01 I02\nI10 I11 I12\nI20 I21 I22\n\n(~)\nD00 D01\nD10 D11\n=\nZ00 Z01\nZ10 Z11\n\nAs an example, the convolution of the matrix I3x3 with the filter A2x2 is computed as follows:\n\n\u02c6 W00 = I00 * A00 + I01 * A01 + I10 * A10 + I11 * A11\n\n\u02c6 W01 = I01 * A00 + I02 * A01 + I11 * A10 + I12 * A11\n\n\u02c6 W10 = I10 * A00 + I11 * A01 + I20 * A10 + I21 * A11\n\n\u02c6 W11 = I11 * A00 + I12 * A01 + I21 * A10 + I22 * A11",
        "context_figures": [
            "chart_p27_0.png"
        ],
        "question": "You should compute the four convolutions in the minimum possible number of cycles. Fill the following table with:\n\n1. The input elements (from matrices I3x3, A2x2, B2x2, C2x2, and D2x2) in the correct input ports of the systolic array (H0, H1, H2, H3 and V0, V1, V2, V3). (Hint: If necessary, an input element can be concurrently streamed into several input ports of the array.)\n\n2. The output values and the corresponding PE where the output elements (of matrices W2x2, X2x2, Y2x2, and Z2x2) are generated.\n\nFill the blanks only with relevant information.",
        "solution": "cycle H0 H1 H2 H3 V0 V1 V2 V3 PE00 PE01 PE02 PE03 PE10 PE11 PE12 PE13 PE20 PE21 PE22 PE23 PE30 PE31 PE32 PE33\n0 A00 I00\n1 A01 B00 I01 I01\n2 A10 B01 C00 I10 I02 I10\n3 A11 B10 C01 D00 I11 I11 I11 I11 W00\n4 B11 C10 D01 I12 I20 I12 W01 X00\n5 C11 D10 I21 I21 W10 X01 Y00\n6 D11 I22 W11 X10 Y01 Z00\n7 X11 Y10 Z01\n8 Y11 Z10\n9 Z11",
        "solution_figures": [
            "chart_p27_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/a",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "How many warps does it take to execute these code segments?",
        "solution": "32 warps.\n\nExplanation:\nThe number of warps is calculated as:\n#Warps = d#Total_threads/#Warp_size e,\n\nwhere\n#Total_threads = 1024 = 210 (i.e., one thread per loop iteration),\nand\n#Warp_size = 32 = 25 (given).\n\nThus, the number of warps needed to run this program is:\n\n#Warps = d 210/25 e = 25 = 32.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/b",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "What is the SIMD utilization of the first iteration of the inner loop (j = 0) for Code Segment 1? Show your work. (Hint: The warp scheduler does not issue instructions when no thread is active).",
        "solution": "The utilization of the first iteration (j = 0) of Code Segment 1 is 7/8.\n\nExplanation:\nInstructions 1, 2, and 4 are executed by all threads in Code Segment 1.\n\nIn Code Segment 1, s = 1 during the first iteration. Thus, only even numbered threads fulfill the predicate of the if statement, and only half of the threads of each warp execute Instruction 3.\nCode Segment 1, j = 0: SIMD_utilization = (1024+1024+512+1024)/(1024+1024+1024+1024) = 7/8.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/c",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "What is the SIMD utilization of the first iteration of the inner loop (j = 0) for Code Segment 2? Show your work. (Hint: The warp scheduler does not issue instructions when no thread is active).",
        "solution": "The utilization of the first iteration (j = 0) of Code Segment 2 is 100%.\n\nExplanation:\nInstructions 1, 2, and 4 are executed by all threads in Code Segment 2.\n\nIn Code Segment 2, s = 512 during the first iteration. Thus, only threads with i < 512 fulfill the predicate of the if statement, and all threads of only half of the warps execute Instruction 3.\nCode Segment 2, j = 0: SIMD_utilization = (1024+1024+512+1024)/(1024+1024+512+1024) = 7/7 = 100%.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/d",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "What is the SIMD utilization of any iteration of the inner loop (0 <= j < 10) for Code Segment 1? Show your work. (Hint: Derive an analytical expression, which may be piecewise).",
        "solution": "As mentioned in part (b), Instructions 1, 2, and 4 are executed by all threads.\n\nIn Code Segment 1, with 0 <= j < 5, all 32 warps are active, but the number of active threads per warp divides by half in each iteration. With 5 <= j < 10, only one thread per warp is active, and the number of active warps divides by half in each iteration. As a result:\n\nCode Segment 1, iteration j:\n\nSIMD_utilization = {\n(3072+2(9\u2212j))/4096, if 0 \u2264 j < 5\n(3072+2(9\u2212j))/(3072+32\u22172(9\u2212j)), if 5 \u2264 j < 10\n}",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/e",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "What is the SIMD utilization of any iteration of the inner loop (0 <= j < 10) for Code Segment 2? Show your work. (Hint: Derive an analytical expression, which may be piecewise).",
        "solution": "As mentioned in part (b), Instructions 1, 2, and 4 are executed by all threads.\n\nIn Code Segment 2, with 0 <= j < 5, all 32 threads per warp are active, but the number of active warps divides by half in each iteration. With 5 <= j < 10, only one warp is active, and the number of active threads divides by half in each iteration. As a result:\n\nCode Segment 2, iteration j:\n\nSIMD_utilization = {\n(3072+32\u22172(4\u2212j))/(3072+32\u22172(4\u2212j)) = 100%, if 0 \u2264 j < 5\n(3072+2(9\u2212j))/(3072+32), if 5 \u2264 j < 10\n}",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/f",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "Is there any iteration (0 <= j < 10) where both code segments have the same utilization? Explain your reasoning.",
        "solution": "Yes, with j = 9 only one thread of only one warp is active, since only one thread (out of 1024) is needed to perform the last addition.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_8/g",
        "context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)\n\ns = 1;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i % (2 * s) == 0) // Inst. 2\n            A[i] += A[i + 1]; // Inst. 3\n        s = s << 1; // Inst. 4\n    }\n}\n\nCode Segment 1\n\ns = 512;\nfor (i = 0; i < 1024; i++) {\n    for (j = 0; j < 10; j++) { // Inst. 1\n        if (i < s) // Inst. 2\n            A[i] += A[i + s]; // Inst. 3\n        s = s >> 1; // Inst. 4\n    }\n}\n\nCode Segment 2\n",
        "context_figures": [],
        "question": "Which code is expected to run faster on a GPU? Explain your reasoning.",
        "solution": "Code Segment 2 is faster because it has less intra-warp divergence, and thus higher SIMD utilization. In each iteration (except the last one), the number of warps that Code Segment 2 schedules is smaller than the number of warps that Code Segment 1 schedules. This results in fewer execution cycles.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_9/1",
        "context": "Branch Prediction [45 points]\n\n\nYou are given the following piece of code that iterates through two large arrays, j and k, each populated\nwith completely (i.e., truly) random positive integers. The code has \ufffdve branches (labeled B1, B2,\nB3, B4, and B5). When we say that a branch is taken, we mean that the code inside the curly brackets\nis executed. Assume that the code is run to completion without any errors or interruptions (i.e., there\nare no exceptions). For the following questions, assume that this is the only block of code that will ever\nbe run on the machines, and that the loop condition branch is resolved \ufffdrst in the iteration (i.e., the if\nstatements execute only after resolving the loop condition branch).\n\n\n1 for ( int i = 0 ; i < 1000 ; i++) { //B1\n2 //TAKEN PATH for B1\n3 i f ( i % 2 == 0) { //B2\n4 j [ i ] = k [ i ] * i ; //TAKEN PATH for B2\n5 }\n6 i f ( i < 250) { //B3\n7 j [ i ] = k [ i ] \u2212 i ; //TAKEN PATH for B3\n8 }\n9 i f ( i < 500) { //B4\n\n10 j [ i ] = k [ i ] + i ; //TAKEN PATH for B4\n11 }\n12 i f ( i >= 500) { //B5\n13 j [ i ] = k [ i ] / i ; //TAKEN PATH for B5\n14 }\n15 }\n\n\nListing 1: Application to evaluate.\n\n\nYou are given three machines whose components are identical in every way, except for their branch\npredictors.\n\n\n\u02c6 Machine A uses an always-taken branch predictor.\n\n\n\u02c6 Machine B uses one single-level global two-bit saturating counter branch predictor shared by all\nbranches, which starts at Weakly Taken (2'b10).\n\n\n\u02c6 Machine C uses a per-branch two-bit saturating counter as its branch predictor. All counters start\nat Weakly Not Taken (2'b01).\n\n\nThe saturating counter values are as follows:\n\n\n\u02c6 2'b00 - Strongly Not Taken\n\n\n\u02c6 2'b01 - Weakly Not Taken\n\n\n\u02c6 2'b10 - Weakly Taken\n\n\n\u02c6 2'b11 - Strongly Taken\n",
        "context_figures": [],
        "question": "What is the branch misprediction rate when the above piece of code runs on Machine A? Show your work.",
        "solution": "45.01% = 2251/5001.\n\nExplanation:\nB1 will generate 1 misprediction out of 1001 iterations (B1 is not taken in the 1001th\niteration and the loop body does not execute). B2 will generate 500 mispredictions out\nof 1000 iterations, B3 will generate 750 mispredictions out of 1000 iterations, and both\nB4 and B5 will generate 500 mispredictions out of 1000 iterations.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_9/2",
        "context": "Branch Prediction [45 points]\n\n\nYou are given the following piece of code that iterates through two large arrays, j and k, each populated\nwith completely (i.e., truly) random positive integers. The code has \ufffdve branches (labeled B1, B2,\nB3, B4, and B5). When we say that a branch is taken, we mean that the code inside the curly brackets\nis executed. Assume that the code is run to completion without any errors or interruptions (i.e., there\nare no exceptions). For the following questions, assume that this is the only block of code that will ever\nbe run on the machines, and that the loop condition branch is resolved \ufffdrst in the iteration (i.e., the if\nstatements execute only after resolving the loop condition branch).\n\n\n1 for ( int i = 0 ; i < 1000 ; i++) { //B1\n2 //TAKEN PATH for B1\n3 i f ( i % 2 == 0) { //B2\n4 j [ i ] = k [ i ] * i ; //TAKEN PATH for B2\n5 }\n6 i f ( i < 250) { //B3\n7 j [ i ] = k [ i ] \u2212 i ; //TAKEN PATH for B3\n8 }\n9 i f ( i < 500) { //B4\n\n10 j [ i ] = k [ i ] + i ; //TAKEN PATH for B4\n11 }\n12 i f ( i >= 500) { //B5\n13 j [ i ] = k [ i ] / i ; //TAKEN PATH for B5\n14 }\n15 }\n\n\nListing 1: Application to evaluate.\n\n\nYou are given three machines whose components are identical in every way, except for their branch\npredictors.\n\n\n\u02c6 Machine A uses an always-taken branch predictor.\n\n\n\u02c6 Machine B uses one single-level global two-bit saturating counter branch predictor shared by all\nbranches, which starts at Weakly Taken (2'b10).\n\n\n\u02c6 Machine C uses a per-branch two-bit saturating counter as its branch predictor. All counters start\nat Weakly Not Taken (2'b01).\n\n\nThe saturating counter values are as follows:\n\n\n\u02c6 2'b00 - Strongly Not Taken\n\n\n\u02c6 2'b01 - Weakly Not Taken\n\n\n\u02c6 2'b10 - Weakly Taken\n\n\n\u02c6 2'b11 - Strongly Taken\n",
        "context_figures": [],
        "question": "What is the branch misprediction rate when the above piece of code runs on Machine B? Show your work.",
        "solution": "59.97% = 2999/5001.\n\nExplanation:\nFrom (0-249): 375 mispredictions (125 for B2 and 250 for B5) for 1250 branches.\nFrom (250-499): 874 mispredictions (2 for iteration 250, 4 for every odd iteration, 3 for\nevery even iteration except for iteration 250) for 1250 branches.\nFrom (500-1000): 1750 mispredictions (3 for odd iterations, 4 for even iterations, 0 for\ni = 1000) for 2501 branches.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_9/3",
        "context": "Branch Prediction [45 points]\n\n\nYou are given the following piece of code that iterates through two large arrays, j and k, each populated\nwith completely (i.e., truly) random positive integers. The code has \ufffdve branches (labeled B1, B2,\nB3, B4, and B5). When we say that a branch is taken, we mean that the code inside the curly brackets\nis executed. Assume that the code is run to completion without any errors or interruptions (i.e., there\nare no exceptions). For the following questions, assume that this is the only block of code that will ever\nbe run on the machines, and that the loop condition branch is resolved \ufffdrst in the iteration (i.e., the if\nstatements execute only after resolving the loop condition branch).\n\n\n1 for ( int i = 0 ; i < 1000 ; i++) { //B1\n2 //TAKEN PATH for B1\n3 i f ( i % 2 == 0) { //B2\n4 j [ i ] = k [ i ] * i ; //TAKEN PATH for B2\n5 }\n6 i f ( i < 250) { //B3\n7 j [ i ] = k [ i ] \u2212 i ; //TAKEN PATH for B3\n8 }\n9 i f ( i < 500) { //B4\n\n10 j [ i ] = k [ i ] + i ; //TAKEN PATH for B4\n11 }\n12 i f ( i >= 500) { //B5\n13 j [ i ] = k [ i ] / i ; //TAKEN PATH for B5\n14 }\n15 }\n\n\nListing 1: Application to evaluate.\n\n\nYou are given three machines whose components are identical in every way, except for their branch\npredictors.\n\n\n\u02c6 Machine A uses an always-taken branch predictor.\n\n\n\u02c6 Machine B uses one single-level global two-bit saturating counter branch predictor shared by all\nbranches, which starts at Weakly Taken (2'b10).\n\n\n\u02c6 Machine C uses a per-branch two-bit saturating counter as its branch predictor. All counters start\nat Weakly Not Taken (2'b01).\n\n\nThe saturating counter values are as follows:\n\n\n\u02c6 2'b00 - Strongly Not Taken\n\n\n\u02c6 2'b01 - Weakly Not Taken\n\n\n\u02c6 2'b10 - Weakly Taken\n\n\n\u02c6 2'b11 - Strongly Taken\n",
        "context_figures": [],
        "question": "What is the branch misprediction rate when the above piece of code runs on Machine C? Show your work.",
        "solution": "20.20% = 1010/5001.\n\nExplanation:\nYou can split this up by branch.\nB1: mispredicts at i = 0, and i = 1000 (2 mispredictions out of 1001).\nB2: mispredicts every time since it oscillates between Weakly Not Taken and Weakly\nTaken (1000 mispredictions out of 1000).\nB3: mispredicts at i = 0, i = 250, and i = 251 (3 mispredictions out of 1000).\nB4: mispredicts at i = 0, i = 500, and i = 501 (3 mispredictions out of 1000).\nB5: mispredicts at i = 500, and i = 501 (2 mispredictions out of 1000).",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_2/2.1",
        "context": "Verilog [60 points]\nComplete the Verilog code [30 points]\n\nFor each numbered blank 1 - 5 in the following Verilog code, mark the choice below (i.e., one of options A, B, C, D) that makes the Verilog module operate as described in the comments. The resulting code must have correct syntax.\n\n1 module my_module (input clk, input rst,\n\n2 input[15:0] idata, input[1:0] op, 1 [31:0] odata);\n3\n\n4 2 nval = 32'd0; // defining a 32-bit signal with an initial value of 0\n5\n\n6 always@* begin\n7 case (op)\n8 2'b00:\n9 nval = odata + idata; // when 'op' is decimal 0, add 'idata' to\n10 // 'odata' and assign the result to 'nval'\n11 2'b01:\n12 nval = odata - idata; // when 'op' is decimal 1, subtract 'idata'\n13 // from 'odata' and assign the result to 'nval'\n14 2'b10:\n15 nval = idata; // when 'op' is decimal 2, assign 'idata' to 'nval'\n\n16 3 :\n\n17 nval = 0; // when 'op' is decimal 3, assign 0 to 'nval'\n18 endcase\n19 end\n20\n\n21 // executing the following always block on the rising edge of 'clk'\n22 always@ (posedge clk) begin\n23 if (rst)\n\n24 4 // resetting 'odata' to 0 for the next cycle\n25 else\n\n26 5 // assigning 'nval' to 'odata' for the next cycle\n\n27 end\n28 endmodule",
        "context_figures": [
            "chart_p4_0.png"
        ],
        "question": "Provide your choice for each blank 1 - 5 below:\n\n1 : A. output B. output reg C. output wire D. input reg\n\n2 : A. reg[31:0] B. input[31:0] C. wire[31:0] D. int[31:0]\n\n3 : A. 2'b3 B. 3'b3 C. 2'h11 D. default\n\n4 : A. assign odata <= 0; B. assign odata = 0; C. odata == 0; D. odata <= 0;\n\n5 : A. assign odata <= nval; B. assign odata = nval; C. odata == nval; D. odata <= nval;",
        "solution": "Explanation.\n\n1 : odata must be declared as an output signal since values are assigned to it in the second always block. It cannot be an input signal since inputs are read-only signals and no assignments are allowed to them. odata must be also declared as reg since the assignments are made inside an always block.\n\n2 : nval must be declared as reg[31:0] since values are assigned to it inside the first always block.\n3 : default is a correct choice since all other cases for a 2-bit values (i.e., 2'b00, 2'b01, and 2'b10) are defined in the case statement. The other choices are not correct since they do not properly specify the value of 3. For example, in 2'b3, the problem is that 3 is not a valid binary digit but 2'b must be followed by a 2-bit binary value.\n\n4 : Choices with assign are not valid since the assign keyword cannot be used in an always block. Choice C does not specify an assignment operator but an equality comparison, hence it is not a valid choice either. The correct choice is D, which assigns 0 to odata using non-blocking assignment operator.\n\n5 : The correct choice is D due to the same reasons as in 4 .",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_2/2.2",
        "context": "Verilog [60 points]\nWhat Does This Code Do? [30 points]\n\nYou are given a Verilog code that you are asked to analyze and find out what it does.\n\n1 module my_module2 (input clk, output[1:0] out);\n2\n\n3 reg state = 1'b0;\n4 reg[1:0] my_reg = 0;\n5\n\n6 always@(posedge clk) begin\n7 state <= &out ? ~state : state;\n8 end\n9\n\n10 always@(posedge clk) begin\n11 case(state)\n12 1'b0: begin\n13 my_reg <= my_reg + 1;\n14 end\n15 1'b1: begin\n16 my_reg <= my_reg - 1;\n17 end\n18 endcase\n19 end\n20\n\n21 assign out = my_reg;\n22 endmodule",
        "context_figures": [
            "chart_p6_0.png"
        ],
        "question": "Show the values (as unsigned decimal numbers) that the out signal takes, starting from the initial state of the module, for 16 consecutive clock (i.e., clk) cycles. Explain your answer briefly.",
        "solution": "out is equal to 0, 1, 2, 3, 0, 3, 2, 3, 0, 3, 2, 3, 0, 3, 2, 3 in the first 16 clock cycles.\n\nExplanation.\nThe module either increments or decrements my_reg depending on the state. When state is equal to 0, my_reg is incremented by 1 and otherwise decremented by 1. The value of my_reg is directly assigned to the out signal, and both signals are 2-bit wide.\nmy_reg and state are both initially 0. Therefore, in subsequent cycles, my_reg gets incremented until it reaches 3. During the next cycle, a new value for state is being computed (i.e., the inverse of state as \u223cstate). However, since the new value of the state is not updated until the next positive edge of the clk, the second always block reads state as 0, and thus my_reg gets incremented again to become 0 (the maximum value a 2-bit register can represent is 3 and incrementing my_reg one more time makes it 0).\nDuring the next cycle, state is 1 and my_reg is decremented back to 3. Since my_reg (and thus out) being 3 inverts state, state becomes 0 in the subsequent cycle and my_reg becomes 2 during the positive edge of clk when state is inverted. Then, my_reg gets incremented to 3 and 0 in the next consecutive cycles. Because state remains as 0 or 1 for two consecutive cycles and then gets inverted, the values of my_reg forever repeat the sequence of (0, 3, 2, 3, 0, 3, 2, 3, . . .).",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_3/3.1",
        "context": "Finite State Machines [45 points]\nSimplifying an FSM [20 points]\n\nYou are given the Mealy state machine of a one input / one output digital circuit design. Answer the following questions for the given state diagram.",
        "context_figures": [
            "chart_p7_0.png"
        ],
        "question": "",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_3/3.2",
        "context": "Finite State Machines [45 points]\nDesigning an FSM [25 points]\n\nDesign a Moore finite state machine (FSM) with one input and one output. The input provides an unsigned binary number in a bit-serial fashion from the most-significant bit to the least-significant bit. The output should be logic-1 in a clock cycle if the provided input so far is divisible by 8 (i.e., [the input number] mod 8 = 0). (Hint: Recall that the output depends only on the current state in a Moore FSM.)\n\nBelow are some example bit-streams that should output a logic-1 value.\n\n\u02c6 1000\n\n\u02c6 10000\n\n\u02c6 11000\n\n\u02c6 111000\n\n\u02c6 101000\n\nTo start an input bit stream, the user should reset the FSM. Draw the state diagram and explain why it works. Your state machine should use as few states as possible and each state should have a precise definition and output.",
        "context_figures": [],
        "question": "Design a Moore finite state machine (FSM) with one input and one output that outputs logic-1 when the input so far is divisible by 8.",
        "solution": "From the given examples, we can see that strings can be exactly divided by 8 are all ended with \"000\" (i.e., three \"0\"s). Then, we define S0, a state where the number is ended with \"000\".\nIf \"1\" comes, then the number cannot be exactly divided by 8 and it lacks three \"0\"s at the end. We define this state as \"E\" state (S1), which means no zero at the end.\nWhen there is a \"0\", then the number lacks two \"0\"s to be exactly divided by 8. Therefore, we define the state as \"0\" (S2).\nWhen there are two \"0\"s, then the number lacks one more \"0\" to be exactly divided by 8. Therefore, we define the state as \"00\" (S3) .\nBased on the analysis above, we can draw the finite state machine whose output (i.e., O) is \"1\" at S0 (is \"0\" at other states):",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_1/(a)",
        "context": "Boolean Logic Circuits [20 points]\n",
        "context_figures": [],
        "question": "[10 points] Using Boolean algebra, \ufffdnd the simplest Boolean algebra equation for the following min-terms:\u2211(1111, 1110, 1000, 1001, 1011, 1010, 0000). Show your work step-by-step.",
        "solution": "F = (B.C.D) + (A.(C +B))\n\nExplanation:\nF = (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D)\n\nF = (B.C.D).(A+A)+(A.C).(B.D+B.D+B.D+B.D)+(A.B).(C.D+C.D+C.D+C.D)\n\nF = (B.C.D) + (A.C) + (A.B)\n\nF = (B.C.D) + (A.(C +B))",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_1/(b)",
        "context": "Boolean Logic Circuits [20 points]\n",
        "context_figures": [],
        "question": "[10 points] Convert the following Boolean equation so that it only contains NOR operations. Show your work step-by-step.\n\nF = A+ (B.C +A.C)",
        "solution": "F = ((A+A+ (B.C +A.C)) + ((A+A+ (B.C +A.C))\n\nB.C = B +B + C + C\n\nA.C = A+A+ C + C + C + C\n\nExplanation:\n\nF = ((A+ (B.C +A.C))\n\nF = ((A+ (B.C +A.C)) + ((A+ (B.C +A.C))\n\nF = ((A+A+ (B.C +A.C)) + ((A+A+ (B.C +A.C))\n\nB.C = B +B + C + C\n\nA.C = A+A+ C + C + C + C",
        "solution_figures": [
            "chart_p3_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/1",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of uniquely identifiable memory locations.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/2",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of instructions fetched per clock cycle.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/3",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Support for branch prediction hints conveyed by the compiler.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/4",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of general-purpose registers.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/5",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of non-programmable registers.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/6",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "SIMD processing support.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/7",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of integer arithmetic and logic units (ALUs).\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/8",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of read ports in the physical register file.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/9",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Endianness (big endian vs. small endian).\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/10",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Size of a virtual memory page.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/11",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Cache coherence protocol.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/12",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of cache blocks in the L3 cache.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/13",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Ability to flush (i.e., invalidate) a cache line using the operating system code.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/14",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "Number of pipeline stages.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_4/15",
        "context": "ISA vs. Microarchitecture [30 points]\n\nA new CPU has two comprehensive user manuals available for purchase which describe the ISA and the microarchitecture of the CPU, respectively.\n\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the ISA manual since it is much cheaper than the microarchitecture manual.\n\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer and award 0 points for unanswered questions (the minimum number of total points you can get for this question is 0).\n",
        "context_figures": [],
        "question": "How many prefetches the hardware prefetcher generates in a clock cycle.\n\n1. ISA 2. Microarchitecture",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_5/a",
        "context": "Performance Evaluation [45 points]\n\nA multi-cycle processor P1 executes load instructions in 6 cycles, store instructions in 6 cycles, arith-metic instructions in 2 cycles, and branch instructions in 2 cycles. Consider an application A where 40% of all instructions are load instructions, 20% of all instructions are store instructions, 30% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "What is the CPI of application A when executing on processor P1? Show your work.",
        "solution": "CPI = 0.4\u00d7 6 + 0.2\u00d7 6 + 0.3\u00d7 2 + 0.1\u00d7 2\nCPI = 4.4",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_5/b",
        "context": "Performance Evaluation [45 points]\n\nA multi-cycle processor P1 executes load instructions in 6 cycles, store instructions in 6 cycles, arith-metic instructions in 2 cycles, and branch instructions in 2 cycles. Consider an application A where 40% of all instructions are load instructions, 20% of all instructions are store instructions, 30% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "A new design of the processor doubles the clock frequency of P1. However, the latencies of all instructions increase by 4 cycles. We call this new processor P2. The compiler used to gen-erate instructions for P2 is the same as for P1. Thus, it produces the same number of instructions for program A. What is the CPI of application A when executing on processor P2? Show your work.",
        "solution": "CPI = 0.4\u00d7 10 + 0.2\u00d7 10 + 0.3\u00d7 6 + 0.1\u00d7 6\nCPI = 8.4",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_5/c",
        "context": "Performance Evaluation [45 points]\n\nA multi-cycle processor P1 executes load instructions in 6 cycles, store instructions in 6 cycles, arith-metic instructions in 2 cycles, and branch instructions in 2 cycles. Consider an application A where 40% of all instructions are load instructions, 20% of all instructions are store instructions, 30% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "Which processor is faster (P1 or P2)? By how much (i.e., what is the speedup)? Show your work.",
        "solution": "P2 is 1.05\u00d7 faster than P1.\n\nExplanation.\nExecution_Time_P1 = instructions\u00d7 CPIP1 \u00d7 clock_time\n\nExecution_Time_P2 = instructions\u00d7 CPIP2 \u00d7 clock_time/2\n\nclock_time = 1/clock_frequency\n\nAssuming that Execution_Time_P2 < Execution_Time_P1 =\u21d2\nExecution_Time_P1/Execution_Time_P2 > 1. Thus:\n\n=\u21d2 instructions\u00d7CPIP1\u00d7clock_time/(instructions\u00d7CPIP2\u00d7clock_time/2)\n\n=\u21d2 4.4\u00d7clock_time/(8.4\u00d7 clock_time/2)\n\n=\u21d2 4.4/4.2\n\n=\u21d2 1.05",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_5/d",
        "context": "Performance Evaluation [45 points]\n\nA multi-cycle processor P1 executes load instructions in 6 cycles, store instructions in 6 cycles, arith-metic instructions in 2 cycles, and branch instructions in 2 cycles. Consider an application A where 40% of all instructions are load instructions, 20% of all instructions are store instructions, 30% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "You want to improve the original P1 design by including one new optimization without changing the clock frequency. You can choose only one of the following options:\n\n(1) ALU: An optimized ALU, which halves the latency of both arithmetic and branch instruc-tions.\n\n(2) LSU: An asymmetric load-store unit, which halves the latency of load operations but doubles the latency of store operations.\n\nWhich optimization do you add to P1 for application A? Show your work and justify your choice.",
        "solution": "The ALU optimization.\n\nExplanation.\nApplication A executes 40% load, 20% store, 30% arithmetic, and 10% branch instruc-tions.\nBy Amdahl's Law, we have:\n\nSpeedupALU = 1/((1\u22120.3\u22120.1)+ (0.3+0.1)/2) = 1.25\n\nSpeedupLSU = 1/((1\u22120.4\u22120.2)+ 0.4/2 +0.2\u00d72) = 1.0\n\nThe ALU optimization provides 1.25\u00d7 speedup, while the LSU provides no speedup at all.\n\nAlternative Solution.\nWith the ALU, the new CPI of processor P1 will be:\nCPIALU = 0.4\u00d7 6 + 0.2\u00d7 6 + 0.3\u00d7 2/2 + 0.1\u00d7 2/2\nCPIALU = 4.0\n\nWith the LSU, the new CPI of processor P1 will be:\nCPILSU = 0.4\u00d7 6/2 + 0.2\u00d7 (6\u00d7 2) + 0.3\u00d7 2 + 0.1\u00d7 2\nCPILSU = 4.4\n\nSince CPIALU < CPILSU , integrating the ALU will improve the overall cycles-per-instructions.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_7/7.1",
        "context": "Consider an in-order fetch, out-of-order dispatch, and in-order retirement execution engine that employs Tomasulo's algorithm. This engine has the following characteristics:\n\n\u02c6 The engine has four main pipeline stages: Fetch (F), Decode (D), Execute (E), and Write-back (W).\n\n\u02c6 The engine can fetch one instruction per cycle, decode one instruction per cycle, and write back the result of one instruction per cycle.\n\n\u02c6 The engine has two execution units: 1) an adder to execute ADD instructions and 2) a multiplier to execute MUL instructions.\n\n\u02c6 The execution units are fully pipelined. The adder has two stages (E1-E2), and the multiplier has four stages (E1-E2-E3-E4). Execution of each stage takes one cycle.\n\n\u02c6 The adder has a two-entry reservation station, and the multiplier has a three-entry reservation station.\n\n\u02c6 An instruction always allocates the first available entry of the reservation station (in top-to-bottom order) of the corresponding execution unit.\n\n\u02c6 Full data forwarding is available, i.e., during the last cycle of the E stage, the tags and data are broadcast to the reservation station and the Register Alias Table (RAT). For example, an ADD instruction updates the reservation station entries of the dependent instructions in the E2 stage. So, the updated value can be read from the reservation station entry in the next cycle. Therefore, a dependent instruction can potentially begin its execution in the next cycle (after E2).\n\n\u02c6 The multiplier and adder have separate output data buses, which allow both the adder and the multiplier to update the reservation station and the RAT in the same cycle.\n\n\u02c6 An instruction continues to occupy a reservation station slot until it finishes the Write-back (W) stage. The reservation station entry is deallocated after the Write-back (W) stage.\nThe processor is about to fetch and execute five instructions. Assume the reservation stations (RS) are all initially empty, and the initial state of the register alias table (RAT) is given below in Figure (a). Instructions are fetched, decoded, and executed as discussed in class. At some point during the execution of the five instructions, a snapshot of the state of the RS and the RAT is taken. Figures (b) and (c) show the state of the RS and the RAT at the snapshot time. A dash (\u2013) indicates that a value has been cleared. A question mark (?) indicates that a value is unknown to you.",
        "context_figures": [
            "chart_p15_0.png"
        ],
        "question": "",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_7/7.2",
        "context": "Consider an in-order fetch, out-of-order dispatch, and in-order retirement execution engine that employs Tomasulo's algorithm. This engine has the following characteristics:\n\n\u02c6 The engine has four main pipeline stages: Fetch (F), Decode (D), Execute (E), and Write-back (W).\n\n\u02c6 The engine can fetch one instruction per cycle, decode one instruction per cycle, and write back the result of one instruction per cycle.\n\n\u02c6 The engine has two execution units: 1) an adder to execute ADD instructions and 2) a multiplier to execute MUL instructions.\n\n\u02c6 The execution units are fully pipelined. The adder has two stages (E1-E2), and the multiplier has four stages (E1-E2-E3-E4). Execution of each stage takes one cycle.\n\n\u02c6 The adder has a two-entry reservation station, and the multiplier has a three-entry reservation station.\n\n\u02c6 An instruction always allocates the first available entry of the reservation station (in top-to-bottom order) of the corresponding execution unit.\n\n\u02c6 Full data forwarding is available, i.e., during the last cycle of the E stage, the tags and data are broadcast to the reservation station and the Register Alias Table (RAT). For example, an ADD instruction updates the reservation station entries of the dependent instructions in the E2 stage. So, the updated value can be read from the reservation station entry in the next cycle. Therefore, a dependent instruction can potentially begin its execution in the next cycle (after E2).\n\n\u02c6 The multiplier and adder have separate output data buses, which allow both the adder and the multiplier to update the reservation station and the RAT in the same cycle.\n\n\u02c6 An instruction continues to occupy a reservation station slot until it finishes the Write-back (W) stage. The reservation station entry is deallocated after the Write-back (W) stage.\nQuestions",
        "context_figures": [],
        "question": "",
        "solution": "",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_7/7.2.1",
        "context": "Consider an in-order fetch, out-of-order dispatch, and in-order retirement execution engine that employs Tomasulo's algorithm. This engine has the following characteristics:\n\n\u02c6 The engine has four main pipeline stages: Fetch (F), Decode (D), Execute (E), and Write-back (W).\n\n\u02c6 The engine can fetch one instruction per cycle, decode one instruction per cycle, and write back the result of one instruction per cycle.\n\n\u02c6 The engine has two execution units: 1) an adder to execute ADD instructions and 2) a multiplier to execute MUL instructions.\n\n\u02c6 The execution units are fully pipelined. The adder has two stages (E1-E2), and the multiplier has four stages (E1-E2-E3-E4). Execution of each stage takes one cycle.\n\n\u02c6 The adder has a two-entry reservation station, and the multiplier has a three-entry reservation station.\n\n\u02c6 An instruction always allocates the first available entry of the reservation station (in top-to-bottom order) of the corresponding execution unit.\n\n\u02c6 Full data forwarding is available, i.e., during the last cycle of the E stage, the tags and data are broadcast to the reservation station and the Register Alias Table (RAT). For example, an ADD instruction updates the reservation station entries of the dependent instructions in the E2 stage. So, the updated value can be read from the reservation station entry in the next cycle. Therefore, a dependent instruction can potentially begin its execution in the next cycle (after E2).\n\n\u02c6 The multiplier and adder have separate output data buses, which allow both the adder and the multiplier to update the reservation station and the RAT in the same cycle.\n\n\u02c6 An instruction continues to occupy a reservation station slot until it finishes the Write-back (W) stage. The reservation station entry is deallocated after the Write-back (W) stage.\n",
        "context_figures": [],
        "question": "Based on the information provided above, identify the instructions and provide the dataflow graph below for the instructions that have been fetched. Please appropriately connect the nodes using edges and specify the direction of each edge. Label each edge with the destination architectural register and the corresponding Tag.",
        "solution": "R4 R7 R2 R1 R6\n\n+\n\n\u00d7\n\n\u00d7\n\nE/R3\n\nF/R5\n\nA/R4\n\n+\n\nL/R8\n\n\u00d7\n\nB/R9\n\nRegister IDs:",
        "solution_figures": [
            "chart_p16_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_7/7.2.2",
        "context": "Consider an in-order fetch, out-of-order dispatch, and in-order retirement execution engine that employs Tomasulo's algorithm. This engine has the following characteristics:\n\n\u02c6 The engine has four main pipeline stages: Fetch (F), Decode (D), Execute (E), and Write-back (W).\n\n\u02c6 The engine can fetch one instruction per cycle, decode one instruction per cycle, and write back the result of one instruction per cycle.\n\n\u02c6 The engine has two execution units: 1) an adder to execute ADD instructions and 2) a multiplier to execute MUL instructions.\n\n\u02c6 The execution units are fully pipelined. The adder has two stages (E1-E2), and the multiplier has four stages (E1-E2-E3-E4). Execution of each stage takes one cycle.\n\n\u02c6 The adder has a two-entry reservation station, and the multiplier has a three-entry reservation station.\n\n\u02c6 An instruction always allocates the first available entry of the reservation station (in top-to-bottom order) of the corresponding execution unit.\n\n\u02c6 Full data forwarding is available, i.e., during the last cycle of the E stage, the tags and data are broadcast to the reservation station and the Register Alias Table (RAT). For example, an ADD instruction updates the reservation station entries of the dependent instructions in the E2 stage. So, the updated value can be read from the reservation station entry in the next cycle. Therefore, a dependent instruction can potentially begin its execution in the next cycle (after E2).\n\n\u02c6 The multiplier and adder have separate output data buses, which allow both the adder and the multiplier to update the reservation station and the RAT in the same cycle.\n\n\u02c6 An instruction continues to occupy a reservation station slot until it finishes the Write-back (W) stage. The reservation station entry is deallocated after the Write-back (W) stage.\n",
        "context_figures": [],
        "question": "Fill in the blanks below with the five-instruction sequence in program order. There can be more than one correct ordering. Please provide only one correct ordering. When referring to registers, please use their architectural names (R0 through R9). Place the register with the smaller architectural name on the left source register box. For example, ADD R8 \u21d0 R1, R5.",
        "solution": "ADD R3 \u21d0 R4 , R7\n\nMUL R5 \u21d0 R3 , R2\n\nMUL R4 \u21d0 R5 , R4\n\nADD R8 \u21d0 R1 , R2\n\nMUL R9 \u21d0 R6 , R3",
        "solution_figures": [
            "chart_p16_1.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_6/a",
        "context": "Pipelining [65 points]\n\nConsider two pipelined machines implementing the MIPS ISA, Machine A and Machine B. Both machines\nhave one ALU and the following five pipeline stages, very similar to the basic 5-stage pipelined MIPS\nprocessor we discussed in lectures:\n\n1. Fetch (one clock cycle)\n\n2. Decode (one clock cycle)\n\n3. Execute (one clock cycle)\n\n4. Memory (one clock cycle)\n\n5. Write-back (one clock cycle).\n\nMachines A and B have the following specifications:\n\nMachine A Machine B\n\nData\nForward-\ning/Inter-\nlocking\n\nDoes NOT implement interlocking in hard-\nware. Relies on the compiler to order in-\nstructions or insert nop instructions such\nthat dependent instructions are correctly\nexecuted.\n\nImplements data dependence detection and\ndata forwarding in hardware. On detection\nof instruction dependence, it forwards an\noperand from the memory stage or from the\nwrite-back stage to the execute stage. The\nresult of a load instruction (lw) can only be\nforwarded from the write-back stage.\n\nInternal\nregister file\nforwarding\n\nImplemented (i.e., an instruction writes into\na register in the first half of a cycle and\nanother instruction can correctly access the\nsame register in the second half of the cycle).\n\nSame as Machine A\n\nBranch\nPrediction\n\nPredicts all branches as always-taken, and\nthe next program counter is available after\nthe decode stage.\n\nSame as Machine A\n\nConsider the following code segment:\n\nLoop: lw $1, 0($4)\nlw $2, 400($4)\nadd $3, $1, $2\nsw $3, 0($4)\nsub $4, $4, #4\nbnez $4, Loop\n\nInitially, $1 = 0, $2 = 0, $3 = 0, and $4 = 400.\n",
        "context_figures": [],
        "question": "Re-write the code segment above with minimal changes so that it gets correctly executed in Machine A with minimal latency. You can either insert nop instructions or reorder instructions as needed.",
        "solution": "Loop: lw $1, 0($4)\nlw $2, 400($4)\nnop\nnop\nadd $3, $1, $2\nnop\nnop\nsw $3, 0($4)\nsub $4, $4, #4\nnop\nnop\nbnez $4, Loop",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_6/b",
        "context": "Pipelining [65 points]\n\nConsider two pipelined machines implementing the MIPS ISA, Machine A and Machine B. Both machines\nhave one ALU and the following five pipeline stages, very similar to the basic 5-stage pipelined MIPS\nprocessor we discussed in lectures:\n\n1. Fetch (one clock cycle)\n\n2. Decode (one clock cycle)\n\n3. Execute (one clock cycle)\n\n4. Memory (one clock cycle)\n\n5. Write-back (one clock cycle).\n\nMachines A and B have the following specifications:\n\nMachine A Machine B\n\nData\nForward-\ning/Inter-\nlocking\n\nDoes NOT implement interlocking in hard-\nware. Relies on the compiler to order in-\nstructions or insert nop instructions such\nthat dependent instructions are correctly\nexecuted.\n\nImplements data dependence detection and\ndata forwarding in hardware. On detection\nof instruction dependence, it forwards an\noperand from the memory stage or from the\nwrite-back stage to the execute stage. The\nresult of a load instruction (lw) can only be\nforwarded from the write-back stage.\n\nInternal\nregister file\nforwarding\n\nImplemented (i.e., an instruction writes into\na register in the first half of a cycle and\nanother instruction can correctly access the\nsame register in the second half of the cycle).\n\nSame as Machine A\n\nBranch\nPrediction\n\nPredicts all branches as always-taken, and\nthe next program counter is available after\nthe decode stage.\n\nSame as Machine A\n\nConsider the following code segment:\n\nLoop: lw $1, 0($4)\nlw $2, 400($4)\nadd $3, $1, $2\nsw $3, 0($4)\nsub $4, $4, #4\nbnez $4, Loop\n\nInitially, $1 = 0, $2 = 0, $3 = 0, and $4 = 400.\n",
        "context_figures": [],
        "question": "Fill the table below with the timeline of the first loop iteration of the code segment in Machine A.",
        "solution": "Instruction\nClock cycle number\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n\nlw $1, 0($4) F D E M W\nlw $2, 400($4) F D E M W\nnop F D E M W\nnop F D E M W\nadd $3, $1, $2 F D E M W\nnop F D E M W\nnop F D E M W\nsw $3, 0($4) F D E M W\nsub $4, $4, #4 F D E M W\nnop F D E M W\nnop F D E M W\nbnez $4, Loop F D E M W",
        "solution_figures": [
            "chart_p13_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_6/c",
        "context": "Pipelining [65 points]\n\nConsider two pipelined machines implementing the MIPS ISA, Machine A and Machine B. Both machines\nhave one ALU and the following five pipeline stages, very similar to the basic 5-stage pipelined MIPS\nprocessor we discussed in lectures:\n\n1. Fetch (one clock cycle)\n\n2. Decode (one clock cycle)\n\n3. Execute (one clock cycle)\n\n4. Memory (one clock cycle)\n\n5. Write-back (one clock cycle).\n\nMachines A and B have the following specifications:\n\nMachine A Machine B\n\nData\nForward-\ning/Inter-\nlocking\n\nDoes NOT implement interlocking in hard-\nware. Relies on the compiler to order in-\nstructions or insert nop instructions such\nthat dependent instructions are correctly\nexecuted.\n\nImplements data dependence detection and\ndata forwarding in hardware. On detection\nof instruction dependence, it forwards an\noperand from the memory stage or from the\nwrite-back stage to the execute stage. The\nresult of a load instruction (lw) can only be\nforwarded from the write-back stage.\n\nInternal\nregister file\nforwarding\n\nImplemented (i.e., an instruction writes into\na register in the first half of a cycle and\nanother instruction can correctly access the\nsame register in the second half of the cycle).\n\nSame as Machine A\n\nBranch\nPrediction\n\nPredicts all branches as always-taken, and\nthe next program counter is available after\nthe decode stage.\n\nSame as Machine A\n\nConsider the following code segment:\n\nLoop: lw $1, 0($4)\nlw $2, 400($4)\nadd $3, $1, $2\nsw $3, 0($4)\nsub $4, $4, #4\nbnez $4, Loop\n\nInitially, $1 = 0, $2 = 0, $3 = 0, and $4 = 400.\n",
        "context_figures": [],
        "question": "Calculate the number of cycles it takes to execute the code segment on Machine A. Show your work in the box.",
        "solution": "Total number of cycles: 1303.\n\nExplanation:\nThe compiler reorders instructions and places six nop-s.\nThis is the execution timeline of the first iteration:\n\nEach iteration consists of 12 instructions. Since the next program counter is available\nafter the decode stage of bnez, the next iteration starts with an additional delay of 1\ncycle.\nThe last iteration takes 16 cycles, to drain the pipeline.\nThus the entire program runs for 99 * 13 + 16 = 1303 cycles.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_6/d",
        "context": "Pipelining [65 points]\n\nConsider two pipelined machines implementing the MIPS ISA, Machine A and Machine B. Both machines\nhave one ALU and the following five pipeline stages, very similar to the basic 5-stage pipelined MIPS\nprocessor we discussed in lectures:\n\n1. Fetch (one clock cycle)\n\n2. Decode (one clock cycle)\n\n3. Execute (one clock cycle)\n\n4. Memory (one clock cycle)\n\n5. Write-back (one clock cycle).\n\nMachines A and B have the following specifications:\n\nMachine A Machine B\n\nData\nForward-\ning/Inter-\nlocking\n\nDoes NOT implement interlocking in hard-\nware. Relies on the compiler to order in-\nstructions or insert nop instructions such\nthat dependent instructions are correctly\nexecuted.\n\nImplements data dependence detection and\ndata forwarding in hardware. On detection\nof instruction dependence, it forwards an\noperand from the memory stage or from the\nwrite-back stage to the execute stage. The\nresult of a load instruction (lw) can only be\nforwarded from the write-back stage.\n\nInternal\nregister file\nforwarding\n\nImplemented (i.e., an instruction writes into\na register in the first half of a cycle and\nanother instruction can correctly access the\nsame register in the second half of the cycle).\n\nSame as Machine A\n\nBranch\nPrediction\n\nPredicts all branches as always-taken, and\nthe next program counter is available after\nthe decode stage.\n\nSame as Machine A\n\nConsider the following code segment:\n\nLoop: lw $1, 0($4)\nlw $2, 400($4)\nadd $3, $1, $2\nsw $3, 0($4)\nsub $4, $4, #4\nbnez $4, Loop\n\nInitially, $1 = 0, $2 = 0, $3 = 0, and $4 = 400.\n",
        "context_figures": [],
        "question": "Fill the table below with the timeline of the first loop iteration of the code segment in Machine B.",
        "solution": "Instruction\nClock cycle number\n\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\n\nlw $1, 0($4) F D E M W\nlw $2, 400($4) F D E M W\nadd $3, $1, $2 F D * E M W\nsw $3, 0($4) F * D E M W\nsub $4, $4, #4 F D E M W\nbnez $4, Loop F D E M W\nlw $1, 0($4) * F D E M W",
        "solution_figures": [
            "chart_p14_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "digitaltechnik-s21-en-sol/Problem_6/e",
        "context": "Pipelining [65 points]\n\nConsider two pipelined machines implementing the MIPS ISA, Machine A and Machine B. Both machines\nhave one ALU and the following five pipeline stages, very similar to the basic 5-stage pipelined MIPS\nprocessor we discussed in lectures:\n\n1. Fetch (one clock cycle)\n\n2. Decode (one clock cycle)\n\n3. Execute (one clock cycle)\n\n4. Memory (one clock cycle)\n\n5. Write-back (one clock cycle).\n\nMachines A and B have the following specifications:\n\nMachine A Machine B\n\nData\nForward-\ning/Inter-\nlocking\n\nDoes NOT implement interlocking in hard-\nware. Relies on the compiler to order in-\nstructions or insert nop instructions such\nthat dependent instructions are correctly\nexecuted.\n\nImplements data dependence detection and\ndata forwarding in hardware. On detection\nof instruction dependence, it forwards an\noperand from the memory stage or from the\nwrite-back stage to the execute stage. The\nresult of a load instruction (lw) can only be\nforwarded from the write-back stage.\n\nInternal\nregister file\nforwarding\n\nImplemented (i.e., an instruction writes into\na register in the first half of a cycle and\nanother instruction can correctly access the\nsame register in the second half of the cycle).\n\nSame as Machine A\n\nBranch\nPrediction\n\nPredicts all branches as always-taken, and\nthe next program counter is available after\nthe decode stage.\n\nSame as Machine A\n\nConsider the following code segment:\n\nLoop: lw $1, 0($4)\nlw $2, 400($4)\nadd $3, $1, $2\nsw $3, 0($4)\nsub $4, $4, #4\nbnez $4, Loop\n\nInitially, $1 = 0, $2 = 0, $3 = 0, and $4 = 400.\n",
        "context_figures": [],
        "question": "Calculate the number of cycles it takes to execute the code segment on Machine B. Show your work in the box.",
        "solution": "Total number of cycles: 803.\n\nExplanation:\n1 - Foward $2 from W to E in cycle 6.\n2 - Foward $3 from M to E in cycle 7.\n3 - Foward $4 from M to E in cycle 9.\n\nEach iteration takes 8 cycles, including one cycle delay after bnez, because to the next\nprogram counter is available only after the decode stage of bnez.\nThe last iteration takes 11 cycles, to drain the pipeline.\nThus total number of cycles is 99*8 + 11 = 803 cycles.",
        "solution_figures": [],
        "correctly_parsed": null
    }
]