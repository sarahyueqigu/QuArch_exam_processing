```json
{
  "exam_name": "740: Computer Architecture, Fall 2013",
  "problems": [
    {
      "problem": "Problem 1: Potpourri",
      "parts": [
        {
          "part": "A",
          "question": [
            {
              "subproblem_question": "Provide one reason why prioritizing a memory non-intensive thread over a memory-intensive one in the memory controller would improve performance. If this is not possible, write N/A and explain why."
            },
            {
              "subproblem_question": "Provide one reason why doing the same would degrade performance. If this is not possible, write N/A and explain why."
            }
          ],
          "answer": [
            {
              "solution": "Prioritizing latency-sensitive (memory non-intensive) threads can increase system throughput"
            },
            {
              "solution": "Can delay the critical/bottleneck thread which may not be memory non-intensive"
            }
          ]
        },
        {
          "part": "B",
          "question": [
            {
              "subproblem_question": "Under what conditions would an application's performance increase linearly as memory bandwidth is increased?"
            }
          ],
          "answer": [
            {
              "solution": "If memory bandwidth is the performance bottleneck"
            }
          ]
        },
        {
          "part": "C",
          "question": [
            {
              "subproblem_question": "What problem does the fat tree interconnect solve that is present in the tree interconnect?"
            }
          ],
          "answer": [
            {
              "solution": "High link contention between root and subnodes - a fat tree increases the bandwidth of these links"
            }
          ]
        },
        {
          "part": "D",
          "question": [
            {
              "subproblem_question": "You are observing a system with many processing elements connected through a network. There is currently no activity on the network (no messages are being sent). On cycle 10, one of the cores generates a message destined for a cache bank somewhere else on the network. You observe the network on cycle 20 and see that this message has not departed the source location. Assume that all components are enabled (not powered off) and operating at full speed. There are no other messages present in the system at this time. Why could this be?"
            }
          ],
          "answer": [
            {
              "solution": "The system is using circuit switching, and there is a large delay to set up all links between source and destination."
            }
          ]
        },
        {
          "part": "E",
          "question": [
            {
              "subproblem_question": "Suppose we have a mechanism that tries to estimate the exact slack of a memory request when the request is injected into the shared resources. Provide two reasons why estimating the exact slack of a packet might be difficult:"
            },
            {
              "subproblem_question": "What performance issue can slack-based prioritization cause to other processors in the system? Why?"
            },
            {
              "subproblem_question": "How can you solve this problem?"
            }
          ],
          "answer": [
            {
              "solution": "The exact latency of the request may not be known at the time of injection - the slack may change based on the state of the shared resources and the decisions made by them"
            },
            {
              "solution": "How much the packet would affect performance may not be known at the time of injection - the overlap of latency of the packet may not be known at the time of injection"
            },
            {
              "solution": "Can cause starvation to some threads"
            },
            {
              "solution": "Batching"
            }
          ]
        },
        {
          "part": "F",
          "question": [
            {
              "subproblem_question": "What is the purpose of token tagging in dynamic dataflow architectures?"
            }
          ],
          "answer": [
            {
              "solution": "Supporting re-entrant code. Ensuring that tokens come from same context."
            }
          ]
        },
        {
          "part": "G",
          "question": [
            {
              "subproblem_question": "What access patterns could benefit from this instruction? Explain well."
            },
            {
              "subproblem_question": "The Alpha 21264 processor employed a predictor that predicted whether a load would hit or miss in the cache before the load accessed the cache. What was the purpose of using this predictor? Explain concisely but with enough detail."
            }
          ],
          "answer": [
            {
              "solution": "Streaming or striding access pattern (no data reuse)"
            },
            {
              "solution": "Allow speculative scheduling of consumers of the load"
            }
          ]
        }
      ]
    },
    {
      "problem": "Problem 2: Multithreading",
      "problem_context": "Suppose your friend designed the following fine-grained multithreaded machine:\n\n- The pipeline has 22 stages and is 1 instruction wide.\n- Branches are resolved at the end of the 18th stage and there is a 1 cycle delay after that to communicate the branch target to the fetch stage.\n- The data cache is accessed during stage 20. On a hit, the thread does not stall. On a miss, the thread stalls for 100 cycles, fixed. The cache is non-blocking and has space to accommodate 16 outstanding requests.\n- The number of hardware contexts is 200 .\n\nAssuming that there are always enough threads present, answer the following questions:",
      "parts": [
        {
          "part": "A",
          "question": [
            {
              "subproblem_question": "Can the pipeline always be kept full and non-stalling? Why or why not? (Hint: think about the worst case execution characteristics.)"
            }
          ],
          "answer": [
            {
              "solution": "NO - will stall when more than 16 outstanding misses in pipe"
            }
          ]
        },
        {
          "part": "B",
          "question": [
            {
              "subproblem_question": "Can the pipeline always be kept full and non-stalling if all accesses hit in the cache? Why or why not?"
            }
          ],
          "answer": [
            {
              "solution": "YES - switching between 200 threads is plenty to avoid stalls due to branch prediction delay"
            }
          ]
        },
        {
          "part": "C",
          "question": [
            {
              "subproblem_question": "Assume that all accesses hit in the cache and your friend wants to keep the pipeline always full and non-stalling. How would you adjust the hardware resources (if necessary) to satisfy this while minimizing hardware cost? You cannot change the latencies provided above. Be comprehensive and specific with numerical answers. If nothing is necessary, justify why this is the case."
            }
          ],
          "answer": [
            {
              "solution": "Reduce hardware thread contexts to 19 , the minimum to keep pipe full/non-stalling"
            }
          ]
        },
        {
          "part": "D",
          "question": [
            {
              "subproblem_question": "Assume that all accesses miss in the cache and your friend wants to keep the pipeline always full and non-stalling. How would you adjust the hardware resources (if necessary) to satisfy this while minimizing hardware cost? You cannot change the latencies provided above. Be comprehensive and specific with numerical answers. If nothing is necessary, justify why this is the case."
            }
          ],
          "answer": [
            {
              "solution": "Reduce hardware thread contexts to 100 , the minimum to keep pipe full/non-stalling. Increase capability to support 100 outstanding misses"
            }
          ]
        }
      ]
    },
    {
      "problem": "Problem 3: Return of Tomasulo's Algorithm",
      "problem_context": "The diagram below shows a snapshot at a particular point in time of various parts (reservation stations and register alias table) of the microarchitecture for an implementation supporting out-of-order execution in the spirit of Tomasulo's Algorithm. Note that there is an adder and a multiplier in this machine. The processor is supplied with a seven instruction program following reset. The state below was captured at some point in time during the execution of these seven instructions. Anything marked with a - is unknown and can't be relied upon for your answer. You should assume that the bottommost instruction in the reservation station arrived earliest and the topmost instruction in the reservation station arrived last.",
      "problem_figures": [
        "TABLE",
        "IMAGE",
        "TABLE"
      ],
      "parts": [
        {
          "part": "A",
          "question": [
            {
              "subproblem_question": "Identify the instructions and draw the data flow graph for the seven instructions (use + for ADD and * for MUL). Please label the edges of the data flow graph with the destination register tag if known. Label with register number if the tag is not known. Note that the first instruction is an ADD with destination register R3."
            }
          ],
          "answer": [
            {
              "solution": "IMAGE"
            }
          ]
        },
        {
          "part": "B",
          "question": [
            {
              "subproblem_question": "Fill in the instruction opcodes, source, and destination registers in the table below."
            }
          ],
          "answer": [
            {
              "solution": "TABLE"
            }
          ]
        }
      ]
    },
    {
      "problem": "Problem 4: Tiered-difficulty",
      "problem_context": "Recall from your required reading on Tiered-Latency DRAM that there is a near and far segment, each containing some number of rows. Assume a very simplified memory model where there is just one bank and there are two rows in the near segment and four rows in the far segment. The time to activate and precharge a row is 25 ns in the near segment and 50 ns in the far segment. The time from start of activation to reading data is 10 ns in the near segment and 15 ns in the far segment. All other timings are negligible for this problem. Given the following memory request stream, determine the optimal assignment (minimize average latency of requests) of rows in the near and far segment (assume a fixed mapping where rows cannot migrate, a closed-row policy, and the far segment is inclusive).",
      "parts": [
        {
          "part": "A",
          "question": [
            {
              "subproblem_question": "What rows would you place in near segment? Hint: draw a timeline."
            }
          ],
          "answer": [
            {
              "solution": "rows 0 and 2 . see above"
            }
          ]
        },
        {
          "part": "B",
          "question": [
            {
              "subproblem_question": "What rows would you place in far segment?"
            }
          ],
          "answer": [
            {
              "solution": "rows 1 and 3 (also rows 0 and 2 since inclusive). see above"
            }
          ]
        },
        {
          "part": "C",
          "question": [
            {
              "subproblem_question": "In 15 words or less, describe the insight in your mapping?"
            }
          ],
          "answer": [
            {
              "solution": "See TL-DRAM's WMC policy - the first access in near simultaneous requests causes the second to wait activation + precharge time. minimizing this wait by caching first row in near segment is better than caching second row in near segment (this decreases only time to read from start of activation), even if second row is accessed more frequently (see example above)"
            }
          ]
        },
        {
          "part": "D",
          "question": [
            {
              "subproblem_question": "Assume now that the mapping is dynamic. What are the tradeoffs of an exclusive design vs. an inclusive design? Name one advantage and one disadvantage for each."
            }
          ],
          "answer": [
            {
              "solution": "Exclusive requires swapping, but can use nearly full capacity of DRAM. Inclusive, the opposite."
            }
          ]
        },
        {
          "part": "E",
          "question": [
            {
              "subproblem_question": "Assume now that there are eight (8) rows in the near segment. Below is a plot showing the number of misses to the near segment for three applications (A, B, and C) when run alone with the specified number of rows allocated to the application in the near segment. This is similar to the plots you saw in your Utility-Based Cache Partitioning reading except for TL-DRAM instead of a cache. Determine the optimal static partitioning of the near segment when all three of these applications are run together on the system. In other words, how many rows would you allocate for each application? Hint: this should sum to eight. Optimal for this problem is defined as minimizing total misses across all applications."
            },
            {
              "subproblem_question": "How many near segment rows would you allocate to A?"
            },
            {
              "subproblem_question": "How many near segment rows would you allocate to B?"
            },
            {
              "subproblem_question": "How many near segment rows would you allocate to C?"
            }
          ],
          "answer": [
            {
              "solution": "IMAGE"
            },
            {
              "solution": "5"
            },
            {
              "solution": "3"
            },
            {
              "solution": "0"
            }
          ]
        }
      ]
    },
    {
      "problem": "Problem 5: GPUs",
      "problem_context": "We define the SIMD utilization of a program running on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\nThe following code segment is running on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A, B, and C are already in vector registers so there are no loads and stores in this program. (Hint: Notice that there are 5 instructions in each thread as labled below.) A warp in the GPU consists of 64 threads, and there are 64 SIMD lanes in the GPU.",
      "parts": [
        {
          "part": "A",
          "question": [
            {
              "subproblem_question": "How many warps does it take to execute this program?"
            }
          ],
          "answer": [
            {
              "solution": "16384 / 64=256"
            }
          ]
        },
        {
          "part": "B",
          "question": [
            {
              "subproblem_question": "As shown below, assume array A has a repetitive pattern which has 32 ones followed by 96 zeros repetitively and array B has a different repetitive pattern which has 64 zeros followed by 64 ones repetitively. What is the SIMD utilization of this program?"
            }
          ],
          "answer": [
            {
              "solution": "When a warp is working on a segment of array A that has 640 s , none of the threads in the warp will take the branch, which yields no branch divergence of the warp. Hence, the SIMD utilization of this particular input set is (64+64+32 * 4)/(64+64 * 5)=66.7 %"
            }
          ]
        },
        {
          "part": "C",
          "question": [
            {
              "subproblem_question": "Is it possible for this program to yield a SIMD utilization of 25 % ?"
            },
            {
              "subproblem_question": "If YES, what should be true about arrays A and B for the SIMD utilization to be 25 % ? Be precise and show your work. If NO, explain why not."
            }
          ],
          "answer": [
            {
              "solution": "Yes. For example, if only 4 elements in every 64 elements of A are positive, we can have a SIMD utilization of (64+4 * 4)/(64 * 5)=25 %."
            }
          ]
        },
        {
          "part": "D",
          "question": [
            {
              "subproblem_question": "Is it possible for this program to yield a SIMD utilization of 20 % ?"
            },
            {
              "subproblem_question": "If YES, what should be true about arrays A and B for the SIMD utilization to be 20 % ? Be precise and show your work. If NO, explain why not."
            }
          ],
          "answer": [
            {
              "solution": "No. The smallest SIMD utilization one can get is to have one and only one element in every 64 elements of A to be positive, which yields a minimal SIMD utilization of (64+1 * 4)/(64 * 5)= 21.25 %, which is still greater than 20 %."
            }
          ]
        },
        {
          "part": "E",
          "question": [
            {
              "subproblem_question": "During an execution with a particular input array A, which has exactly 24 positive elements in every 64 elements, Hongyi finds that the SIMD utilization of the program is 50 %. Based on this observation, Hongyi claims that any input array that has an average of 24 out of 64 elements positive would yield a 50 % SIMD utilization. Is Hongyi correct?"
            },
            {
              "subproblem_question": "If YES, show your work. If NO, provide a counterexample."
            }
          ],
          "answer": [
            {
              "solution": "Hongyi is incorrect. If A has a repetitive pattern of 48 contiguous 1 s followed by 80 contiguous 0 s , in which case 37.5 % of the elements are positive on average, then the SIMD utilization of the program will be 83.3 % rather than 50 %."
            }
          ]
        }
      ]
    },
    {
      "problem": "Problem 6: Hyperblock",
      "problem_context": "As described in class, Hyperblock scheduling uses predication support to replace unbiased branches with predicates, which enables larger code blocks.",
      "parts": [
        {
          "part": "A",
          "question": [
            {
              "subproblem_question": "In one sentence, in terms of code optimizations, explain what benefit does larger scheduling code blocks provide?"
            }
          ],
          "answer": [
            {
              "solution": "Larger scheduling code blocks enable greater flexibility for instruction scheduling."
            }
          ]
        },
        {
          "part": "B",
          "question": [
            {
              "subproblem_question": "For the example above, can Instruction Promotion ever improve system performance? Why or why not?"
            }
          ],
          "answer": [
            {
              "solution": "Yes it can. With Instruction Promotion, the program can hide some of the load latency."
            }
          ]
        },
        {
          "part": "C",
          "question": [
            {
              "subproblem_question": "For the example above, can Instruction Promotion ever degrade system performance? Why or why not?"
            }
          ],
          "answer": [
            {
              "solution": "Yes it can. Instruction Promotion: (1) introduces extra instructions and (2) can increase register pressure. [Note that extra instructions may not always increase register pressure]"
            }
          ]
        },
        {
          "part": "D",
          "question": [
            {
              "subproblem_question": "The graph above shows the performance comparison of a program optimized using Hyperblock and Superblock respectively with different issue widths. With all other factors being equal, as the figure shows, when the issue width is low, Superblock provides higher speedup than Hyperblock. However, when the issue width is high, Hyperblock provides higher speedup than Superblock. Explain why this can happen?"
            }
          ],
          "answer": [
            {
              "solution": "A wider issue width can tolerate the wasted instructions in a hyperblock, but does not benefit the superblock (all else being equal).\n\nA more detailed explanation: Hyperblock uses predication which increases the total number of instructions to execute. When the issue width is low, executing extra predicated instructions requires extra work, which slows down the processor as all resources of the processor has already been fully utilized. When the issue width is high, however, Hyperblock provides a greater number of independent instructions from the multiple paths of control to fill the available processor resources. As Hyperblock also enables larger code blocks for better optimization for unbiased branches, Hyperblock provides better speedup."
            }
          ]
        }
      ]
    }
  ]
}
```