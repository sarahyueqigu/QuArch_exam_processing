```json
{
  "exam_name": "Final Exam",
  "problems": [
    {
      "problem": "1 Boolean Logic Circuits",
      "problem_context": "During your job interview, you are asked to design a combinational circuit with a four-bit input, {A, B, C, D} (A is the most significant bit and D is the least significant bit), and two 1-bit outputs, Fib and G3. The value of each output is determined as follows:",
      "problem_figures": [],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "Fill in the missing entries in the truth table below for the combinational circuit you are designing and express the output Fib in the sum of products representation."
            }
          ],
          "answer": [
            {
              "solution": "| Inputs |  |  |  | Outputs |  |\n| :--: | :--: | :--: | :--: | :--: | :--: |\n| $A$ | $B$ | $C$ | $D$ | Fib | $G 3$ |\n| 0 | 0 | 0 | 0 | 1 | 0 |\n| 0 | 0 | 0 | 1 | 1 | 0 |\n| 0 | 0 | 1 | 0 | 1 | 0 |\n| 0 | 0 | 1 | 1 | 1 | 0 |\n| 0 | 1 | 0 | 0 | 0 | 1 |\n| 0 | 1 | 0 | 1 | 1 | 1 |\n| 0 | 1 | 1 | 0 | 0 | 1 |\n| 0 | 1 | 1 | 1 | 0 | 1 |\n| 1 | 0 | 0 | 0 | 1 | 1 |\n| 1 | 0 | 0 | 1 | 0 | 1 |\n| 1 | 0 | 1 | 0 | 0 | 1 |\n| 1 | 0 | 1 | 1 | 0 | 1 |\n| 1 | 1 | 0 | 0 | 0 | 1 |\n| 1 | 1 | 0 | 1 | 1 | 1 |\n| 1 | 1 | 1 | 0 | 0 | 1 |\n| 1 | 1 | 1 | 1 | 0 | 1 |\n\n$\operatorname{Fib}=(\bar{A} \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(\bar{A} \cdot \bar{B} \cdot \bar{C} \cdot D)+(\bar{A} \cdot \bar{B} \cdot C \cdot \bar{D})+(\bar{A} \cdot \bar{B} \cdot C \cdot D)+(\bar{A} \cdot B \cdot \bar{C} \cdot D)+$ $(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(A \cdot B \cdot \bar{C} \cdot D)$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "Simplify the Fib expression using Boolean minimization rules. Show your work step-by-step."
            }
          ],
          "answer": [
            {
              "solution": "$\begin{aligned} & \text { Fib }=(\bar{A} \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(\bar{A} \cdot \bar{B} \cdot \bar{C} \cdot D)+(\bar{A} \cdot \bar{B} \cdot C \cdot \bar{D})+(\bar{A} \cdot \bar{B} \cdot C \cdot D)+(\bar{A} \cdot B \cdot \bar{C} \cdot D)+ \\ & (A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(A \cdot B \cdot \bar{C} \cdot D) \\ & \text { Fib }=((\bar{A} \cdot \bar{B}) \cdot((\bar{C} \cdot \bar{D})+(\bar{C} \cdot D)+(C \cdot \bar{D})+(C \cdot D)))+(\bar{A} \cdot B \cdot \bar{C} \cdot D)+(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(A \cdot B \cdot \bar{C} \cdot D) \\ & \text { Fib }=((\bar{A} \cdot \bar{B}) \cdot(1))+(\bar{A} \cdot B \cdot \bar{C} \cdot D)+(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(A \cdot B \cdot \bar{C} \cdot D) \\ & \text { Fib }=(\bar{A} \cdot \bar{B})+(\bar{A} \cdot B \cdot \bar{C} \cdot D)+(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(A \cdot B \cdot \bar{C} \cdot D) \\ & \text { Fib }=(\bar{A} \cdot \bar{B})+(\bar{C} \cdot((\bar{A} \cdot B \cdot D)+(A \cdot \bar{B} \cdot \bar{D})+(A \cdot B \cdot D))) \\ & \text { Fib }=(\bar{A} \cdot \bar{B})+(\bar{C} \cdot((B \cdot D)+(A \cdot \bar{B} \cdot \bar{D}))) \\ & \text { Fib }=(\bar{A} \cdot \bar{B})+(B \cdot \bar{C} \cdot D)+(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D}) \\ & \text { Fib }=(\bar{A} \cdot \bar{B})+(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(B \cdot \bar{C} \cdot D) \\ & \text { Fib }=(\bar{A} \cdot \bar{B})+(\bar{B} \cdot \bar{C} \cdot \bar{D})+(B \cdot \bar{C} \cdot D) \end{aligned}$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "c",
          "question": [
            {
              "subproblem_question": "Find the simplest representation of the G3 output by using only 2-input NAND gates. Show your work step-by-step."
            }
          ],
          "answer": [
            {
              "solution": "# $G 3=\overline{(\bar{A} \cdot \bar{A}) \cdot(\bar{B} \cdot \bar{B})}$\n## Explanation:\n$G 3=(\bar{A} \cdot B \cdot \bar{C} \cdot \bar{D})+(\bar{A} \cdot B \cdot \bar{C} \cdot D)+(\bar{A} \cdot B \cdot C \cdot \bar{D})+(\bar{A} \cdot B \cdot C \cdot D)+(A \cdot \bar{B} \cdot \bar{C} \cdot \bar{D})+(A \cdot \bar{B} \cdot \bar{C}$ $\\left.D)+(A \\cdot \\bar{B} \\cdot C \\cdot \\bar{D})+(A \\cdot \\bar{B} \\cdot C \\cdot D)+(A \\cdot B \\cdot \\bar{C} \\cdot \\bar{D})+(A \\cdot B \\cdot \\bar{C} \\cdot D)+(A \\cdot B \\cdot C \\cdot \\bar{D})+(A \\cdot B \\cdot C \\cdot D)$\n$G 3=(\\bar{A} \\cdot B \\cdot((\\bar{C} \\cdot \\bar{D})+(\\bar{C} \\cdot D)+(C \\cdot \\bar{D})+(C \\cdot D)))+(A \\cdot \\bar{B} \\cdot((\\bar{C} \\cdot \\bar{D})+(\\bar{C} \\cdot D)+(C \\cdot \\bar{D})+(C \\cdot D)))+(A \\cdot B \\cdot((\\bar{C} \\cdot \\bar{D})+(\\bar{C} \\cdot D)+(C \\cdot \\bar{D})+(C \\cdot D)))$\n$G 3=(\\bar{A} \\cdot B \\cdot(1))+(A \\cdot \\bar{B} \\cdot(1))+(A \\cdot B \\cdot(1))$\n$G 3=(\\bar{A} \\cdot B)+(A \\cdot \\bar{B})+(A \\cdot B)$\n$G 3=A+B$\n$G 3=\\overline{\\bar{A}+\\bar{B}}$\n$G 3=\\overline{\\bar{A} \\cdot \\bar{B}}$\n$G 3=\\overline{(\\bar{A} \\cdot \\bar{A}) \\cdot(\\bar{B} \\cdot \\bar{B})}$",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "2 Finite State Machines",
      "problem_figures": ["IMAGE"],
      "parts": [
        {
          "part": "2.1",
          "question": [
            {
              "subproblem_question": "Is it possible to simplify this state diagram and reduce the number of states? If so, simplify it to the minimum number of states. Explain each step of your simplification. Draw the simplified state diagram. If not, explain why it is not possible to simplify the state diagram."
            }
          ],
          "answer": [
            {
              "solution": "Yes, it is possible. Below is the state transition table of the given state machine:\n\n| Current State | Input | Next State | Output |\n| :--: | :--: | :--: | :--: |\n| A | 0 | A | 1 |\n| A | 1 | B | 0 |\n| B | 0 | A | 1 |\n| B | 1 | B | 0 |\n| C | 0 | D | 1 |\n| C | 1 | A | 0 |\n| D | 0 | A | 1 |\n| D | 1 | B | 0 |\n\nWe can see that the states A, B, and D are identical. For all of these states,\n- an input of 0 leads to the next state A and the output 1\n- an input of 1 leads to the next state B and the output 0\n\nTherefore, we can merge states A, B, and D. Let's use the name X:\n\n| Current State | Input | Next State | Output |\n| :--: | :--: | :--: | :--: |\n| X | 0 | X | 1 |\n| X | 1 | X | 0 |\n| C | 0 | X | 1 |\n| C | 1 | X | 0 |\n\nWe can further simplify this state machine as both states C and X are identical in terms of their next state and output. As a result, this state machine has only one state and the output is always the inverse of the input.",
              "solution_figures": ["IMAGE"]
            }
          ]
        },
        {
          "part": "2.2",
          "question": [
            {
              "subproblem_question": "Design a Moore finite state machine (FSM), where each output is solely determined by the current state of the machine and not directly influenced by the inputs. The state machine should have one input and one output. This FSM's goal is to detect a stable transition in the input signal from repeated logic-0 to repeated logic-1. The output should be logic-1 only when the input sequence of \"0-0-1-1\" is observed. The output should be zero in all other cases.\n\nWhen the circuit is reset, your state machine should assume that the input signal has been high (logic-1) for a long time. Draw the state diagram and explain why it works. Your state machine should use as few states as possible and each state should have a precise definition and output."
            }
          ],
          "answer": [
            {
              "solution": "We need to keep track of the bit values in the last four bits. This requires 16 states. However, many of these states behave the same. We can reduce the number of states down to five.\n\n- Since this is a Moore machine, the output should be independent from the input. Therefore, there should be a state for the posedge where the output is \"1\". All other states will have the output of \"0\". The FSM goes to the posedge state only when the last four bits are 0-0-1-1. We call this state S0011.\n- The FSM should reach to the posedge state from another state where the last three input bits are 0-0-1. We call this state SX001.\n- The FSM should reach to the 0-0-1 state from a state where the last two input bits are 0-0. Note that it does not matter what the input bits are, earlier than the last two zeros. We call this state SXX01.\n- The FSM should not stay in state S0011 for more than one clock cycle as when the new input comes, the last four bits will not be 0-0-1-1 anymore. If the input is 1, the next state should be SXXX1: the last bit is zero but it is not a posedge and the earlier bits are not important. If the input is 0, the next state should be SXX10: the last two bits are 1-0 and the earlier bits are not important.\n- Intuitively, if the state is SXXX1, the FSM should remain at this state if the input is 1 and go to SXX10 if the input is 0.\n- If the state is SXX10, the FSM should not remain at this state regardless of the input. If the input is 0, the next state is SXX00. If the input is 1, the next state is SXXX1.\nTherefore, it is possible to design this state machine with five states. The state diagram is shown below.",
              "solution_figures": ["IMAGE"]
            }
          ]
        }
      ]
    },
    {
      "problem": "3 ISA vs. Microarchitecture",
      "problem_figures": [],
      "parts": [
        {
          "part": "1",
          "question": [
            {
              "subproblem_question": "Width of the immediate value in an ADD instruction."
            }
          ],
          "answer": [
            {
              "solution": "1. ISA",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "2",
          "question": [
            {
              "subproblem_question": "The algorithm used by the ALU to perform multiplication."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "3",
          "question": [
            {
              "subproblem_question": "Number of bits required for indexing the source register of a store instruction."
            }
          ],
          "answer": [
            {
              "solution": "1. ISA",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "4",
          "question": [
            {
              "subproblem_question": "Number of entries in the L3 cache."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "5",
          "question": [
            {
              "subproblem_question": "The data cache organization (e.g., direct-mapped, set-associative)."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "6",
          "question": [
            {
              "subproblem_question": "Support for conveying prefetching hints to the hardware via the compiler."
            }
          ],
          "answer": [
            {
              "solution": "1. ISA",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "7",
          "question": [
            {
              "subproblem_question": "Available data types (e.g., integer) for arithmetic and logic operations."
            }
          ],
          "answer": [
            {
              "solution": "1. ISA",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "8",
          "question": [
            {
              "subproblem_question": "Cache coherence protocol in multi-core processors."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "9",
          "question": [
            {
              "subproblem_question": "Width of the data bus between the processor and main memory."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "10",
          "question": [
            {
              "subproblem_question": "The memory controller's memory request scheduling algorithm."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "11",
          "question": [
            {
              "subproblem_question": "Instruction encoding for control flow and branch instructions."
            }
          ],
          "answer": [
            {
              "solution": "1. ISA",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "12",
          "question": [
            {
              "subproblem_question": "The design of the register renaming logic."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "13",
          "question": [
            {
              "subproblem_question": "Number of instructions decoded per cycle in a superscalar processor."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "14",
          "question": [
            {
              "subproblem_question": "L2 cache miss latency."
            }
          ],
          "answer": [
            {
              "solution": "2. Microarchitecture",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "15",
          "question": [
            {
              "subproblem_question": "Width of the program counter."
            }
          ],
          "answer": [
            {
              "solution": "1. ISA",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "4 Verilog",
      "problem_figures": [],
      "parts": [
        {
          "part": "4.1",
          "question": [
            {
              "subproblem_question": "Analyze the following Verilog module and answer the question.\n\n```module module_x (input wire clk, input wire rst, input wire [7:0] in, output wire [7:0] out);\nreg [7:0] var1, var2, var3, var4;\nassign out = (var4 == in) ? var3 : var4;\nalways @(posedge clk) begin\n    if (rst) begin\n        var1 <= 8'b0; var2 <= 8'b1;\n        var3 <= 8'b0; var4 <= 8'b0;\n    end else begin\n        var1 <= var2; var2 <= var1 + var2;\n        var3 <= var1 + var2;\n        var4 <= var4 + 8'b1;\n    end\n    end\n    endmodule```\n\nAssume that the input in always has the following value:\nin = 8'h09\nWhat unsigned decimal values does the out signal get in the following waveform diagram? Fill in the gray boxes with an out value for each clk cycle. Briefly explain your answer."
            }
          ],
          "answer": [
            {
              "solution": "The module outputs the inth number in the Fibonacci sequence after in clock cycles. Until then, it outputs the number of clock cycles that have passed since reset.\nFor the given value of in (8'h09), the values for out are from leftmost yellow box to the rightmost yellow box:\n$0,1,2,3,4,5,6,7,8,55$",
              "solution_figures": ["IMAGE"]
            }
          ]
        },
        {
          "part": "4.2",
          "question": [
            {
              "subproblem_question": "You gave ChatGPT the following prompt to help with your lab report: \"A Verilog module that simulates a character's movement on a 2D-plane. The module takes four inputs for four directions (direction inputs) the character can move to. The module outputs x and y coordinates. The character stays in the same coordinate if none of the direction inputs are set. Initial coordinates (set on reset) are 0,0. Stride determines how many units the character moves in one step.\"\n\n```module movement {\n    input clk, input rst,\n    input up, input down,\n    input left, input right,\n    (3) stride,\n    output [7:0] x_coord,\n    output [7:0] y_coord\n};\n(2) x_internal, y_internal; // 8-bit signals\nwire [2:0] move_amount = 3; // if stride is not zero, move by stride amount, else move by 1\nalways @(posedge clk) begin\n    if (rst) begin\n        x_internal <= 0; y_internal <= 0;\n    end else begin\n        if (up) y_internal <= y_internal + move_amount;\n        else if (down) y_internal <= y_internal - move_amount;\n        else if (left) x_internal <= x_internal - move_amount;\n        x_internal <= x_internal + move_amount;\n    end\nend\n(4) x_coord = x_internal; // output coordinate\n(4) y_coord = y_internal; // output coordinate\nendmodule```\n\nProvide your choice for each blank (1), (2), and (4) below. Circle only one of A, B, C, D. Provide a one-line expression for (3) (Hint: Use the ternary operator (?) to implement a MUX).\n(1): A. output\nB. output reg\nC. input wire [2:0]\nD. input reg\n(2): A. wire [7: 0]\nB. [7: 0] wire\nC. wire [8: 0]\nD. reg [7: 0]\n(3):\nstride != 3'b0 ? stride : 3'b1;\n(4): A.\nB. assign\nC. ==\nD. let\n\n## Explanation.\n(1): Signal stride is used as an input to the module, so it should be declared as an input. Among options that describe input signals (C and D), input reg is not valid Verilog syntax.\n(2): The correct way to describe signals that we can assign values to in an always block is reg [7:0].\n(3): We describe a mux using the ternary operator as such: stride != 3'b0 ? stride : 3'b1;. If stride is zero, the left-hand side of the ternary operator (i.e., stride) is the output of the mux and otherwise the right-hand side (i.e., 3'b1) is the output of the mux.\n(4): The correct syntax for assigning a value to a signal is assign x_coord = x_internal;. Other options are not valid Verilog syntax.\n\nDid ChatGPT inject any errors in this code? Write down line number(s) and a short explanation (to help us award you partial credit).\n\n## Explanation. Line 18 introduces a logical error, causing x_internal to always be incremented by move_amount regardless of the direction of movement."
            }
          ],
          "answer": [
            {
              "solution": "Line 18 introduces a logical error, causing x_internal to always be incremented by move_amount regardless of the direction of movement.",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "5 Memory Potpourri",
      "problem_figures": [],
      "parts": [
        {
          "part": "1",
          "question": [
            {
              "subproblem_question": "A main memory access typically has larger latency than a register file access."
            }
          ],
          "answer": [
            {
              "solution": "True",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "2",
          "question": [
            {
              "subproblem_question": "SRAM is commonly used as main memory in modern computers."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "3",
          "question": [
            {
              "subproblem_question": "A DRAM cell requires larger power to store data compared to an SRAM cell."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "4",
          "question": [
            {
              "subproblem_question": "Reads are faster than writes in DRAM."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "5",
          "question": [
            {
              "subproblem_question": "Reads are faster than writes in phase change memory."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "6",
          "question": [
            {
              "subproblem_question": "A bitline in a DRAM array connects all DRAM cells in a DRAM row to the row decoder circuitry."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "7",
          "question": [
            {
              "subproblem_question": "Using virtual memory reduces the memory access latency."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "8",
          "question": [
            {
              "subproblem_question": "Phase Change Memory (PCM) is non-volatile."
            }
          ],
          "answer": [
            {
              "solution": "True",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "9",
          "question": [
            {
              "subproblem_question": "If a hypothetical system is not constrained by chip area, memory cost ($), and energy consumption, PCM would be the best memory technology to use in that system."
            }
          ],
          "answer": [
            {
              "solution": "True",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "10",
          "question": [
            {
              "subproblem_question": "A program with a streaming memory access pattern leads to very high temporal locality in the last level data cache."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "11",
          "question": [
            {
              "subproblem_question": "In DRAM, accesses to different rows in one bank can be serviced faster compared to accesses to different rows in different banks."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "12",
          "question": [
            {
              "subproblem_question": "TLB is a specialized instruction cache that caches instructions based on branch prediction results."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "13",
          "question": [
            {
              "subproblem_question": "Virtual memory simplifies software design."
            }
          ],
          "answer": [
            {
              "solution": "True",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "14",
          "question": [
            {
              "subproblem_question": "A page fault happens when the TLB does not contain the entry needed by an instruction."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "15",
          "question": [
            {
              "subproblem_question": "A fully-associative L1 TLB that only stores 4 KB virtual-to-physical mappings and has 1024 entries can cover up to 4 MB of memory."
            }
          ],
          "answer": [
            {
              "solution": "False",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "6 Performance Evaluation",
      "problem_figures": [],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "What is the CPI (cycles per instruction) of application A when executing on processor P1? Show your work."
            }
          ],
          "answer": [
            {
              "solution": "$$\nC P I=0.4 \\times 6+0.2 \\times 6+0.3 \\times 2+0.1 \\times 2\nC P I=4.4\n$$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "A new design of the processor doubles the clock frequency of P1. However, the latencies of all instructions increase by 4 cycles. We call this new processor P2. The compiler used to generate instructions for P2 is the same as for P1. Thus, it produces the same number of instructions for program A. What is the CPI of application A when executing on processor P2? Show your work."
            }
          ],
          "answer": [
            {
              "solution": "$$\nC P I=0.4 \\times 10+0.2 \\times 10+0.3 \\times 6+0.1 \\times 6\nC P I=8.4\n$$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "c",
          "question": [
            {
              "subproblem_question": "Which processor is faster (P1 or P2)? By how much (i.e., what is the speedup)? Show your work."
            }
          ],
          "answer": [
            {
              "solution": "$$\nP 2 \\text{ is } 1.05 \\times \\text{ faster than } P 1\n$$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "d",
          "question": [
            {
              "subproblem_question": "You want to improve the original P1 design by including one new optimization without changing the clock frequency. You can choose only one of the following options:\n(1) ALU: An optimized ALU, which halves the latency of both arithmetic and branch instructions.\n(2) LSU: An asymmetric load-store unit, which halves the latency of load operations but doubles the latency of store operations.\nWhich optimization do you add to P1 for application A? Show your work and justify your choice."
            }
          ],
          "answer": [
            {
              "solution": "The ALU optimization.",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "7 Pipelining",
      "problem_figures": ["TABLE"],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "List the data forwarding paths between pipeline stages."
            }
          ],
          "answer": [
            {
              "solution": "The result of E3 stage is forwarded to E1 stage (e.g., R1's value at clock cycle 6 and R4's value at clock cycle 11). The result of M stage is forwarded to E1 stage (e.g., R1's value at clock cycle 7.) The result of E3 stage is forwarded to the condition registers (e.g., SUBI and JNZ at clock cycle 15). There is no other information for any other data forwarding. Therefore, other data forwardings are unknown.",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "Does this machine use hardware interlocking or software interlocking? Explain."
            }
          ],
          "answer": [
            {
              "solution": "Hardware interlocking. It detects data dependencies and stalls the pipeline accordingly without needing any software-induced NOPs.",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "c",
          "question": [
            {
              "subproblem_question": "Calculate the value of T (the clock cycle of the given snapshot). Show your work."
            }
          ],
          "answer": [
            {
              "solution": "$$\nT=82\n$$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "d",
          "question": [
            {
              "subproblem_question": "Calculate the value of N (the total number of dynamic instructions fetched by the clock cycle T). Show your work."
            }
          ],
          "answer": [
            {
              "solution": "$$\nN=51\n$$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "e",
          "question": [
            {
              "subproblem_question": "Calculate the total execution time of the assembly code in Code Listing 1 until the completion in terms of the number of clock cycles. Show your work."
            }
          ],
          "answer": [
            {
              "solution": "$$\n100 \\text{ cycles.}\n$$",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "8 Vector Processing",
      "problem_figures": ["TABLE"],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "What should the minimum number of banks (N) be to avoid stalls while executing a VLD or VST instruction? Calculate the minimum number of banks for every stride from 1 to 10. Explain."
            }
          ],
          "answer": [
            {
              "solution": "101 banks for even strides, 100 banks for odd strides",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "Translate the following loop into assembly code that can be executed in the least possible number of cycles in the previously described vector machine:"
            }
          ],
          "answer": [
            {
              "solution": "| SET $V_{s t}, 1$ | # Load Vector Stride Register |\n| SET $V_{l n}, 46$ | # Load Vector Length Register |\n| VLD $V_{1}$, a | # Read from array a |\n| VLD $V_{2}$, b | # Read from array b |\n| VCMPZ $V_{3}, V_{1}$ | # Compare V1 to 0 |\n| LDM V3 | # Load Vector Mask Register |\n| VST c, V2 | # Write to array c |\n| VNOT V3 | # BitwiseNOT |\n| LDM V3 | # Load Vector Mask Register |\n| VSHFR $V_{4}, V_{1}$ | # Shift to divide |\n| VMUL $V_{5}, V_{1}, V_{2}$ | # Multiply |\n| VADD $V_{6}, V_{5}, V_{4}$ | # Add |\n| VST c, $V_{6}$ | # Write to array c |",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "c",
          "question": [
            {
              "subproblem_question": "What is the number of cycles the previous code takes to execute in the vector processor described in this question? Assume:\n- Vectors a and b are in different rows\n- A machine that has a memory with 8 banks.\n- The rest of the machine is the same as in part (a)."
            }
          ],
          "answer": [
            {
              "solution": "1822 cycles",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "9 VLIW",
      "problem_figures": ["TABLE", "IMAGE"],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "Your goal in this question is to statically schedule the instructions in Figure 1 to the VLIW processor specified above. Table 2 (on the next page) represents the occupancy of each functional unit during the execution of the assembly code in Figure 1."
            }
          ],
          "answer": [
            {
              "solution": "|  VLIW Instruction | Functional Unit |  |  |  |  |  |   |\n| --- | --- | --- | --- | --- | --- | --- | --- |\n|   | Load | Load | Load | Store | Mult | Add | Branch  |\n|  1 LOOP: | load_inc c2, [c21, c0, c14] | load c3, [c29, c1, c14] | load c4, [c30, c1, c14] | NOP | NOP | NOP | NOP  |\n|  2 | NOP | NOP | NOP | NOP | mult c3, c2, c3 | NOP | NOP  |\n|  3 | NOP | NOP | NOP | NOP | NOP | add c0, c1, c4 | NOP  |\n|  4 | NOP | NOP | NOP | store_inc [c31, c1, c16, c0 | NOP | NOP | NOP  |\n|  5 | NOP | NOP | NOP | NOP | NOP | NOP | bus c1, cN, LOOP  |\n|  6 |  |  |  |  |  |  |   |\n|  7 |  |  |  |  |  |  |   |\n|  8 |  |  |  |  |  |  |   |\n|  9 |  |  |  |  |  |  |   |\n|  10 |  |  |  |  |  |  |   |\n|  11 |  |  |  |  |  |  |   |\n|  12 |  |  |  |  |  |  |   |\n|  13 |  |  |  |  |  |  |   |\n|  14 |  |  |  |  |  |  |   |\n|  15 |  |  |  |  |  |  |   |",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "What is the ratio between the number of useful operations and the number of VLIW instructions in your code? A useful operation refers to any assembly operation that is not a NOP."
            }
          ],
          "answer": [
            {
              "solution": "$\frac{7}{5}$ useful operations per VLIW instruction.",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "c",
          "question": [
            {
              "subproblem_question": "What is the execution time (in cycles) of the VLIW processor when executing the sequence of instructions in Table 2, as a function of the loop counter N? Show your work."
            }
          ],
          "answer": [
            {
              "solution": "Execution time $=5 \\times N$.",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "10 Cache",
      "problem_figures": [],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "What are the addresses of the next two cache blocks that should be accessed to successfully reverse-engineer the number of sets and ways in the L1 data cache? There may be multiple solutions; please give the lowest possible addresses that can enable the identification of the number of sets and ways. Please explain every step in detail to get full points."
            }
          ],
          "answer": [
            {
              "solution": "$$\n0 \\rightarrow 2\n$$",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "What is the number of sets and ways if the cache hit rate observed over the two extra addresses accessed in Part (1) were:"
            }
          ],
          "answer": [
            {
              "solution": "|  L1 hit rate | # sets | # ways  |\n| --- | --- | --- |\n|  $100 \\%$ | 1 | 4 |\n|  $50 \\%$ | 4 | 1 |\n|  $0 \\%$ | 2 | 2 |",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "c",
          "question": [
            {
              "subproblem_question": "Is it possible to reverse-engineer the number of sets and ways of the cache using two accesses (after the application's first three accesses) if the Most Recently Used (MRU) block is replaced first? Explain your reasoning."
            }
          ],
          "answer": [
            {
              "solution": "No. There is no solution for just two more accesses because with an MRU policy, no permutation of two more accesses is able to assign a unique L1 hit rate to each of the three cache configurations.",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "11 BONUS: Systolic Arrays",
      "problem_figures": ["IMAGE"],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "Fill in the blanks only with relevant information. Input cells left blank are interpreted as 0."
            }
          ],
          "answer": [
            {
              "solution": "| cycle | H0 | H1 | V0 | V1 | PE $_{00}$ | PE $_{01}$ | PE $_{10}$ | PE $_{11}$ |\n| :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n| 0 | $A_{00}$ |  | $B_{00}$ |  |  |  |  |  |\n| 1 | $A_{01}$ | $A_{10}$ | $B_{10}$ | $B_{01}$ |  |  |  |  |\n| 2 |  | $A_{11}$ |  | $B_{11}$ | $C_{00}$ |  |  |  |\n| 3 |  |  |  |  |  | $C_{01}$ | $C_{10}$ |  |\n| 4 |  |  |  |  |  |  |  | $C_{11}$ |\n| 5 |  |  |  |  |  |  |  |  |\n| 6 |  |  |  |  |  |  |  |  |\n| 7 |  |  |  |  |  |  |  |  |",
              "solution_figures": []
            }
          ]
        },
        {
          "part": "b",
          "question": [
            {
              "subproblem_question": "Suppose that the same systolic array from Figure 2 is used to compute the multiplication of two $4 \\times 4$ matrices. How many cycles does it take to perform the multiplication? Assume that the register in a PE resets to 0 immediately after an output is generated, i.e., PEs can start accumulating for the next output element in the next cycle without waiting for an extra cycle to reset the register to 0. Show your work."
            }
          ],
          "answer": [
            {
              "solution": "19 cycles.",
              "solution_figures": []
            }
          ]
        }
      ]
    },
    {
      "problem": "12 BONUS: Prefetching",
      "problem_figures": [],
      "parts": [
        {
          "part": "a",
          "question": [
            {
              "subproblem_question": "Determine what type of prefetching mechanism is used by M1 and M2. Show your work. Answers without explanation will not be rewarded."
            }
          ],
          "answer": [
            {
              "solution": "Machine M1: 4th-next-line prefetcher\nMachine M2: Stride prefetcher",
              "solution_figures": []
            }
          ]
        }
      ]
    }
  ]
}
```