[
    {
        "question_id": "740_f13_midterm2_solutions/Problem_2/A",
        "context": "Suppose your friend designed the following fine-grained multithreaded machine: The pipeline has 22 stages and is 1 instruction wide. Branches are resolved at the end of the 18th stage and there is a 1 cycle delay after that to communicate the branch target to the fetch stage. The data cache is accessed during stage 20. On a hit, the thread does not stall. On a miss, the thread stalls for 100 cycles, fixed. The cache is non-blocking and has space to accommodate 16 outstanding requests. The number of hardware contexts is 200. Assuming that there are always enough threads present, answer the following questions:\n",
        "context_figures": [],
        "question": "Can the pipeline always be kept full and non-stalling? Why or why not? (Hint: think about the worst case execution characteristics.)",
        "solution": "NO - will stall when more than 16 outstanding misses in pipe",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_2/B",
        "context": "Suppose your friend designed the following fine-grained multithreaded machine: The pipeline has 22 stages and is 1 instruction wide. Branches are resolved at the end of the 18th stage and there is a 1 cycle delay after that to communicate the branch target to the fetch stage. The data cache is accessed during stage 20. On a hit, the thread does not stall. On a miss, the thread stalls for 100 cycles, fixed. The cache is non-blocking and has space to accommodate 16 outstanding requests. The number of hardware contexts is 200. Assuming that there are always enough threads present, answer the following questions:\n",
        "context_figures": [],
        "question": "Can the pipeline always be kept full and non-stalling if all accesses hit in the cache? Why or why not?",
        "solution": "YES - switching between 200 threads is plenty to avoid stalls due to branch prediction delay",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_2/C",
        "context": "Suppose your friend designed the following fine-grained multithreaded machine: The pipeline has 22 stages and is 1 instruction wide. Branches are resolved at the end of the 18th stage and there is a 1 cycle delay after that to communicate the branch target to the fetch stage. The data cache is accessed during stage 20. On a hit, the thread does not stall. On a miss, the thread stalls for 100 cycles, fixed. The cache is non-blocking and has space to accommodate 16 outstanding requests. The number of hardware contexts is 200. Assuming that there are always enough threads present, answer the following questions:\nAssume that all accesses hit in the cache and your friend wants to keep the pipeline always full and non-stalling.",
        "context_figures": [],
        "question": "How would you adjust the hardware resources (if necessary) to satisfy this while minimizing hardware cost? You cannot change the latencies provided above. Be comprehensive and specific with numerical answers. If nothing is necessary, justify why this is the case.",
        "solution": "Reduce hardware thread contexts to 19, the minimum to keep pipe full/non-stalling",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_2/D",
        "context": "Suppose your friend designed the following fine-grained multithreaded machine: The pipeline has 22 stages and is 1 instruction wide. Branches are resolved at the end of the 18th stage and there is a 1 cycle delay after that to communicate the branch target to the fetch stage. The data cache is accessed during stage 20. On a hit, the thread does not stall. On a miss, the thread stalls for 100 cycles, fixed. The cache is non-blocking and has space to accommodate 16 outstanding requests. The number of hardware contexts is 200. Assuming that there are always enough threads present, answer the following questions:\nAssume that all accesses miss in the cache and your friend wants to keep the pipeline always full and non-stalling.",
        "context_figures": [],
        "question": "How would you adjust the hardware resources (if necessary) to satisfy this while minimizing hardware cost? You cannot change the latencies provided above. Be comprehensive and specific with numerical answers. If nothing is necessary, justify why this is the case.",
        "solution": "Reduce hardware thread contexts to 100, the minimum to keep pipe full/non-stalling. Increase capability to support 100 outstanding misses",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_3/A",
        "context": "The diagram below shows a snapshot at a particular point in time of various parts (reservation stations and register alias table) of the microarchitecture for an implementation supporting out-of-order execution in the spirit of Tomasulo\u2019s Algorithm. Note that there is an adder and a multiplier in this machine. The processor is supplied with a seven instruction program following reset. The state below was captured at some point in time during the execution of these seven instructions. Anything marked with a \u2013 is unknown and can\u2019t be relied upon for your answer. You should assume that the bottommost instruction in the reservation station arrived earliest and the topmost instruction in the reservation station arrived last.\nIdentify the instructions and draw the data flow graph for the seven instructions (use + for ADD and * for MUL). Please label the edges of the data flow graph with the destination register tag if known. Label with register number if the tag is not known. Note that the first instruction is an ADD with destination register R3.",
        "context_figures": [
            "chart_p6_0.png"
        ],
        "question": "Draw the data flow graph for the seven instructions.",
        "solution": "",
        "solution_figures": [
            "chart_p6_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_3/B",
        "context": "The diagram below shows a snapshot at a particular point in time of various parts (reservation stations and register alias table) of the microarchitecture for an implementation supporting out-of-order execution in the spirit of Tomasulo\u2019s Algorithm. Note that there is an adder and a multiplier in this machine. The processor is supplied with a seven instruction program following reset. The state below was captured at some point in time during the execution of these seven instructions. Anything marked with a \u2013 is unknown and can\u2019t be relied upon for your answer. You should assume that the bottommost instruction in the reservation station arrived earliest and the topmost instruction in the reservation station arrived last.\nFill in the instruction opcodes, source, and destination registers in the table below.",
        "context_figures": [
            "chart_p6_0.png"
        ],
        "question": "Fill in the instruction opcodes, source, and destination registers in the table below.",
        "solution": "OP DEST SRC1 SRC2 \nADD R3 R1 R2 \nADD R1 R2 R3 \nMUL R4 R1 R1 \nMUL R5 R2 R1 \nADD  R2 R2 R5 \nMUL R5 R4 R1 \nADD R5 R2 R5",
        "solution_figures": [
            "chart_p7_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/A",
        "context": "Potpourri (55 pts)\nThread prioritization",
        "context_figures": [],
        "question": "Suppose we are running a multithreaded application where threads are part of the same application on a multicore processor. The memory controller is shared between the cores.",
        "solution": "1) Prioritizing latency-sensitive (memory non-intensive) threads can increase system throughput. 2) Can delay the critical/bottleneck thread which may not be memory non-intensive",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/B",
        "context": "Potpourri (55 pts)\nMemory bandwidth",
        "context_figures": [],
        "question": "Under what conditions would an application\u2019s performance increase linearly as memory bandwidth is increased?",
        "solution": "If memory bandwidth is the performance bottleneck",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/C",
        "context": "Potpourri (55 pts)\nFat trees",
        "context_figures": [],
        "question": "What problem does the fat tree interconnect solve that is present in the tree interconnect?",
        "solution": "High link contention between root and subnodes \u2013 a fat tree increases the bandwidth of these links",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/D",
        "context": "Potpourri (55 pts)\nInterconnect",
        "context_figures": [],
        "question": "You are observing a system with many processing elements connected through a network. There is currently no activity on the network (no messages are being sent). On cycle 10, one of the cores generates a message destined for a cache bank somewhere else on the network. You observe the network on cycle 20 and see that this message has not departed the source location. Assume that all components are enabled (not powered off) and operating at full speed. There are no other messages present in the system at this time. Why could this be?",
        "solution": "The system is using circuit switching, and there is a large delay to set up all links between source and destination.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/E",
        "context": "Potpourri (55 pts)\nSlack",
        "context_figures": [],
        "question": "As you recall, we have discussed the idea of slack based prioritization for on-chip interconnects in class. In fact, you reviewed a paper that introduced this concept. The key idea was to prioritize the packet that has the least slack over others in the router, where the slack of a packet (ideally) is defined as the number of cycles the packet can be delayed without hurting performance.",
        "solution": "1) The exact latency of the request may not be known at the time of injection \u2013 the slack may change based on the state of the shared resources and the decisions made by them. How much the packet would affect performance may not be known at the time of injection \u2013 the overlap of latency of the packet may not be known at the time of injection. 2) Can cause starvation to some threads. 3) Batching",
        "solution_figures": [
            "chart_p3_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/F",
        "context": "Potpourri (55 pts)\nDataflow",
        "context_figures": [],
        "question": "What is the purpose of token tagging in dynamic dataflow architectures?",
        "solution": "Supporting re-entrant code. Ensuring that tokens come from same context.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_1/G",
        "context": "Potpourri (55 pts)\nAlpha 21264",
        "context_figures": [],
        "question": "The Alpha 21264 had a \u201cPrefetch and evict next\u201d instruction that \u201cprefetched data into the L1 cache except that the block will be evicted from the L1 data cache on the next access to the same data cache set.\u201d",
        "solution": "1) Streaming or striding access pattern (no data reuse). 2) Allow speculative scheduling of consumers of the load",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_4/A",
        "context": "Recall from your required reading on Tiered-Latency DRAM that there is a near and far segment, each containing some number of rows. Assume a very simplified memory model where there is just one bank and there are two rows in the near segment and four rows in the far segment. The time to activate and precharge a row is 25ns in the near segment and 50ns in the far segment. The time from start of activation to reading data is 10ns in the near segment and 15ns in the far segment. All other timings are negligible for this problem. Given the following memory request stream, determine the optimal assignment (minimize average latency of requests) of rows in the near and far segment (assume a fixed mapping where rows cannot migrate, a closed-row policy, and the far segment is inclusive).\n",
        "context_figures": [],
        "question": "What rows would you place in near segment? Hint: draw a timeline.",
        "solution": "rows 0 and 2. see above",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_4/B",
        "context": "Recall from your required reading on Tiered-Latency DRAM that there is a near and far segment, each containing some number of rows. Assume a very simplified memory model where there is just one bank and there are two rows in the near segment and four rows in the far segment. The time to activate and precharge a row is 25ns in the near segment and 50ns in the far segment. The time from start of activation to reading data is 10ns in the near segment and 15ns in the far segment. All other timings are negligible for this problem. Given the following memory request stream, determine the optimal assignment (minimize average latency of requests) of rows in the near and far segment (assume a fixed mapping where rows cannot migrate, a closed-row policy, and the far segment is inclusive).\n",
        "context_figures": [],
        "question": "What rows would you place in far segment?",
        "solution": "rows 1 and 3 (also rows 0 and 2 since inclusive). see above",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_4/C",
        "context": "Recall from your required reading on Tiered-Latency DRAM that there is a near and far segment, each containing some number of rows. Assume a very simplified memory model where there is just one bank and there are two rows in the near segment and four rows in the far segment. The time to activate and precharge a row is 25ns in the near segment and 50ns in the far segment. The time from start of activation to reading data is 10ns in the near segment and 15ns in the far segment. All other timings are negligible for this problem. Given the following memory request stream, determine the optimal assignment (minimize average latency of requests) of rows in the near and far segment (assume a fixed mapping where rows cannot migrate, a closed-row policy, and the far segment is inclusive).\n",
        "context_figures": [],
        "question": "In 15 words or less, describe the insight in your mapping?",
        "solution": "See TL-DRAM\u2019s WMC policy \u2013 the first access in near simultaneous requests causes the second to wait activation + precharge time. minimizing this wait by caching first row in near segment is better than caching second row in near segment (this decreases only time to read from start of activation), even if second row is accessed more frequently (see example above)",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_4/D",
        "context": "Recall from your required reading on Tiered-Latency DRAM that there is a near and far segment, each containing some number of rows. Assume a very simplified memory model where there is just one bank and there are two rows in the near segment and four rows in the far segment. The time to activate and precharge a row is 25ns in the near segment and 50ns in the far segment. The time from start of activation to reading data is 10ns in the near segment and 15ns in the far segment. All other timings are negligible for this problem. Given the following memory request stream, determine the optimal assignment (minimize average latency of requests) of rows in the near and far segment (assume a fixed mapping where rows cannot migrate, a closed-row policy, and the far segment is inclusive).\n",
        "context_figures": [],
        "question": "Assume now that the mapping is dynamic. What are the tradeoffs of an exclusive design vs. an inclusive design? Name one advantage and one disadvantage for each.",
        "solution": "Exclusive requires swapping, but can use nearly full capacity of DRAM. Inclusive, the opposite.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_4/E",
        "context": "Recall from your required reading on Tiered-Latency DRAM that there is a near and far segment, each containing some number of rows. Assume a very simplified memory model where there is just one bank and there are two rows in the near segment and four rows in the far segment. The time to activate and precharge a row is 25ns in the near segment and 50ns in the far segment. The time from start of activation to reading data is 10ns in the near segment and 15ns in the far segment. All other timings are negligible for this problem. Given the following memory request stream, determine the optimal assignment (minimize average latency of requests) of rows in the near and far segment (assume a fixed mapping where rows cannot migrate, a closed-row policy, and the far segment is inclusive).\n",
        "context_figures": [],
        "question": "3) How many near segment rows would you allocate to C?",
        "solution": "0",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_5/A",
        "context": "We define the SIMD utilization of a program running on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program. The following code segment is running on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A, B, and C are already in vector registers so there are no loads and stores in this program. (Hint: Notice that there are 5 instructions in each thread as labled below.) A warp in the GPU consists of 64 threads, and there are 64 SIMD lanes in the GPU. for (i = 0; i < 16384; i++) { if (A[i] > 0) { //Instruction 1 A[i] = A[i] * C[i]; //Instruction 2 B[i] = A[i] + B[i]; //Instruction 3 C[i] = B[i] + 1; //Instruction 4 D[i] = C[i] * B[i]; //Instruction 5 } }\n",
        "context_figures": [],
        "question": "How many warps does it take to execute this program?",
        "solution": "16384/64 = 256",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_5/B",
        "context": "We define the SIMD utilization of a program running on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program. The following code segment is running on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A, B, and C are already in vector registers so there are no loads and stores in this program. (Hint: Notice that there are 5 instructions in each thread as labled below.) A warp in the GPU consists of 64 threads, and there are 64 SIMD lanes in the GPU. for (i = 0; i < 16384; i++) { if (A[i] > 0) { //Instruction 1 A[i] = A[i] * C[i]; //Instruction 2 B[i] = A[i] + B[i]; //Instruction 3 C[i] = B[i] + 1; //Instruction 4 D[i] = C[i] * B[i]; //Instruction 5 } }\nAs shown below, assume array A has a repetitive pattern which has 32 ones followed by 96 zeros repetitively and array B has a different repetitive pattern which has 64 zeros followed by 64 ones repetitively.",
        "context_figures": [
            "chart_p11_0.png"
        ],
        "question": "What is the SIMD utilization of this program?",
        "solution": "When a warp is working on a segment of array A that has 64 0s, none of the threads in the warp will take the branch, which yields no branch divergence of the warp. Hence, the SIMD utilization of this particular input set is (64 + 64 + 32 \u2217 4)/(64 + 64 \u2217 5) = 66.7%",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_5/C",
        "context": "We define the SIMD utilization of a program running on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program. The following code segment is running on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A, B, and C are already in vector registers so there are no loads and stores in this program. (Hint: Notice that there are 5 instructions in each thread as labled below.) A warp in the GPU consists of 64 threads, and there are 64 SIMD lanes in the GPU. for (i = 0; i < 16384; i++) { if (A[i] > 0) { //Instruction 1 A[i] = A[i] * C[i]; //Instruction 2 B[i] = A[i] + B[i]; //Instruction 3 C[i] = B[i] + 1; //Instruction 4 D[i] = C[i] * B[i]; //Instruction 5 } }\n",
        "context_figures": [],
        "question": "Is it possible for this program to yield a SIMD utilization of 25%?",
        "solution": "Yes. For example, if only 4 elements in every 64 elements of A are positive, we can have a SIMD utilization of (64 + 4 \u2217 4)/(64 \u2217 5) = 25%.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_5/D",
        "context": "We define the SIMD utilization of a program running on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program. The following code segment is running on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A, B, and C are already in vector registers so there are no loads and stores in this program. (Hint: Notice that there are 5 instructions in each thread as labled below.) A warp in the GPU consists of 64 threads, and there are 64 SIMD lanes in the GPU. for (i = 0; i < 16384; i++) { if (A[i] > 0) { //Instruction 1 A[i] = A[i] * C[i]; //Instruction 2 B[i] = A[i] + B[i]; //Instruction 3 C[i] = B[i] + 1; //Instruction 4 D[i] = C[i] * B[i]; //Instruction 5 } }\n",
        "context_figures": [],
        "question": "Is it possible for this program to yield a SIMD utilization of 20%?",
        "solution": "No. The smallest SIMD utilization one can get is to have one and only one element in every 64 elements of A to be positive, which yields a minimal SIMD utilization of (64 + 1 \u2217 4)/(64 \u2217 5) = 21.25%, which is still greater than 20%.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_5/E",
        "context": "We define the SIMD utilization of a program running on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program. The following code segment is running on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A, B, and C are already in vector registers so there are no loads and stores in this program. (Hint: Notice that there are 5 instructions in each thread as labled below.) A warp in the GPU consists of 64 threads, and there are 64 SIMD lanes in the GPU. for (i = 0; i < 16384; i++) { if (A[i] > 0) { //Instruction 1 A[i] = A[i] * C[i]; //Instruction 2 B[i] = A[i] + B[i]; //Instruction 3 C[i] = B[i] + 1; //Instruction 4 D[i] = C[i] * B[i]; //Instruction 5 } }\nDuring an execution with a particular input array A, which has exactly 24 positive elements in every 64 elements, Hongyi finds that the SIMD utilization of the program is 50%. Based on this observation, Hongyi claims that any input array that has an average of 24 out of 64 elements positive would yield a 50% SIMD utilization.",
        "context_figures": [],
        "question": "Is Hongyi correct?",
        "solution": "Hongyi is incorrect. If A has a repetitive pattern of 48 contiguous 1s followed by 80 contiguous 0s, in which case 37.5% of the elements are positive on average, then the SIMD utilization of the program will be 83.3% rather than 50%.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_6/A",
        "context": "As described in class, Hyperblock scheduling uses predication support to replace unbiased branches with predicates, which enables larger code blocks.\n",
        "context_figures": [],
        "question": "In one sentence, in terms of code optimizations, explain what benefit does larger scheduling code blocks provide?",
        "solution": "Larger scheduling code blocks enable greater flexibility for instruction scheduling.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_6/B",
        "context": "As described in class, Hyperblock scheduling uses predication support to replace unbiased branches with predicates, which enables larger code blocks.\nOne optimization that can be applied to Hyperblock is Instruction Promotion. Instruction Promotion hoists the operation from a predicated instruction and replaces the original predicated instruction with a conditional move. With Instruction Promotion, operations can be scheduled and issued before their corresponding predicates are determined.",
        "context_figures": [],
        "question": "For the example above, can Instruction Promotion ever improve system performance? Why or why not?",
        "solution": "Yes it can. With Instruction Promotion, the program can hide some of the load latency.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_6/C",
        "context": "As described in class, Hyperblock scheduling uses predication support to replace unbiased branches with predicates, which enables larger code blocks.\nOne optimization that can be applied to Hyperblock is Instruction Promotion. Instruction Promotion hoists the operation from a predicated instruction and replaces the original predicated instruction with a conditional move. With Instruction Promotion, operations can be scheduled and issued before their corresponding predicates are determined.",
        "context_figures": [],
        "question": "For the example above, can Instruction Promotion ever degrade system performance? Why or why not?",
        "solution": "Yes it can. Instruction Promotion: (1) introduces extra instructions and (2) can increase register pressure.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "740_f13_midterm2_solutions/Problem_6/D",
        "context": "As described in class, Hyperblock scheduling uses predication support to replace unbiased branches with predicates, which enables larger code blocks.\nThe graph above shows the performance comparison of a program optimized using Hyperblock and Superblock respectively with different issue widths.",
        "context_figures": [
            "chart_p14_0.png"
        ],
        "question": "With all other factors being equal, as the figure shows, when the issue width is low, Superblock provides higher speedup than Hyperblock. However, when the issue width is high, Hyperblock provides higher speedup than Superblock. Explain why this can happen?",
        "solution": "A wider issue width can tolerate the wasted instructions in a hyperblock, but does not benefit the superblock (all else being equal). A more detailed explanation: Hyperblock uses predication which increases the total number of instructions to execute. When the issue width is low, executing extra predicated instructions requires extra work, which slows down the processor as all resources of the processor has already been fully utilized. When the issue width is high, however, Hyperblock provides a greater number of independent instructions from the multiple paths of control to fill the available processor resources. As Hyperblock also enables larger code blocks for better optimization for unbiased branches, Hyperblock provides better speedup.",
        "solution_figures": [],
        "correctly_parsed": null
    }
]