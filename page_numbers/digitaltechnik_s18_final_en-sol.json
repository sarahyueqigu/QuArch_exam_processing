{
    "pages": [
        {
            "page": 1,
            "text": "    Name:    SOLUTIONS                                       Student ID:\n                                                               Final Exam\n                                               Design of Digital Circuits (252-0028-00L)\n                                                        ETH Z\u00fcrich, Spring 2018\n                                                            Prof. Onur Mutlu\n                       Problem 1 (30 Points):  Potpourri\n                       Problem 2 (30 Points):  Verilog\n                       Problem 3 (15 Points):  Boolean Algebra\n                       Problem 4 (50 Points):  Finite State Machine\n                       Problem 5 (45 Points):  ISA and Microarchitecture\n                       Problem 6 (35 Points):  Pipelining\n                       Problem 7 (45 Points):  Out-of-order Execution\n                       Problem 8 (40 Points):  Vector Processing\n                       Problem 9 (45 Points):  GPUs and SIMD\n                      Problem 10 (40 Points):  Memory Hierarchy\n                      Problem 11 (35 Points):  Dataflow Meets Logic\n               Problem 12 (BONUS: 40 Points):  Branch Prediction\n          Total (450 (410 + 40 bonus) Points):\nExamination Rules:\n  1. Written exam, 180 minutes in total.\n  2. No books, no calculators, no computers or communication devices.   6 pages of handwritten notes are\n     allowed.\n  3. Write all your answers on this document, space is reserved for your answers after each question. Blank\n     pages are available at the end of the exam.\n  4. Clearly indicate your final answer for each problem. Answers will only be evaluated if they are readable.\n  5. Put your Student ID card visible on the desk during the exam.\n  6. If you feel disturbed, immediately call an assistant.\n  7. Write with a black or blue pen (no pencil, no green or red color).\n  8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due\n     to a calculation mistake.\n  9. Please write your initials at the top of every page.\n   Tips:\n \u2022 Be cognizant of time. Do not spend too much time on one question.\n \u2022 Be concise. You may be penalized for verbosity.\n \u2022 Show work when needed. You will receive partial credit at the instructors\u2019 discretion.\n \u2022 Write legibly. Show your final answer.",
            "md": "\n# Final Exam\n\n# Design of Digital Circuits (252-0028-00L)\n\n# ETH Z\u00fcrich, Spring 2018\n\n# Prof. Onur Mutlu\n\n\n\n# Problems\n\n- Problem 1 (30 Points): Potpourri\n- Problem 2 (30 Points): Verilog\n- Problem 3 (15 Points): Boolean Algebra\n- Problem 4 (50 Points): Finite State Machine\n- Problem 5 (45 Points): ISA and Microarchitecture\n- Problem 6 (35 Points): Pipelining\n- Problem 7 (45 Points): Out-of-order Execution\n- Problem 8 (40 Points): Vector Processing\n- Problem 9 (45 Points): GPUs and SIMD\n- Problem 10 (40 Points): Memory Hierarchy\n- Problem 11 (35 Points): Dataflow Meets Logic\n- Problem 12 (BONUS: 40 Points): Branch Prediction\n\nTotal (450 (410 + 40 bonus) Points):\n\n# Examination Rules:\n\n1. Written exam, 180 minutes in total.\n2. No books, no calculators, no computers or communication devices. 6 pages of handwritten notes are allowed.\n3. Write all your answers on this document, space is reserved for your answers after each question. Blank pages are available at the end of the exam.\n4. Clearly indicate your final answer for each problem. Answers will only be evaluated if they are readable.\n5. Put your Student ID card visible on the desk during the exam.\n6. If you feel disturbed, immediately call an assistant.\n7. Write with a black or blue pen (no pencil, no green or red color).\n8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due to a calculation mistake.\n9. Please write your initials at the top of every page.\n\n# Tips:\n\n- Be cognizant of time. Do not spend too much time on one question.\n- Be concise. You may be penalized for verbosity.\n- Show work when needed. You will receive partial credit at the instructors\u2019 discretion.\n- Write legibly. Show your final answer.",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Final Exam",
                    "md": "# Final Exam",
                    "rows": null,
                    "bBox": {
                        "x": 257.49,
                        "y": 63.16,
                        "w": 80.58,
                        "h": 14.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits (252-0028-00L)",
                    "md": "# Design of Digital Circuits (252-0028-00L)",
                    "rows": null,
                    "bBox": {
                        "x": 129.69,
                        "y": 88.47,
                        "w": 336.33,
                        "h": 17.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "ETH Z\u00fcrich, Spring 2018",
                    "md": "# ETH Z\u00fcrich, Spring 2018",
                    "rows": null,
                    "bBox": {
                        "x": 194.75,
                        "y": 120.05,
                        "w": 205.64,
                        "h": 17.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Prof. Onur Mutlu",
                    "md": "# Prof. Onur Mutlu",
                    "rows": null,
                    "bBox": {
                        "x": 251.56,
                        "y": 151.66,
                        "w": 92.62,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Problems",
                    "md": "# Problems",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "- Problem 1 (30 Points): Potpourri\n- Problem 2 (30 Points): Verilog\n- Problem 3 (15 Points): Boolean Algebra\n- Problem 4 (50 Points): Finite State Machine\n- Problem 5 (45 Points): ISA and Microarchitecture\n- Problem 6 (35 Points): Pipelining\n- Problem 7 (45 Points): Out-of-order Execution\n- Problem 8 (40 Points): Vector Processing\n- Problem 9 (45 Points): GPUs and SIMD\n- Problem 10 (40 Points): Memory Hierarchy\n- Problem 11 (35 Points): Dataflow Meets Logic\n- Problem 12 (BONUS: 40 Points): Branch Prediction\n\nTotal (450 (410 + 40 bonus) Points):",
                    "md": "- Problem 1 (30 Points): Potpourri\n- Problem 2 (30 Points): Verilog\n- Problem 3 (15 Points): Boolean Algebra\n- Problem 4 (50 Points): Finite State Machine\n- Problem 5 (45 Points): ISA and Microarchitecture\n- Problem 6 (35 Points): Pipelining\n- Problem 7 (45 Points): Out-of-order Execution\n- Problem 8 (40 Points): Vector Processing\n- Problem 9 (45 Points): GPUs and SIMD\n- Problem 10 (40 Points): Memory Hierarchy\n- Problem 11 (35 Points): Dataflow Meets Logic\n- Problem 12 (BONUS: 40 Points): Branch Prediction\n\nTotal (450 (410 + 40 bonus) Points):",
                    "rows": null,
                    "bBox": {
                        "x": 104.13,
                        "y": 182.4,
                        "w": 289.79,
                        "h": 270.58
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Examination Rules:",
                    "md": "# Examination Rules:",
                    "rows": null,
                    "bBox": {
                        "x": 57.6,
                        "y": 492.8,
                        "w": 98.34,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1. Written exam, 180 minutes in total.\n2. No books, no calculators, no computers or communication devices. 6 pages of handwritten notes are allowed.\n3. Write all your answers on this document, space is reserved for your answers after each question. Blank pages are available at the end of the exam.\n4. Clearly indicate your final answer for each problem. Answers will only be evaluated if they are readable.\n5. Put your Student ID card visible on the desk during the exam.\n6. If you feel disturbed, immediately call an assistant.\n7. Write with a black or blue pen (no pencil, no green or red color).\n8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due to a calculation mistake.\n9. Please write your initials at the top of every page.",
                    "md": "1. Written exam, 180 minutes in total.\n2. No books, no calculators, no computers or communication devices. 6 pages of handwritten notes are allowed.\n3. Write all your answers on this document, space is reserved for your answers after each question. Blank pages are available at the end of the exam.\n4. Clearly indicate your final answer for each problem. Answers will only be evaluated if they are readable.\n5. Put your Student ID card visible on the desk during the exam.\n6. If you feel disturbed, immediately call an assistant.\n7. Write with a black or blue pen (no pencil, no green or red color).\n8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due to a calculation mistake.\n9. Please write your initials at the top of every page.",
                    "rows": null,
                    "bBox": {
                        "x": 69.78,
                        "y": 514.71,
                        "w": 468.3,
                        "h": 173.39
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Tips:",
                    "md": "# Tips:",
                    "rows": null,
                    "bBox": {
                        "x": 72.54,
                        "y": 700.02,
                        "w": 25.0,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "- Be cognizant of time. Do not spend too much time on one question.\n- Be concise. You may be penalized for verbosity.\n- Show work when needed. You will receive partial credit at the instructors\u2019 discretion.\n- Write legibly. Show your final answer.",
                    "md": "- Be cognizant of time. Do not spend too much time on one question.\n- Be concise. You may be penalized for verbosity.\n- Show work when needed. You will receive partial credit at the instructors\u2019 discretion.\n- Write legibly. Show your final answer.",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 2,
            "text": "Initials: Solutions                    Design of Digital Circuits                    August 18th, 2018\n                                   This page intentionally left blank\nFinal Exam                                                                                 Page 1 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\nAugust 18th, 2018\n\nThis page intentionally left blank\n\n# Final Exam\n\nPage 1 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "August 18th, 2018\n\nThis page intentionally left blank",
                    "md": "August 18th, 2018\n\nThis page intentionally left blank",
                    "rows": null,
                    "bBox": {
                        "x": 225.58,
                        "y": 43.11,
                        "w": 297.78,
                        "h": 38.89
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Final Exam",
                    "md": "# Final Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 784.67,
                        "w": 50.87,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 1 of 40",
                    "md": "Page 1 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 469.46,
                        "y": 784.67,
                        "w": 53.85,
                        "h": 10.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 3,
            "text": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n1    Potpourri       [30 points]\n1.1   Microarchitecture or ISA? [10 points]\nBased on your knowledge of a basic MIPS design and the computer architecture techniques you learned\nthroughout this course, put an \u201cX\u201d in the box corresponding to whether each of the following design\ncharacteristics is better classified as \u201cmicroarchitecture\u201d or \u201cISA\u201d:\n   Characteristic                                          Microarchitecture        ISA\n   General purpose register $29 is the stack pointer                                 X\n   Maximum bandwidth between the L2 and the L3 cache              X\n   Maximum reservation station capacity                           X\n   Hardware floating point exception support                                         X\n   Instruction issue width                                        X\n   Vector instruction support                                                        X\n   Memory-mapped I/O Port Address                                                    X\n   Arithmetic and Logic Unit (ALU) critical path                  X\n   CPU endianness                                                                    X\n   Virtual page size                                                                 X\nFinal Exam                                                                            Page 2 of 40",
            "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n# 1 Potpourri       [30 points]\n\n# 1.1 Microarchitecture or ISA? [10 points]\n\nBased on your knowledge of a basic MIPS design and the computer architecture techniques you learned throughout this course, put an \u201cX\u201d in the box corresponding to whether each of the following design characteristics is better classified as \u201cmicroarchitecture\u201d or \u201cISA\u201d:\n\n| Characteristic                                    | Microarchitecture | ISA |\n| ------------------------------------------------- | ----------------- | --- |\n| General purpose register $29 is the stack pointer | X                 |     |\n| Maximum bandwidth between the L2 and the L3 cache | X                 |     |\n| Maximum reservation station capacity              | X                 |     |\n| Hardware floating point exception support         |                   | X   |\n| Instruction issue width                           | X                 |     |\n| Vector instruction support                        |                   | X   |\n| Memory-mapped I/O Port Address                    |                   | X   |\n| Arithmetic and Logic Unit (ALU) critical path     | X                 |     |\n| CPU endianness                                    | X                 |     |\n| Virtual page size                                 |                   | X   |\n\nFinal Exam                                                                            Page 2 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 38.51
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "1 Potpourri       [30 points]",
                    "md": "# 1 Potpourri       [30 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 148.78,
                        "h": 14.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "1.1 Microarchitecture or ISA? [10 points]",
                    "md": "# 1.1 Microarchitecture or ISA? [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 404.44,
                        "h": 107.59
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Based on your knowledge of a basic MIPS design and the computer architecture techniques you learned throughout this course, put an \u201cX\u201d in the box corresponding to whether each of the following design characteristics is better classified as \u201cmicroarchitecture\u201d or \u201cISA\u201d:",
                    "md": "Based on your knowledge of a basic MIPS design and the computer architecture techniques you learned throughout this course, put an \u201cX\u201d in the box corresponding to whether each of the following design characteristics is better classified as \u201cmicroarchitecture\u201d or \u201cISA\u201d:",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 112.21,
                        "w": 451.71,
                        "h": 308.48
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Characteristic                                    | Microarchitecture | ISA |\n| ------------------------------------------------- | ----------------- | --- |\n| General purpose register $29 is the stack pointer | X                 |     |\n| Maximum bandwidth between the L2 and the L3 cache | X                 |     |\n| Maximum reservation station capacity              | X                 |     |\n| Hardware floating point exception support         |                   | X   |\n| Instruction issue width                           | X                 |     |\n| Vector instruction support                        |                   | X   |\n| Memory-mapped I/O Port Address                    |                   | X   |\n| Arithmetic and Logic Unit (ALU) critical path     | X                 |     |\n| CPU endianness                                    | X                 |     |\n| Virtual page size                                 |                   | X   |",
                    "rows": [
                        [
                            "Characteristic",
                            "Microarchitecture",
                            "ISA"
                        ],
                        [
                            "General purpose register $29 is the stack pointer",
                            "X",
                            ""
                        ],
                        [
                            "Maximum bandwidth between the L2 and the L3 cache",
                            "X",
                            ""
                        ],
                        [
                            "Maximum reservation station capacity",
                            "X",
                            ""
                        ],
                        [
                            "Hardware floating point exception support",
                            "",
                            "X"
                        ],
                        [
                            "Instruction issue width",
                            "X",
                            ""
                        ],
                        [
                            "Vector instruction support",
                            "",
                            "X"
                        ],
                        [
                            "Memory-mapped I/O Port Address",
                            "",
                            "X"
                        ],
                        [
                            "Arithmetic and Logic Unit (ALU) critical path",
                            "X",
                            ""
                        ],
                        [
                            "CPU endianness",
                            "X",
                            ""
                        ],
                        [
                            "Virtual page size",
                            "",
                            "X"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.71,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                                            Page 2 of 40",
                    "md": "Final Exam                                                                            Page 2 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 191.91,
                        "w": 451.32,
                        "h": 602.76
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 4,
            "text": "Initials: Solutions                             Design of Digital Circuits              August 18th, 2018\n1.2    Single-Cycle Processor Datapath                           [10 points]\nModify the single-cycle processor datapath to include a version of the lw instruction, called lw2, that\nadds two registers to obtain the effective address. The datapath that you will modify is provided below.\nYour job is to implement the necessary data and control signals to support the new lw2 instruction,\nwhich we define to have the following semantics:\n     lw2:   Rd \u2190 Memory[Rs + Rt]\n            PC \u2190 PC + 4\n   Add to the datapath any necessary data and control signals (if necessary) to implement the lw2\ninstruction.  Draw and label all components and wires very clearly (give control signals meaningful\nnames; if selecting a subset of bits from many, specify exactly which bits are selected; and so on).\n                                                                                                 0\n                                                                                                 M\n                                                                                                  u\n                                                                                                  x\n                                                                                        Add ALU  1\n                                                                                        result\n                    Add                                                                 Shift     PCSrc\n                                                               RegDst                   left 2\n              4                                                Branch\n                                                               MemRead\n                               Instruction [31  26]  Cont rol  MemtoReg\n                                                               ALUOp\n                                                               MemWrite\n                                                               ALUSrc\n                                                               RegWrite\n              Read             Instruction [25  21]             Read\n       PC     address                                           register 1  Read\n                               Instruction [20  16]             Read     data 1         Zero\n                     Instruction                                register 2\n                       [31\u20130]                    0              Write  Regist ers Read  0  ALU ALU  Address  Read\n              Instruction                        M              register data 2         M  result  data  1\n                 memory                              u                                    u             M\n                               Instruction [15  11]  x          Write                     x       Dat a   u\n                                                 1              data                    1         memory  x\n                                                                                         Write          0\n                                                                                         data\n                               Instruction [15  0]               16       Sign  32\n                                                                        ext end           ALU\n                                                                                        control\n                                                     Instruction [5 0]\n                                   ALU opcode                    Operation\n                                   00                            Add\n                                   01                            Subtract\n                                   10                            Controlled by funct\n                                   11                            Not used\n   There is no need for new components and wires. The main difference is that the ALU must use \"Read\n   data 2\", instead of the output of the sign extend unit. The new lw2 will be R-type, not I-type.\n   The values of the control signals need to be:\n   RegDst = 1;\n   ALUScr = 0;\n   MemtoReg = 1;\n   RegWrite = 1;\n   MemRead = 1;\n   MemWrite = 0;\n   ALUop = 00;\n   Branch = 0.\nFinal Exam                                                                                        Page 3 of 40",
            "md": "Initials: Solutions                             Design of Digital Circuits              August 18th, 2018\n\n# 1.2 Single-Cycle Processor Datapath\n\n[10 points]\n\nModify the single-cycle processor datapath to include a version of the lw instruction, called lw2, that adds two registers to obtain the effective address. The datapath that you will modify is provided below. Your job is to implement the necessary data and control signals to support the new lw2 instruction, which we define to have the following semantics:\n\nlw2:   Rd \u2190 Memory[Rs + Rt]\n\nPC \u2190 PC + 4\n\nAdd to the datapath any necessary data and control signals (if necessary) to implement the lw2 instruction. Draw and label all components and wires very clearly (give control signals meaningful names; if selecting a subset of bits from many, specify exactly which bits are selected; and so on).\n\n0\n\nM\n\nu\n\nx\n\nAdd ALU  1\n\nresult\n\n| Add     | Shift    | PCSrc    |\n| ------- | -------- | -------- |\n| 4       | RegDst   | Branch   |\n| MemRead | ALUOp    | MemWrite |\n| ALUSrc  | RegWrite |          |\n\nRead\n\nPC address\n\nInstruction [31  26]  Control  MemtoReg\n\nInstruction [25  21]  Read register 1  Read data 1\n\nInstruction [20  16]  Read register 2\n\nInstruction [31\u20130]  0  Write  Registers Read  0  ALU ALU  Address  Read\n\nInstruction memory  M\n\nInstruction [15  11]  x  Write  data 1\n\nInstruction [15  0]  16  Sign  32\n\next end  ALU control\n\nInstruction [5 0]\n\n| ALU opcode | Operation           |\n| ---------- | ------------------- |\n| 00         | Add                 |\n| 01         | Subtract            |\n| 10         | Controlled by funct |\n| 11         | Not used            |\n\nThere is no need for new components and wires. The main difference is that the ALU must use \"Read data 2\", instead of the output of the sign extend unit. The new lw2 will be R-type, not I-type.\n\nThe values of the control signals need to be:\n\n- RegDst = 1;\n- ALUSrc = 0;\n- MemtoReg = 1;\n- RegWrite = 1;\n- MemRead = 1;\n- MemWrite = 0;\n- ALUop = 00;\n- Branch = 0.\n\nFinal Exam                                                                                        Page 3 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                             Design of Digital Circuits              August 18th, 2018",
                    "md": "Initials: Solutions                             Design of Digital Circuits              August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 443.98
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "1.2 Single-Cycle Processor Datapath",
                    "md": "# 1.2 Single-Cycle Processor Datapath",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 70.01,
                        "w": 445.71,
                        "h": 325.43
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "[10 points]\n\nModify the single-cycle processor datapath to include a version of the lw instruction, called lw2, that adds two registers to obtain the effective address. The datapath that you will modify is provided below. Your job is to implement the necessary data and control signals to support the new lw2 instruction, which we define to have the following semantics:\n\nlw2:   Rd \u2190 Memory[Rs + Rt]\n\nPC \u2190 PC + 4\n\nAdd to the datapath any necessary data and control signals (if necessary) to implement the lw2 instruction. Draw and label all components and wires very clearly (give control signals meaningful names; if selecting a subset of bits from many, specify exactly which bits are selected; and so on).\n\n0\n\nM\n\nu\n\nx\n\nAdd ALU  1\n\nresult",
                    "md": "[10 points]\n\nModify the single-cycle processor datapath to include a version of the lw instruction, called lw2, that adds two registers to obtain the effective address. The datapath that you will modify is provided below. Your job is to implement the necessary data and control signals to support the new lw2 instruction, which we define to have the following semantics:\n\nlw2:   Rd \u2190 Memory[Rs + Rt]\n\nPC \u2190 PC + 4\n\nAdd to the datapath any necessary data and control signals (if necessary) to implement the lw2 instruction. Draw and label all components and wires very clearly (give control signals meaningful names; if selecting a subset of bits from many, specify exactly which bits are selected; and so on).\n\n0\n\nM\n\nu\n\nx\n\nAdd ALU  1\n\nresult",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 70.01,
                        "w": 451.61,
                        "h": 428.04
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Add     | Shift    | PCSrc    |\n| ------- | -------- | -------- |\n| 4       | RegDst   | Branch   |\n| MemRead | ALUOp    | MemWrite |\n| ALUSrc  | RegWrite |          |",
                    "rows": [
                        [
                            "Add",
                            "Shift",
                            "PCSrc"
                        ],
                        [
                            "4",
                            "RegDst",
                            "Branch"
                        ],
                        [
                            "MemRead",
                            "ALUOp",
                            "MemWrite"
                        ],
                        [
                            "ALUSrc",
                            "RegWrite",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 453.71,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Read\n\nPC address\n\nInstruction [31  26]  Control  MemtoReg\n\nInstruction [25  21]  Read register 1  Read data 1\n\nInstruction [20  16]  Read register 2\n\nInstruction [31\u20130]  0  Write  Registers Read  0  ALU ALU  Address  Read\n\nInstruction memory  M\n\nInstruction [15  11]  x  Write  data 1\n\nInstruction [15  0]  16  Sign  32\n\next end  ALU control\n\nInstruction [5 0]",
                    "md": "Read\n\nPC address\n\nInstruction [31  26]  Control  MemtoReg\n\nInstruction [25  21]  Read register 1  Read data 1\n\nInstruction [20  16]  Read register 2\n\nInstruction [31\u20130]  0  Write  Registers Read  0  ALU ALU  Address  Read\n\nInstruction memory  M\n\nInstruction [15  11]  x  Write  data 1\n\nInstruction [15  0]  16  Sign  32\n\next end  ALU control\n\nInstruction [5 0]",
                    "rows": null,
                    "bBox": {
                        "x": 103.04,
                        "y": 211.7,
                        "w": 416.28,
                        "h": 297.31
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| ALU opcode | Operation           |\n| ---------- | ------------------- |\n| 00         | Add                 |\n| 01         | Subtract            |\n| 10         | Controlled by funct |\n| 11         | Not used            |",
                    "rows": [
                        [
                            "ALU opcode",
                            "Operation"
                        ],
                        [
                            "00",
                            "Add"
                        ],
                        [
                            "01",
                            "Subtract"
                        ],
                        [
                            "10",
                            "Controlled by funct"
                        ],
                        [
                            "11",
                            "Not used"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.61,
                        "h": 591.14
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "There is no need for new components and wires. The main difference is that the ALU must use \"Read data 2\", instead of the output of the sign extend unit. The new lw2 will be R-type, not I-type.\n\nThe values of the control signals need to be:\n\n- RegDst = 1;\n- ALUSrc = 0;\n- MemtoReg = 1;\n- RegWrite = 1;\n- MemRead = 1;\n- MemWrite = 0;\n- ALUop = 00;\n- Branch = 0.\n\nFinal Exam                                                                                        Page 3 of 40",
                    "md": "There is no need for new components and wires. The main difference is that the ALU must use \"Read data 2\", instead of the output of the sign extend unit. The new lw2 will be R-type, not I-type.\n\nThe values of the control signals need to be:\n\n- RegDst = 1;\n- ALUSrc = 0;\n- MemtoReg = 1;\n- RegWrite = 1;\n- MemRead = 1;\n- MemWrite = 0;\n- ALUop = 00;\n- Branch = 0.\n\nFinal Exam                                                                                        Page 3 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 211.7,
                        "w": 453.71,
                        "h": 582.97
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 5,
            "text": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n1.3   Performance Evaluation [10 points]\nThe execution time of a given benchmark is 100 ms   on a 500 M Hz    processor. An ETH alumnus,\ndesigning the next generation of the processor, notices that a new implementation enables the processor\nto run at 750 M Hz. However, the modifications increase the CPI by 20% for the same benchmark.\n(a) [4 points] What is the execution time expressed in terms of the number of cycles taken for the old\n    generation of the processor (i.e., before the modifications)?\n    Assuming that the IPC is 2, what is the number of instructions in the benchmark?\n   Answer: Execution time is 50 Million cycles. The benchmark has 100 Million instructions.\n   Explanation:\n   Clock frequency is 500 M Hz. Then each cycle takes 1/(500 \u00d7 10\u22126) = 2ns.\n   Total execution time in cycles is 100ms/2ns = 50M illion cycles.\n   2 instructions per cycle. Then, the total number of instructions: 2x50M = 100M\n(b) [3 points] What is the execution time of the benchmark in milliseconds for the new generation of\n    the processor?\n   Answer: 80 ms.\n   Explanation:\n   Execution T ime = [N umber of Instructions] \u00d7 [CP I ] \u00d7 [F requency\u22121]\n   Let\u2019s say that the CPI of baseline is c, and number of instructions is i.\n   Then the execution time of baseline:\n   (c \u00d7 i)/(500x106) = 100x10\u22123 seconds  =>    (c \u00d7 i) = 5 \u00d7 107\n   The execution time after modifications: ((1.2 \u00d7 c) \u00d7 i)/(750x106)\n   T = ((1.2 \u00d7 (c \u00d7 i))/(750 \u00d7 106) seconds.\n   T = ((1.2 \u00d7 (5 \u00d7 107))/(750 \u00d7 106) seconds.\n   T = 8 \u00d7 10\u22122 = 80ms.\n(c) [3 points] What is the speedup or slowdown of the new generation processor over the old generation?\n   Answer: 25% speedup\n   Explanation:\n   Speedup =   (OldExecutionT ime /  [N ewExecutionT ime]) \u2212 1\n   Speedup  = 100/80 \u2212 1\n   Speedup  = 0.25\n   Then the modification introduces 25% speedup.\nFinal Exam                                                                            Page 4 of 40",
            "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n# 1.3   Performance Evaluation [10 points]\n\nThe execution time of a given benchmark is 100 ms on a 500 M Hz processor. An ETH alumnus, designing the next generation of the processor, notices that a new implementation enables the processor to run at 750 M Hz. However, the modifications increase the CPI by 20% for the same benchmark.\n\n# (a) [4 points] What is the execution time expressed in terms of the number of cycles taken for the old generation of the processor (i.e., before the modifications)?\n\nAssuming that the IPC is 2, what is the number of instructions in the benchmark?\n\nAnswer: Execution time is 50 Million cycles. The benchmark has 100 Million instructions.\n\nExplanation:\n\n- Clock frequency is 500 M Hz. Then each cycle takes 1/(500 \u00d7 10\u22126) = 2ns.\n- Total execution time in cycles is 100ms/2ns = 50 Million cycles.\n- 2 instructions per cycle. Then, the total number of instructions: 2x50M = 100M\n\n# (b) [3 points] What is the execution time of the benchmark in milliseconds for the new generation of the processor?\n\nAnswer: 80 ms.\n\nExplanation:\n\nExecution Time = [Number of Instructions] \u00d7 [CPI] \u00d7 [Frequency\u22121]\n\nLet\u2019s say that the CPI of baseline is c, and number of instructions is i.\n\nThen the execution time of baseline:\n\n(c \u00d7 i)/(500x106) = 100x10\u22123 seconds  =>    (c \u00d7 i) = 5 \u00d7 107\n\nThe execution time after modifications: ((1.2 \u00d7 c) \u00d7 i)/(750x106)\n\nT = ((1.2 \u00d7 (c \u00d7 i))/(750 \u00d7 106)) seconds.\n\nT = ((1.2 \u00d7 (5 \u00d7 107))/(750 \u00d7 106)) seconds.\n\nT = 8 \u00d7 10\u22122 = 80ms.\n\n# (c) [3 points] What is the speedup or slowdown of the new generation processor over the old generation?\n\nAnswer: 25% speedup\n\nExplanation:\n\nSpeedup = (OldExecutionTime / [NewExecutionTime]) \u2212 1\n\nSpeedup = 100/80 \u2212 1\n\nSpeedup = 0.25\n\nThen the modification introduces 25% speedup.\n\nFinal Exam                                                                            Page 4 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "1.3   Performance Evaluation [10 points]",
                    "md": "# 1.3   Performance Evaluation [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 70.01,
                        "w": 228.74,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "The execution time of a given benchmark is 100 ms on a 500 M Hz processor. An ETH alumnus, designing the next generation of the processor, notices that a new implementation enables the processor to run at 750 M Hz. However, the modifications increase the CPI by 20% for the same benchmark.",
                    "md": "The execution time of a given benchmark is 100 ms on a 500 M Hz processor. An ETH alumnus, designing the next generation of the processor, notices that a new implementation enables the processor to run at 750 M Hz. However, the modifications increase the CPI by 20% for the same benchmark.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 90.39,
                        "w": 451.2,
                        "h": 33.91
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [4 points] What is the execution time expressed in terms of the number of cycles taken for the old generation of the processor (i.e., before the modifications)?",
                    "md": "# (a) [4 points] What is the execution time expressed in terms of the number of cycles taken for the old generation of the processor (i.e., before the modifications)?",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 136.22,
                        "w": 451.0,
                        "h": 290.9
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Assuming that the IPC is 2, what is the number of instructions in the benchmark?\n\nAnswer: Execution time is 50 Million cycles. The benchmark has 100 Million instructions.\n\nExplanation:\n\n- Clock frequency is 500 M Hz. Then each cycle takes 1/(500 \u00d7 10\u22126) = 2ns.\n- Total execution time in cycles is 100ms/2ns = 50 Million cycles.\n- 2 instructions per cycle. Then, the total number of instructions: 2x50M = 100M",
                    "md": "Assuming that the IPC is 2, what is the number of instructions in the benchmark?\n\nAnswer: Execution time is 50 Million cycles. The benchmark has 100 Million instructions.\n\nExplanation:\n\n- Clock frequency is 500 M Hz. Then each cycle takes 1/(500 \u00d7 10\u22126) = 2ns.\n- Total execution time in cycles is 100ms/2ns = 50 Million cycles.\n- 2 instructions per cycle. Then, the total number of instructions: 2x50M = 100M",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 164.11,
                        "w": 427.71,
                        "h": 416.29
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [3 points] What is the execution time of the benchmark in milliseconds for the new generation of the processor?",
                    "md": "# (b) [3 points] What is the execution time of the benchmark in milliseconds for the new generation of the processor?",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 340.16,
                        "w": 451.81,
                        "h": 21.95
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Answer: 80 ms.\n\nExplanation:\n\nExecution Time = [Number of Instructions] \u00d7 [CPI] \u00d7 [Frequency\u22121]\n\nLet\u2019s say that the CPI of baseline is c, and number of instructions is i.\n\nThen the execution time of baseline:\n\n(c \u00d7 i)/(500x106) = 100x10\u22123 seconds  =>    (c \u00d7 i) = 5 \u00d7 107\n\nThe execution time after modifications: ((1.2 \u00d7 c) \u00d7 i)/(750x106)\n\nT = ((1.2 \u00d7 (c \u00d7 i))/(750 \u00d7 106)) seconds.\n\nT = ((1.2 \u00d7 (5 \u00d7 107))/(750 \u00d7 106)) seconds.\n\nT = 8 \u00d7 10\u22122 = 80ms.",
                    "md": "Answer: 80 ms.\n\nExplanation:\n\nExecution Time = [Number of Instructions] \u00d7 [CPI] \u00d7 [Frequency\u22121]\n\nLet\u2019s say that the CPI of baseline is c, and number of instructions is i.\n\nThen the execution time of baseline:\n\n(c \u00d7 i)/(500x106) = 100x10\u22123 seconds  =>    (c \u00d7 i) = 5 \u00d7 107\n\nThe execution time after modifications: ((1.2 \u00d7 c) \u00d7 i)/(750x106)\n\nT = ((1.2 \u00d7 (c \u00d7 i))/(750 \u00d7 106)) seconds.\n\nT = ((1.2 \u00d7 (5 \u00d7 107))/(750 \u00d7 106)) seconds.\n\nT = 8 \u00d7 10\u22122 = 80ms.",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 205.2,
                        "w": 318.63,
                        "h": 375.2
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [3 points] What is the speedup or slowdown of the new generation processor over the old generation?",
                    "md": "# (c) [3 points] What is the speedup or slowdown of the new generation processor over the old generation?",
                    "rows": null,
                    "bBox": {
                        "x": 72.55,
                        "y": 528.17,
                        "w": 446.48,
                        "h": 88.1
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Answer: 25% speedup\n\nExplanation:\n\nSpeedup = (OldExecutionTime / [NewExecutionTime]) \u2212 1\n\nSpeedup = 100/80 \u2212 1\n\nSpeedup = 0.25\n\nThen the modification introduces 25% speedup.\n\nFinal Exam                                                                            Page 4 of 40",
                    "md": "Answer: 25% speedup\n\nExplanation:\n\nSpeedup = (OldExecutionTime / [NewExecutionTime]) \u2212 1\n\nSpeedup = 100/80 \u2212 1\n\nSpeedup = 0.25\n\nThen the modification introduces 25% speedup.\n\nFinal Exam                                                                            Page 4 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 205.2,
                        "w": 451.32,
                        "h": 589.47
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 6,
            "text": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n2    Verilog     [30 points]\nPlease answer the following four questions about Verilog.\n(a) [6 points] Does the following code result in a sequential circuit or a combinational circuit? Explain\n    why.\n 1  module  concat  (input clk, input data_in1,      input data_in2,\n 2                                        output  reg  [1:0] data_out);\n 3   always  @ (posedge clk, data_in1)\n 4     if (data_in1)\n 5         data_out  = {data_in1, data_in2};\n 6     else if (data_in2)\n 7         data_out  = {data_in2, data_in1};\n 8  endmodule\n    Answer and concise explanation:\n   Sequential circuit.\n   Explanation.\n   This code results in a sequential circuit because data_in2 is not in the sensitivity list, and thus a\n   latch is inferred for data_out.\n(b) [6 points] In the following code, the input clk is a clock signal. What is the hexadecimal value of\n    the output c right after the third positive edge of clk if initially c = 8\u2019hE3 and a = 4\u2019d8 and\n    b = 4\u2019o2 during the entire time?\n 1  module  mod1 (input clk, input [3:0] a, input [3:0] b, output          reg  [7:0] c);\n 2  always  @ (posedge clk)\n 3    begin\n 4      c  <= {c,  &a, |b};\n 5      c[0] <= ^c[7:6];\n 6    end\n 7  endmodule\n    Please answer below. Show your work.\n   8\u2019hC4.\n   Explanation.\n   Cycle 1:      c <= {c, &a, |b} \u2192 c <= {1110_0011, 0, 1} \u2192 c <= {1000_1101}\n            c[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{11} \u2192 c[0] <= 0\n   At the first positive edge of clk, c = 8\u2032b1000_1100\n   Cycle 2:      c <= {c, &a, |b} \u2192 c <= {1000_1100, 0, 1} \u2192 c <= {0011_0001}\n            c[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{10} \u2192 c[0] <= 1\n   At the second positive edge of clk, c = 8\u2032b0011_0001\n   Cycle 3:      c <= {c, &a, |b} \u2192 c <= {0011_0001, 0, 1} \u2192 c <= {1100_0101}\n            c[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{00} \u2192 c[0] <= 0\n   At the third positive edge of clk, c = 8\u2032b1100_0100 \u2192 c = 8\u2032hC4\n   Note that since the assignments to c are non-blocking, c[7 : 6] in line 5 is not affected by the assignment\n   to c in line 4 in the same cycle.\nFinal Exam                                                                            Page 5 of 40",
            "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n# 2    Verilog     [30 points]\n\nPlease answer the following four questions about Verilog.\n\n# (a) [6 points]\n\nDoes the following code result in a sequential circuit or a combinational circuit? Explain why.\n\nmodule  concat  (input clk, input data_in1,      input data_in2,\noutput  reg  [1:0] data_out);\nalways  @ (posedge clk, data_in1)\nif (data_in1)\ndata_out  = {data_in1, data_in2};\nelse if (data_in2)\ndata_out  = {data_in2, data_in1};\nendmodule\n\nAnswer and concise explanation:\n\nSequential circuit.\n\nExplanation.\n\nThis code results in a sequential circuit because data_in2 is not in the sensitivity list, and thus a latch is inferred for data_out.\n\n# (b) [6 points]\n\nIn the following code, the input clk is a clock signal. What is the hexadecimal value of the output c right after the third positive edge of clk if initially c = 8\u2019hE3 and a = 4\u2019d8 and b = 4\u2019o2 during the entire time?\n\nmodule  mod1 (input clk, input [3:0] a, input [3:0] b, output          reg  [7:0] c);\nalways  @ (posedge clk)\nbegin\nc  <= {c,  &a, |b};\nc[0] <= ^c[7:6];\nend\nendmodule\n\nPlease answer below. Show your work.\n\n8\u2019hC4.\n\nExplanation.\n\nCycle 1:      c <= {c, &a, |b} \u2192 c <= {1110_0011, 0, 1} \u2192 c <= {1000_1101}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{11} \u2192 c[0] <= 0\nAt the first positive edge of clk, c = 8\u2032b1000_1100\n\nCycle 2:      c <= {c, &a, |b} \u2192 c <= {1000_1100, 0, 1} \u2192 c <= {0011_0001}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{10} \u2192 c[0] <= 1\nAt the second positive edge of clk, c = 8\u2032b0011_0001\n\nCycle 3:      c <= {c, &a, |b} \u2192 c <= {0011_0001, 0, 1} \u2192 c <= {1100_0101}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{00} \u2192 c[0] <= 0\nAt the third positive edge of clk, c = 8\u2032b1100_0100 \u2192 c = 8\u2032hC4\n\nNote that since the assignments to c are non-blocking, c[7 : 6] in line 5 is not affected by the assignment to c in line 4 in the same cycle.\n\nFinal Exam                                                                            Page 5 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 441.08
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "2    Verilog     [30 points]",
                    "md": "# 2    Verilog     [30 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 130.09,
                        "h": 405.6
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Please answer the following four questions about Verilog.",
                    "md": "Please answer the following four questions about Verilog.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 248.66,
                        "h": 36.2
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [6 points]",
                    "md": "# (a) [6 points]",
                    "rows": null,
                    "bBox": {
                        "x": 76.36,
                        "y": 204.38,
                        "w": 3.0,
                        "h": 301.72
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Does the following code result in a sequential circuit or a combinational circuit? Explain why.\n\nmodule  concat  (input clk, input data_in1,      input data_in2,\noutput  reg  [1:0] data_out);\nalways  @ (posedge clk, data_in1)\nif (data_in1)\ndata_out  = {data_in1, data_in2};\nelse if (data_in2)\ndata_out  = {data_in2, data_in1};\nendmodule\n\nAnswer and concise explanation:\n\nSequential circuit.\n\nExplanation.\n\nThis code results in a sequential circuit because data_in2 is not in the sensitivity list, and thus a latch is inferred for data_out.",
                    "md": "Does the following code result in a sequential circuit or a combinational circuit? Explain why.\n\nmodule  concat  (input clk, input data_in1,      input data_in2,\noutput  reg  [1:0] data_out);\nalways  @ (posedge clk, data_in1)\nif (data_in1)\ndata_out  = {data_in1, data_in2};\nelse if (data_in2)\ndata_out  = {data_in2, data_in1};\nendmodule\n\nAnswer and concise explanation:\n\nSequential circuit.\n\nExplanation.\n\nThis code results in a sequential circuit because data_in2 is not in the sensitivity list, and thus a latch is inferred for data_out.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 456.74,
                        "h": 515.09
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [6 points]",
                    "md": "# (b) [6 points]",
                    "rows": null,
                    "bBox": {
                        "x": 76.36,
                        "y": 204.38,
                        "w": 3.0,
                        "h": 301.72
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "In the following code, the input clk is a clock signal. What is the hexadecimal value of the output c right after the third positive edge of clk if initially c = 8\u2019hE3 and a = 4\u2019d8 and b = 4\u2019o2 during the entire time?\n\nmodule  mod1 (input clk, input [3:0] a, input [3:0] b, output          reg  [7:0] c);\nalways  @ (posedge clk)\nbegin\nc  <= {c,  &a, |b};\nc[0] <= ^c[7:6];\nend\nendmodule\n\nPlease answer below. Show your work.\n\n8\u2019hC4.\n\nExplanation.\n\nCycle 1:      c <= {c, &a, |b} \u2192 c <= {1110_0011, 0, 1} \u2192 c <= {1000_1101}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{11} \u2192 c[0] <= 0\nAt the first positive edge of clk, c = 8\u2032b1000_1100\n\nCycle 2:      c <= {c, &a, |b} \u2192 c <= {1000_1100, 0, 1} \u2192 c <= {0011_0001}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{10} \u2192 c[0] <= 1\nAt the second positive edge of clk, c = 8\u2032b0011_0001\n\nCycle 3:      c <= {c, &a, |b} \u2192 c <= {0011_0001, 0, 1} \u2192 c <= {1100_0101}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{00} \u2192 c[0] <= 0\nAt the third positive edge of clk, c = 8\u2032b1100_0100 \u2192 c = 8\u2032hC4\n\nNote that since the assignments to c are non-blocking, c[7 : 6] in line 5 is not affected by the assignment to c in line 4 in the same cycle.\n\nFinal Exam                                                                            Page 5 of 40",
                    "md": "In the following code, the input clk is a clock signal. What is the hexadecimal value of the output c right after the third positive edge of clk if initially c = 8\u2019hE3 and a = 4\u2019d8 and b = 4\u2019o2 during the entire time?\n\nmodule  mod1 (input clk, input [3:0] a, input [3:0] b, output          reg  [7:0] c);\nalways  @ (posedge clk)\nbegin\nc  <= {c,  &a, |b};\nc[0] <= ^c[7:6];\nend\nendmodule\n\nPlease answer below. Show your work.\n\n8\u2019hC4.\n\nExplanation.\n\nCycle 1:      c <= {c, &a, |b} \u2192 c <= {1110_0011, 0, 1} \u2192 c <= {1000_1101}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{11} \u2192 c[0] <= 0\nAt the first positive edge of clk, c = 8\u2032b1000_1100\n\nCycle 2:      c <= {c, &a, |b} \u2192 c <= {1000_1100, 0, 1} \u2192 c <= {0011_0001}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{10} \u2192 c[0] <= 1\nAt the second positive edge of clk, c = 8\u2032b0011_0001\n\nCycle 3:      c <= {c, &a, |b} \u2192 c <= {0011_0001, 0, 1} \u2192 c <= {1100_0101}\nc[0] <= \u02c6c[7:6] \u2192 c[0] <= \u02c6{00} \u2192 c[0] <= 0\nAt the third positive edge of clk, c = 8\u2032b1100_0100 \u2192 c = 8\u2032hC4\n\nNote that since the assignments to c are non-blocking, c[7 : 6] in line 5 is not affected by the assignment to c in line 4 in the same cycle.\n\nFinal Exam                                                                            Page 5 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 456.75,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 7,
            "text": "Initials: Solutions                 Design of Digital Circuits                August 18th, 2018\n(c) [6 points] Is the following code syntactically correct? If not, please explain the mistake(s) and how\n    to fix it/them.\n 1  module  1nn3r   ( input [3:0] d, input op,   output[1:0] s);\n 2    assign  s  =  op ? (d[1:0] -  d[3:2])  :\n 3                             (d[3:2]  + d[1:0]);\n 4  endmodule\n 5\n 6  module  top  (  input wire [6:0] instr,   input wire op,   output  reg z);\n 7\n 8    reg[1:0] r1,   r2;\n 9\n10    1nn3r i0 (.instr(instr[1:0]), .op(instr[7]),       .z(r1)  );\n11    1nn3r i1 (.instr(instr[3:2]), .op(instr[0]),       .z(r2)  );\n12    assign  z  =  r1 | r2;\n13\n14  endmodule\n    Answer and concise explanation:\n   The code is not syntactically correct.\n   Explanation.\n     \u2022 Module names cannot start with a number \u2192 \u20191nn3r\u2019 is not a legal module name.\n     \u2022 The output signal \u2019z\u2019 has to be declared as a \u2019wire\u2019 but not \u2019reg\u2019.\n     \u2022 \u2019r1\u2019 and \u2019r2\u2019 has to be declared as \u2019wire\u2019s.\n     \u2022 The module \u20191nn3r\u2019 does not have ports named \u2019instr\u2019 and \u2019z\u2019. Those need to be changed to \u2019d\u2019\n      and \u2019s\u2019, respectively.\nFinal Exam                                                                          Page 6 of 40",
            "md": "Initials: Solutions                 Design of Digital Circuits                August 18th, 2018\n\n(c) [6 points] Is the following code syntactically correct? If not, please explain the mistake(s) and how to fix it/them.\n\n1  module  1nn3r   ( input [3:0] d, input op,   output[1:0] s);\n2    assign  s  =  op ? (d[1:0] -  d[3:2])  :\n3                             (d[3:2]  + d[1:0]);\n4  endmodule\n5\n6  module  top  (  input wire [6:0] instr,   input wire op,   output  reg z);\n7\n8    reg[1:0] r1,   r2;\n9\n10    1nn3r i0 (.instr(instr[1:0]), .op(instr[7]),       .z(r1)  );\n11    1nn3r i1 (.instr(instr[3:2]), .op(instr[0]),       .z(r2)  );\n12    assign  z  =  r1 | r2;\n13\n14  endmodule\n\nAnswer and concise explanation:\n\nThe code is not syntactically correct.\n\nExplanation.\n\n- Module names cannot start with a number \u2192 \u20191nn3r\u2019 is not a legal module name.\n- The output signal \u2019z\u2019 has to be declared as a \u2019wire\u2019 but not \u2019reg\u2019.\n- \u2019r1\u2019 and \u2019r2\u2019 has to be declared as \u2019wire\u2019s.\n- The module \u20191nn3r\u2019 does not have ports named \u2019instr\u2019 and \u2019z\u2019. Those need to be changed to \u2019d\u2019 and \u2019s\u2019, respectively.\n\nFinal Exam                                                                          Page 6 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                 Design of Digital Circuits                August 18th, 2018\n\n(c) [6 points] Is the following code syntactically correct? If not, please explain the mistake(s) and how to fix it/them.\n\n1  module  1nn3r   ( input [3:0] d, input op,   output[1:0] s);\n2    assign  s  =  op ? (d[1:0] -  d[3:2])  :\n3                             (d[3:2]  + d[1:0]);\n4  endmodule\n5\n6  module  top  (  input wire [6:0] instr,   input wire op,   output  reg z);\n7\n8    reg[1:0] r1,   r2;\n9\n10    1nn3r i0 (.instr(instr[1:0]), .op(instr[7]),       .z(r1)  );\n11    1nn3r i1 (.instr(instr[3:2]), .op(instr[0]),       .z(r2)  );\n12    assign  z  =  r1 | r2;\n13\n14  endmodule\n\nAnswer and concise explanation:\n\nThe code is not syntactically correct.\n\nExplanation.\n\n- Module names cannot start with a number \u2192 \u20191nn3r\u2019 is not a legal module name.\n- The output signal \u2019z\u2019 has to be declared as a \u2019wire\u2019 but not \u2019reg\u2019.\n- \u2019r1\u2019 and \u2019r2\u2019 has to be declared as \u2019wire\u2019s.\n- The module \u20191nn3r\u2019 does not have ports named \u2019instr\u2019 and \u2019z\u2019. Those need to be changed to \u2019d\u2019 and \u2019s\u2019, respectively.\n\nFinal Exam                                                                          Page 6 of 40",
                    "md": "Initials: Solutions                 Design of Digital Circuits                August 18th, 2018\n\n(c) [6 points] Is the following code syntactically correct? If not, please explain the mistake(s) and how to fix it/them.\n\n1  module  1nn3r   ( input [3:0] d, input op,   output[1:0] s);\n2    assign  s  =  op ? (d[1:0] -  d[3:2])  :\n3                             (d[3:2]  + d[1:0]);\n4  endmodule\n5\n6  module  top  (  input wire [6:0] instr,   input wire op,   output  reg z);\n7\n8    reg[1:0] r1,   r2;\n9\n10    1nn3r i0 (.instr(instr[1:0]), .op(instr[7]),       .z(r1)  );\n11    1nn3r i1 (.instr(instr[3:2]), .op(instr[0]),       .z(r2)  );\n12    assign  z  =  r1 | r2;\n13\n14  endmodule\n\nAnswer and concise explanation:\n\nThe code is not syntactically correct.\n\nExplanation.\n\n- Module names cannot start with a number \u2192 \u20191nn3r\u2019 is not a legal module name.\n- The output signal \u2019z\u2019 has to be declared as a \u2019wire\u2019 but not \u2019reg\u2019.\n- \u2019r1\u2019 and \u2019r2\u2019 has to be declared as \u2019wire\u2019s.\n- The module \u20191nn3r\u2019 does not have ports named \u2019instr\u2019 and \u2019z\u2019. Those need to be changed to \u2019d\u2019 and \u2019s\u2019, respectively.\n\nFinal Exam                                                                          Page 6 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 456.66,
                        "h": 751.56
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 8,
            "text": "Initials: Solutions                            Design of Digital Circuits       August 18th, 2018\n        (d) [6 points] Does the following code correctly implement a counter that counts from 1 to 11 by incre-\n    ments of 2 (e.g., 1, 3, 5, 7, 9, 11, 1, 3, ...)? If so, say \"Correct\". If not, correct the code with minimal\n    modification.\n 1  module  odd_counter   (clk, count);\n 2     wire clk;\n 3     reg[2:0] count;\n 4     reg[2:0] count_next;\n 5\n 6     always@*\n 7     begin\n 8      count_next   = count;\n 9      if(count   != 11)\n10         count_next  =  count_next   + 2;\n11      else\n12         count_next <= 1;\n13     end\n14\n15     always@(posedge clk)\n16      count <= count_next;\n17  endmodule\n    Answer and concise explanation:\n   No, the implementation is not correct.\n   Explanation.\n   The correct implementation:\n   module odd_counter (clk, count);\n     wire clk;\n     reg[3:0] count = 1;\n     reg[3:0] count_next;\n     always@* begin\n      count_next = count;\n      if(count != 11)\n       count_next += 2;\n      else\n       count_next = 1;\n     end\n     always@(posedge clk)\n      count <= count_next;\n   endmodule\nFinal Exam                                                                            Page 7 of 40",
            "md": "Initials: Solutions                            Design of Digital Circuits       August 18th, 2018\n\n# (d) [6 points]\n\nDoes the following code correctly implement a counter that counts from 1 to 11 by increments of 2 (e.g., 1, 3, 5, 7, 9, 11, 1, 3, ...)? If so, say \"Correct\". If not, correct the code with minimal modification.\n\n1  module  odd_counter   (clk, count);\n2     wire clk;\n3     reg[2:0] count;\n4     reg[2:0] count_next;\n5\n6     always@*\n7     begin\n8      count_next   = count;\n9      if(count   != 11)\n10         count_next  =  count_next   + 2;\n11      else\n12         count_next <= 1;\n13     end\n14\n15     always@(posedge clk)\n16      count <= count_next;\n17  endmodule\n\nAnswer and concise explanation:\n\nNo, the implementation is not correct.\n\nExplanation.\n\nThe correct implementation:\n\nmodule odd_counter (clk, count);\nwire clk;\nreg[3:0] count = 1;\nreg[3:0] count_next;\nalways@* begin\ncount_next = count;\nif(count != 11)\ncount_next += 2;\nelse\ncount_next = 1;\nend\nalways@(posedge clk)\ncount <= count_next;\nendmodule\n\nFinal Exam                                                                            Page 7 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                            Design of Digital Circuits       August 18th, 2018",
                    "md": "Initials: Solutions                            Design of Digital Circuits       August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 157.53
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) [6 points]",
                    "md": "# (d) [6 points]",
                    "rows": null,
                    "bBox": {
                        "x": 76.36,
                        "y": 173.72,
                        "w": 3.0,
                        "h": 5.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Does the following code correctly implement a counter that counts from 1 to 11 by increments of 2 (e.g., 1, 3, 5, 7, 9, 11, 1, 3, ...)? If so, say \"Correct\". If not, correct the code with minimal modification.\n\n1  module  odd_counter   (clk, count);\n2     wire clk;\n3     reg[2:0] count;\n4     reg[2:0] count_next;\n5\n6     always@*\n7     begin\n8      count_next   = count;\n9      if(count   != 11)\n10         count_next  =  count_next   + 2;\n11      else\n12         count_next <= 1;\n13     end\n14\n15     always@(posedge clk)\n16      count <= count_next;\n17  endmodule\n\nAnswer and concise explanation:\n\nNo, the implementation is not correct.\n\nExplanation.\n\nThe correct implementation:\n\nmodule odd_counter (clk, count);\nwire clk;\nreg[3:0] count = 1;\nreg[3:0] count_next;\nalways@* begin\ncount_next = count;\nif(count != 11)\ncount_next += 2;\nelse\ncount_next = 1;\nend\nalways@(posedge clk)\ncount <= count_next;\nendmodule\n\nFinal Exam                                                                            Page 7 of 40",
                    "md": "Does the following code correctly implement a counter that counts from 1 to 11 by increments of 2 (e.g., 1, 3, 5, 7, 9, 11, 1, 3, ...)? If so, say \"Correct\". If not, correct the code with minimal modification.\n\n1  module  odd_counter   (clk, count);\n2     wire clk;\n3     reg[2:0] count;\n4     reg[2:0] count_next;\n5\n6     always@*\n7     begin\n8      count_next   = count;\n9      if(count   != 11)\n10         count_next  =  count_next   + 2;\n11      else\n12         count_next <= 1;\n13     end\n14\n15     always@(posedge clk)\n16      count <= count_next;\n17  endmodule\n\nAnswer and concise explanation:\n\nNo, the implementation is not correct.\n\nExplanation.\n\nThe correct implementation:\n\nmodule odd_counter (clk, count);\nwire clk;\nreg[3:0] count = 1;\nreg[3:0] count_next;\nalways@* begin\ncount_next = count;\nif(count != 11)\ncount_next += 2;\nelse\ncount_next = 1;\nend\nalways@(posedge clk)\ncount <= count_next;\nendmodule\n\nFinal Exam                                                                            Page 7 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 83.96,
                        "w": 451.32,
                        "h": 710.71
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 9,
            "text": "Initials: Solutions                Design of Digital Circuits               August 18th, 2018\n(e) [6 points] Does the following code correctly instantiate a 4-bit adder? If so, say \"Correct\". If not,\n    correct the code with minimal modification.\n 1  module  adder(input a, input b, input c, output     sum, output  carry);\n 2  assign  sum =  a  ^ b ^  c;\n 3  assign  carry  =  (a&b)  | (b&c) | (c&a);\n 4  endmodule\n 5\n 6\n 7  module  adder_4bits(input [3:0] a, input [3:0] b, output     [3:0] sum, carry);\n 8  wire [2:0]s;\n 9\n10  adder u0 (a[0],b[0],1\u2019b0,sum[0],s[0]);\n11  adder u1 (a[1],s[0],b[1],sum[1],s[1]);\n12  adder u2 (a[2],s[1],b[2],sum[2],s[2]);\n13  adder u3 (a[3],s[2],b[3],sum[3],carry);\n14  endmodule\n   Yes.\n   Explanation: Even though the wire s is swapped with the input b, the final computation produced\n   by the module adder is still going to be correct since the or and and operations are commutative.\nFinal Exam                                                                        Page 8 of 40",
            "md": "Initials: Solutions                Design of Digital Circuits               August 18th, 2018\n\n(e) [6 points] Does the following code correctly instantiate a 4-bit adder? If so, say \"Correct\". If not, correct the code with minimal modification.\n\n1  module  adder(input a, input b, input c, output     sum, output  carry);\n2  assign  sum =  a  ^ b ^  c;\n3  assign  carry  =  (a&b)  | (b&c) | (c&a);\n4  endmodule\n5\n6\n7  module  adder_4bits(input [3:0] a, input [3:0] b, output     [3:0] sum, carry);\n8  wire [2:0]s;\n9\n10  adder u0 (a[0],b[0],1\u2019b0,sum[0],s[0]);\n11  adder u1 (a[1],s[0],b[1],sum[1],s[1]);\n12  adder u2 (a[2],s[1],b[2],sum[2],s[2]);\n13  adder u3 (a[3],s[2],b[3],sum[3],carry);\n14  endmodule\n\nYes.\n\nExplanation: Even though the wire s is swapped with the input b, the final computation produced by the module adder is still going to be correct since the or and and operations are commutative.\n\nFinal Exam                                                                        Page 8 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                Design of Digital Circuits               August 18th, 2018\n\n(e) [6 points] Does the following code correctly instantiate a 4-bit adder? If so, say \"Correct\". If not, correct the code with minimal modification.\n\n1  module  adder(input a, input b, input c, output     sum, output  carry);\n2  assign  sum =  a  ^ b ^  c;\n3  assign  carry  =  (a&b)  | (b&c) | (c&a);\n4  endmodule\n5\n6\n7  module  adder_4bits(input [3:0] a, input [3:0] b, output     [3:0] sum, carry);\n8  wire [2:0]s;\n9\n10  adder u0 (a[0],b[0],1\u2019b0,sum[0],s[0]);\n11  adder u1 (a[1],s[0],b[1],sum[1],s[1]);\n12  adder u2 (a[2],s[1],b[2],sum[2],s[2]);\n13  adder u3 (a[3],s[2],b[3],sum[3],carry);\n14  endmodule\n\nYes.\n\nExplanation: Even though the wire s is swapped with the input b, the final computation produced by the module adder is still going to be correct since the or and and operations are commutative.\n\nFinal Exam                                                                        Page 8 of 40",
                    "md": "Initials: Solutions                Design of Digital Circuits               August 18th, 2018\n\n(e) [6 points] Does the following code correctly instantiate a 4-bit adder? If so, say \"Correct\". If not, correct the code with minimal modification.\n\n1  module  adder(input a, input b, input c, output     sum, output  carry);\n2  assign  sum =  a  ^ b ^  c;\n3  assign  carry  =  (a&b)  | (b&c) | (c&a);\n4  endmodule\n5\n6\n7  module  adder_4bits(input [3:0] a, input [3:0] b, output     [3:0] sum, carry);\n8  wire [2:0]s;\n9\n10  adder u0 (a[0],b[0],1\u2019b0,sum[0],s[0]);\n11  adder u1 (a[1],s[0],b[1],sum[1],s[1]);\n12  adder u2 (a[2],s[1],b[2],sum[2],s[2]);\n13  adder u3 (a[3],s[2],b[3],sum[3],carry);\n14  endmodule\n\nYes.\n\nExplanation: Even though the wire s is swapped with the input b, the final computation produced by the module adder is still going to be correct since the or and and operations are commutative.\n\nFinal Exam                                                                        Page 8 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 456.58,
                        "h": 751.56
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 10,
            "text": "Initials: Solutions               Design of Digital Circuits               August 18th, 2018\n3    Boolean Algebra         [15 points]\n(a) [5 points] Find the simplest sum-of-products representation of the following Boolean equation. Show\n    your work step-by-step.\n    F = B + (A +  ~~C</s>).(<s>A</s> +<s>B</s> +<s>C~~  )\n   Answer: F = A + B +    ~~C~~  \n   Explanation:\n   F = B + (A.A + A.B + A.C + A.C + B.C + C.C)\n   F = B + 0 + A.B + C.(A +  ~~A</s>) + B.C +<s>C~~  \n   F = (B + A.B) + C.(A +  ~~A</s>) + (B.C +<s>C~~  )\n   F = (B + A) +  ~~C</s> + C.(<s>B~~   + 1)\n   F = A + B +  ~~C~~  \n(b) [5 points] Convert the following Boolean equation so that it only contains NAND operations. Show\n    your work step-by-step.\n    F = (A + B.C) +  ~~C~~  \n     Answer: F = (((A.A).(B.C)).C)\n     Explanation:\n     F = (((A + B.C) + ~~C~~  ))\n     F = ((A + B.C).C)\n     F = ((A + B.C).C)\n     F = ((A.(B.C)).C)\n     F = (((A.A).(B.C)).C)\n (c) [5 points] Using Boolean algebra, simplify the following min-terms: \u2211(3, 5, 7, 11, 13, 15)\n    Show your work step-by-step.\n   Answer: F = D.(B + C)\n   Explanation:\n   {3, 5, 7, 11, 13, 15} = {0011, 0101, 0111, 1011, 1101, 1111}\n   F = (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D)\n   F = (C.D.((A.B) + (A.B) + (A.B) + (A.B))) + (B.D.((A.C ) + (A.C )))\n   F = (C.D) + (B.C.D)\n   F = D.(C + (B.C))\n   F = D.(B + C)\nFinal Exam                                                                      Page 9 of 40",
            "md": "Initials: Solutions\n\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# 3 Boolean Algebra [15 points]\n\n# (a) [5 points] Find the simplest sum-of-products representation of the following Boolean equation. Show your work step-by-step.\n\nF = B + (A + ~~C).(A +B +C~~)\n\nAnswer: F = A + B + ~~C~~\n\n# Explanation:\n\nF = B + (A.A + A.B + A.C + A.C + B.C + C.C)\n\nF = B + 0 + A.B + C.(A + ~~A) + B.C +C~~\n\nF = (B + A.B) + C.(A + ~~A) + (B.C +C~~)\n\nF = (B + A) + ~~C + C.(B~~ + 1)\n\nF = A + B + ~~C~~\n\n# (b) [5 points] Convert the following Boolean equation so that it only contains NAND operations. Show your work step-by-step.\n\nF = (A + B.C) + ~~C~~\n\nAnswer: F = (((A.A).(B.C)).C)\n\n# Explanation:\n\nF = (((A + B.C) +~~C~~))\n\nF = ((A + B.C).C)\n\nF = ((A + B.C).C)\n\nF = ((A.(B.C)).C)\n\nF = (((A.A).(B.C)).C)\n\n# (c) [5 points] Using Boolean algebra, simplify the following min-terms: \u2211(3, 5, 7, 11, 13, 15) Show your work step-by-step.\n\nAnswer: F = D.(B + C)\n\n# Explanation:\n\n{3, 5, 7, 11, 13, 15} = {0011, 0101, 0111, 1011, 1101, 1111}\n\nF = (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D)\n\nF = (C.D.((A.B) + (A.B) + (A.B) + (A.B))) + (B.D.((A.C ) + (A.C )))\n\nF = (C.D) + (B.C.D)\n\nF = D.(C + (B.C))\n\nF = D.(B + C)\n\nFinal Exam Page 9 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "3 Boolean Algebra [15 points]",
                    "md": "# 3 Boolean Algebra [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 196.69,
                        "h": 14.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [5 points] Find the simplest sum-of-products representation of the following Boolean equation. Show your work step-by-step.",
                    "md": "# (a) [5 points] Find the simplest sum-of-products representation of the following Boolean equation. Show your work step-by-step.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 93.82,
                        "w": 451.31,
                        "h": 432.94
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "F = B + (A + ~~C).(A +B +C~~)\n\nAnswer: F = A + B + ~~C~~",
                    "md": "F = B + (A + ~~C).(A +B +C~~)\n\nAnswer: F = A + B + ~~C~~",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 121.71,
                        "w": 104.06,
                        "h": 113.34
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Explanation:",
                    "md": "# Explanation:",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 165.28,
                        "w": 71.75,
                        "h": 403.17
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "F = B + (A.A + A.B + A.C + A.C + B.C + C.C)\n\nF = B + 0 + A.B + C.(A + ~~A) + B.C +C~~\n\nF = (B + A.B) + C.(A + ~~A) + (B.C +C~~)\n\nF = (B + A) + ~~C + C.(B~~ + 1)\n\nF = A + B + ~~C~~",
                    "md": "F = B + (A.A + A.B + A.C + A.C + B.C + C.C)\n\nF = B + 0 + A.B + C.(A + ~~A) + B.C +C~~\n\nF = (B + A.B) + C.(A + ~~A) + (B.C +C~~)\n\nF = (B + A) + ~~C + C.(B~~ + 1)\n\nF = A + B + ~~C~~",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 177.24,
                        "w": 219.31,
                        "h": 57.82
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [5 points] Convert the following Boolean equation so that it only contains NAND operations. Show your work step-by-step.",
                    "md": "# (b) [5 points] Convert the following Boolean equation so that it only contains NAND operations. Show your work step-by-step.",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 105.77,
                        "w": 451.87,
                        "h": 420.99
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "F = (A + B.C) + ~~C~~\n\nAnswer: F = (((A.A).(B.C)).C)",
                    "md": "F = (A + B.C) + ~~C~~\n\nAnswer: F = (((A.A).(B.C)).C)",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 327.21,
                        "w": 151.52,
                        "h": 133.38
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Explanation:",
                    "md": "# Explanation:",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 165.28,
                        "w": 71.75,
                        "h": 403.17
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "F = (((A + B.C) +~~C~~))\n\nF = ((A + B.C).C)\n\nF = ((A + B.C).C)\n\nF = ((A.(B.C)).C)\n\nF = (((A.A).(B.C)).C)",
                    "md": "F = (((A + B.C) +~~C~~))\n\nF = ((A + B.C).C)\n\nF = ((A + B.C).C)\n\nF = ((A.(B.C)).C)\n\nF = (((A.A).(B.C)).C)",
                    "rows": null,
                    "bBox": {
                        "x": 94.22,
                        "y": 387.82,
                        "w": 101.93,
                        "h": 72.76
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [5 points] Using Boolean algebra, simplify the following min-terms: \u2211(3, 5, 7, 11, 13, 15) Show your work step-by-step.",
                    "md": "# (c) [5 points] Using Boolean algebra, simplify the following min-terms: \u2211(3, 5, 7, 11, 13, 15) Show your work step-by-step.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 399.29,
                        "h": 459.15
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Answer: F = D.(B + C)",
                    "md": "Answer: F = D.(B + C)",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 534.54,
                        "w": 113.38,
                        "h": 129.55
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Explanation:",
                    "md": "# Explanation:",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 165.28,
                        "w": 71.75,
                        "h": 403.17
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "{3, 5, 7, 11, 13, 15} = {0011, 0101, 0111, 1011, 1101, 1111}\n\nF = (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D)\n\nF = (C.D.((A.B) + (A.B) + (A.B) + (A.B))) + (B.D.((A.C ) + (A.C )))\n\nF = (C.D) + (B.C.D)\n\nF = D.(C + (B.C))\n\nF = D.(B + C)\n\nFinal Exam Page 9 of 40",
                    "md": "{3, 5, 7, 11, 13, 15} = {0011, 0101, 0111, 1011, 1101, 1111}\n\nF = (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D) + (A.B.C.D)\n\nF = (C.D.((A.B) + (A.B) + (A.B) + (A.B))) + (B.D.((A.C ) + (A.C )))\n\nF = (C.D) + (B.C.D)\n\nF = D.(C + (B.C))\n\nF = D.(B + C)\n\nFinal Exam Page 9 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.32,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 11,
            "text": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n4    Finite State Machine             [50 points]\nYou are given the following FSM with two one-bit input signals (TA and TB) and one two-bit output\nsignal (O). You need to implement this FSM, but you are unsure about how you should encode the\nstates. Answer the following questions to get a better sense of the FSM and how the three different types\nof state encoding we dicussed in the lecture (i.e., one-hot, binary, output) will affect the implementation.\n                      A                    TA                      B\n                                         __\n                    O: 10                TB                      O: 11\n                  TB                              __                 __\n                                                  TA                 TB\n                      C                                            D\n                    O: 01                                        O: 00         TB\n(a) [3 points] There is one critical component of an FSM that is missing in this diagram. Please write\n    what is missing in the answer box below.\n   The reset line or indication for initial state.\n(b) [2 points] Of the two FSM types, what type of an FSM is this?\n   Moore\nFinal Exam                                                                           Page 10 of 40",
            "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n# 4    Finite State Machine             [50 points]\n\nYou are given the following FSM with two one-bit input signals (TA and TB) and one two-bit output signal (O). You need to implement this FSM, but you are unsure about how you should encode the states. Answer the following questions to get a better sense of the FSM and how the three different types of state encoding we discussed in the lecture (i.e., one-hot, binary, output) will affect the implementation.\n\n|      |   |       | A     | TA    | B |\n| ---- | - | ----- | ----- | ----- | - |\n|      |   | O: 10 | TB    | O: 11 |   |\n|      |   | \\_\\_  |       |       |   |\n| \\_\\_ |   |       | TA    | TB    |   |\n|      |   |       | C     | O: 01 | D |\n|      |   |       | O: 00 | TB    |   |\n\n(a) [3 points] There is one critical component of an FSM that is missing in this diagram. Please write what is missing in the answer box below.\n\nThe reset line or indication for initial state.\n\n(b) [2 points] Of the two FSM types, what type of an FSM is this?\n\nMoore\n\nFinal Exam                                                                           Page 10 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 279.24
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "4    Finite State Machine             [50 points]",
                    "md": "# 4    Finite State Machine             [50 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 245.33,
                        "h": 254.74
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "You are given the following FSM with two one-bit input signals (TA and TB) and one two-bit output signal (O). You need to implement this FSM, but you are unsure about how you should encode the states. Answer the following questions to get a better sense of the FSM and how the three different types of state encoding we discussed in the lecture (i.e., one-hot, binary, output) will affect the implementation.",
                    "md": "You are given the following FSM with two one-bit input signals (TA and TB) and one two-bit output signal (O). You need to implement this FSM, but you are unsure about how you should encode the states. Answer the following questions to get a better sense of the FSM and how the three different types of state encoding we discussed in the lecture (i.e., one-hot, binary, output) will affect the implementation.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 93.82,
                        "w": 451.44,
                        "h": 262.89
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|      |   |       | A     | TA    | B |\n| ---- | - | ----- | ----- | ----- | - |\n|      |   | O: 10 | TB    | O: 11 |   |\n|      |   | \\_\\_  |       |       |   |\n| \\_\\_ |   |       | TA    | TB    |   |\n|      |   |       | C     | O: 01 | D |\n|      |   |       | O: 00 | TB    |   |",
                    "rows": [
                        [
                            "",
                            "",
                            "",
                            "A",
                            "TA",
                            "B"
                        ],
                        [
                            "",
                            "",
                            "O: 10",
                            "TB",
                            "O: 11",
                            ""
                        ],
                        [
                            "",
                            "",
                            "__",
                            "",
                            "",
                            ""
                        ],
                        [
                            "__",
                            "",
                            "",
                            "TA",
                            "TB",
                            ""
                        ],
                        [
                            "",
                            "",
                            "",
                            "C",
                            "O: 01",
                            "D"
                        ],
                        [
                            "",
                            "",
                            "",
                            "O: 00",
                            "TB",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 451.99,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "(a) [3 points] There is one critical component of an FSM that is missing in this diagram. Please write what is missing in the answer box below.\n\nThe reset line or indication for initial state.\n\n(b) [2 points] Of the two FSM types, what type of an FSM is this?\n\nMoore\n\nFinal Exam                                                                           Page 10 of 40",
                    "md": "(a) [3 points] There is one critical component of an FSM that is missing in this diagram. Please write what is missing in the answer box below.\n\nThe reset line or indication for initial state.\n\n(b) [2 points] Of the two FSM types, what type of an FSM is this?\n\nMoore\n\nFinal Exam                                                                           Page 10 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 67.62,
                        "w": 451.87,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 12,
            "text": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018\n    (c) [5 points] List one major advantage of each type of state encoding below.\n    One-hot encoding           reduces next-state logic\n    Binary encoding        reduces FFs to hold state\n    Output encoding        reduces the output logic\n(d) [10 points] Fully describe the FSM with equations given that the states are encoded with one-hot\n    encoding.  Assign state encodings such that numerical values of states increase monotonically for\n    states A through D while using the minimum possible number of bits to represent the states with\n    one-hot encoding. Indicate the values you assign to each state and simplify all equations:\n   State assignments: A: 0001, B: 0010, C: 0100, D: 1000\n   NS[3] = TB * TS[3] + TS[2]\n   NS[2] = TB * TS[0] + T A * TS[1]\n   NS[1] = T B * (TS[0] + TS[3])\n   NS[0] = TS[1] * TA\n   O[1] = TS[0] + TS[1]\n   O[0] = TS[1] + TS[2]\nFinal Exam                                                                               Page 11 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\nAugust 18th, 2018\n\n# (c) [5 points]\n\nList one major advantage of each type of state encoding below.\n\n- One-hot encoding: reduces next-state logic\n- Binary encoding: reduces FFs to hold state\n- Output encoding: reduces the output logic\n\n# (d) [10 points]\n\nFully describe the FSM with equations given that the states are encoded with one-hot encoding. Assign state encodings such that numerical values of states increase monotonically for states A through D while using the minimum possible number of bits to represent the states with one-hot encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments:\n\n- A: 0001\n- B: 0010\n- C: 0100\n- D: 1000\n\nEquations:\n\n- NS[3] = TB * TS[3] + TS[2]\n- NS[2] = TB * TS[0] + TA * TS[1]\n- NS[1] = TB * (TS[0] + TS[3])\n- NS[0] = TS[1] * TA\n- O[1] = TS[0] + TS[1]\n- O[0] = TS[1] + TS[2]\n\nFinal Exam Page 11 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "August 18th, 2018",
                    "md": "August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [5 points]",
                    "md": "# (c) [5 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "List one major advantage of each type of state encoding below.\n\n- One-hot encoding: reduces next-state logic\n- Binary encoding: reduces FFs to hold state\n- Output encoding: reduces the output logic",
                    "md": "List one major advantage of each type of state encoding below.\n\n- One-hot encoding: reduces next-state logic\n- Binary encoding: reduces FFs to hold state\n- Output encoding: reduces the output logic",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 95.28,
                        "w": 209.08,
                        "h": 75.58
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) [10 points]",
                    "md": "# (d) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Fully describe the FSM with equations given that the states are encoded with one-hot encoding. Assign state encodings such that numerical values of states increase monotonically for states A through D while using the minimum possible number of bits to represent the states with one-hot encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments:\n\n- A: 0001\n- B: 0010\n- C: 0100\n- D: 1000\n\nEquations:\n\n- NS[3] = TB * TS[3] + TS[2]\n- NS[2] = TB * TS[0] + TA * TS[1]\n- NS[1] = TB * (TS[0] + TS[3])\n- NS[0] = TS[1] * TA\n- O[1] = TS[0] + TS[1]\n- O[0] = TS[1] + TS[2]\n\nFinal Exam Page 11 of 40",
                    "md": "Fully describe the FSM with equations given that the states are encoded with one-hot encoding. Assign state encodings such that numerical values of states increase monotonically for states A through D while using the minimum possible number of bits to represent the states with one-hot encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments:\n\n- A: 0001\n- B: 0010\n- C: 0100\n- D: 1000\n\nEquations:\n\n- NS[3] = TB * TS[3] + TS[2]\n- NS[2] = TB * TS[0] + TA * TS[1]\n- NS[1] = TB * (TS[0] + TS[3])\n- NS[0] = TS[1] * TA\n- O[1] = TS[0] + TS[1]\n- O[0] = TS[1] + TS[2]\n\nFinal Exam Page 11 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 95.31,
                        "w": 451.35,
                        "h": 699.36
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 13,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n(e) [10 points] Fully describe the FSM with equations given that the states are encoded with binary\n    encoding.  Assign state encodings such that numerical values of states increase monotonically for\n    states A through D while using the minimum possible number of bits to represent the states with\n    binary encoding. Indicate the values you assign to each state and simplify all equations:\n   State assignments: A: 00, B: 01, C: 10, D: 11\n   NS[1] = T S[1] * (T S[0] * TB + TS[0] T A) + TS[1] * (T S[0] + TS[0] * TB)\n   NS[0] = T S[1] * T S[0] * T B + TS[1]\n   O[1] = TS[1]\n   O[0] = TS[1] XOR TS[0]\n(f) [10 points] Fully describe the FSM with equations given that the states are encoded with output\n    encoding. Use the minimum possible number of bits to represent the states with output encoding.\n    Indicate the values you assign to each state and simplify all equations:\n   State assignments: A: 10, B: 11, C: 01, D: 00\n   NS[1] = TS[1] * T S[0] * T B + TS[1] * TS[0] * TA + T S[1] * T S[0] * T B\n   = T S[0] * T B + TS[1] * TS[0] * TA\n   NS[0] = TS[1] * T S[0] + TS[1] * TS[0] * T A + T S[1] * T S[0] * T B\n   = TS[1] * (T S[0] + TS[0] * T A) + T S[1] * T S[0] * T B\n   O[1] = TS[1]\n   O[0] = TS[0]\nFinal Exam                                                                             Page 12 of 40",
            "md": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n\n# (e) [10 points]\n\nFully describe the FSM with equations given that the states are encoded with binary encoding. Assign state encodings such that numerical values of states increase monotonically for states A through D while using the minimum possible number of bits to represent the states with binary encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments: A: 00, B: 01, C: 10, D: 11\n\nNS[1] = T S[1] * (T S[0] * TB + TS[0] T A) + TS[1] * (T S[0] + TS[0] * TB)\n\nNS[0] = T S[1] * T S[0] * T B + TS[1]\n\nO[1] = TS[1]\n\nO[0] = TS[1] XOR TS[0]\n\n# (f) [10 points]\n\nFully describe the FSM with equations given that the states are encoded with output encoding. Use the minimum possible number of bits to represent the states with output encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments: A: 10, B: 11, C: 01, D: 00\n\nNS[1] = TS[1] * T S[0] * T B + TS[1] * TS[0] * TA + T S[1] * T S[0] * T B\n\n= T S[0] * T B + TS[1] * TS[0] * TA\n\nNS[0] = TS[1] * T S[0] + TS[1] * TS[0] * T A + T S[1] * T S[0] * T B\n\n= TS[1] * (T S[0] + TS[0] * T A) + T S[1] * T S[0] * T B\n\nO[1] = TS[1]\n\nO[0] = TS[0]\n\nFinal Exam                                                                             Page 12 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018",
                    "md": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(e) [10 points]",
                    "md": "# (e) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Fully describe the FSM with equations given that the states are encoded with binary encoding. Assign state encodings such that numerical values of states increase monotonically for states A through D while using the minimum possible number of bits to represent the states with binary encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments: A: 00, B: 01, C: 10, D: 11\n\nNS[1] = T S[1] * (T S[0] * TB + TS[0] T A) + TS[1] * (T S[0] + TS[0] * TB)\n\nNS[0] = T S[1] * T S[0] * T B + TS[1]\n\nO[1] = TS[1]\n\nO[0] = TS[1] XOR TS[0]",
                    "md": "Fully describe the FSM with equations given that the states are encoded with binary encoding. Assign state encodings such that numerical values of states increase monotonically for states A through D while using the minimum possible number of bits to represent the states with binary encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments: A: 00, B: 01, C: 10, D: 11\n\nNS[1] = T S[1] * (T S[0] * TB + TS[0] T A) + TS[1] * (T S[0] + TS[0] * TB)\n\nNS[0] = T S[1] * T S[0] * T B + TS[1]\n\nO[1] = TS[1]\n\nO[0] = TS[1] XOR TS[0]",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 83.96,
                        "w": 436.87,
                        "h": 438.67
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(f) [10 points]",
                    "md": "# (f) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Fully describe the FSM with equations given that the states are encoded with output encoding. Use the minimum possible number of bits to represent the states with output encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments: A: 10, B: 11, C: 01, D: 00\n\nNS[1] = TS[1] * T S[0] * T B + TS[1] * TS[0] * TA + T S[1] * T S[0] * T B\n\n= T S[0] * T B + TS[1] * TS[0] * TA\n\nNS[0] = TS[1] * T S[0] + TS[1] * TS[0] * T A + T S[1] * T S[0] * T B\n\n= TS[1] * (T S[0] + TS[0] * T A) + T S[1] * T S[0] * T B\n\nO[1] = TS[1]\n\nO[0] = TS[0]\n\nFinal Exam                                                                             Page 12 of 40",
                    "md": "Fully describe the FSM with equations given that the states are encoded with output encoding. Use the minimum possible number of bits to represent the states with output encoding. Indicate the values you assign to each state and simplify all equations:\n\nState assignments: A: 10, B: 11, C: 01, D: 00\n\nNS[1] = TS[1] * T S[0] * T B + TS[1] * TS[0] * TA + T S[1] * T S[0] * T B\n\n= T S[0] * T B + TS[1] * TS[0] * TA\n\nNS[0] = TS[1] * T S[0] + TS[1] * TS[0] * T A + T S[1] * T S[0] * T B\n\n= TS[1] * (T S[0] + TS[0] * T A) + T S[1] * T S[0] * T B\n\nO[1] = TS[1]\n\nO[0] = TS[0]\n\nFinal Exam                                                                             Page 12 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 83.96,
                        "w": 451.32,
                        "h": 710.71
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 14,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n(g) [10 points] Assume the following conditions:\n     \u2022 We can only implement our FSM with 2-input AND gates, 2-input OR gates, and D flip-flops.\n     \u2022  2-input AND gates and 2-input OR gates occupy the same area.\n     \u2022  D flip-flops occupy 3x the area of 2-input AND gates.\n    Which state encoding do you choose to implement in order to minimize the total area       of this\n    FSM?\n   one-hot: 10 logics 4 FFs binary: 16 logics. 2 FFs output: 10 logics. 2 FFs\n   Output encoding has the least amount of circuitry elements.\nFinal Exam                                                                             Page 13 of 40",
            "md": "Initials: Solutions\n\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n(g) [10 points] Assume the following conditions:\n\n- We can only implement our FSM with 2-input AND gates, 2-input OR gates, and D flip-flops.\n- 2-input AND gates and 2-input OR gates occupy the same area.\n- D flip-flops occupy 3x the area of 2-input AND gates.\n\nWhich state encoding do you choose to implement in order to minimize the total area of this FSM?\n\n| one-hot | 10 logics | 4 FFs |\n| ------- | --------- | ----- |\n| binary  | 16 logics | 2 FFs |\n| output  | 10 logics | 2 FFs |\n\nOutput encoding has the least amount of circuitry elements.\n\nFinal Exam",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "(g) [10 points] Assume the following conditions:\n\n- We can only implement our FSM with 2-input AND gates, 2-input OR gates, and D flip-flops.\n- 2-input AND gates and 2-input OR gates occupy the same area.\n- D flip-flops occupy 3x the area of 2-input AND gates.\n\nWhich state encoding do you choose to implement in order to minimize the total area of this FSM?",
                    "md": "(g) [10 points] Assume the following conditions:\n\n- We can only implement our FSM with 2-input AND gates, 2-input OR gates, and D flip-flops.\n- 2-input AND gates and 2-input OR gates occupy the same area.\n- D flip-flops occupy 3x the area of 2-input AND gates.\n\nWhich state encoding do you choose to implement in order to minimize the total area of this FSM?",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 72.0,
                        "w": 451.17,
                        "h": 89.7
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| one-hot | 10 logics | 4 FFs |\n| ------- | --------- | ----- |\n| binary  | 16 logics | 2 FFs |\n| output  | 10 logics | 2 FFs |",
                    "rows": [
                        [
                            "one-hot",
                            "10 logics",
                            "4 FFs"
                        ],
                        [
                            "binary",
                            "16 logics",
                            "2 FFs"
                        ],
                        [
                            "output",
                            "10 logics",
                            "2 FFs"
                        ]
                    ],
                    "bBox": {
                        "x": 86.48,
                        "y": 167.64,
                        "w": 320.37,
                        "h": 21.96
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Output encoding has the least amount of circuitry elements.\n\nFinal Exam",
                    "md": "Output encoding has the least amount of circuitry elements.\n\nFinal Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 179.6,
                        "w": 277.64,
                        "h": 615.07
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 15,
            "text": "Initials: Solutions                Design of Digital Circuits                August 18th, 2018\n5    ISA and Microarchitecture               [45 points]\nYou are asked to complete the following program written in MIPS assembly with a sequence of MIPS\ninstructions that perform 64-bit integer subtraction (A - B). The 64-bit integer to be subtracted\nfrom (A) is loaded into registers $4 and $5. Similarly, the 64-bit integer to subtract (B) is loaded into\nregisters $6 and $7. Both numbers are in two\u2019s complement form. The upper 32-bit part of each number\nis stored in the corresponding even-numbered register.\nLoop:    lw   $4, 0($1)\n         lw   $5, 4($1)\n         lw   $6, 8($1)\n         lw   $7, 12($1)\n         # 64-bit subtraction\n         # goes here\n         addi   $1, $1, 16\n         j  Loop\n(a) [15 points] Complete the above program to perform the 64-bit subtraction explained above using\n    at most 4 MIPS instructions. (Note: A summary of the MIPS ISA is provided at the end of this\n    question.)\n   A possible sequence of instructions is as follows:\n   subu $3, $5, $7 # Subtract the least significant part\n   sltu $2, $5, $7 # Check if borrowing is needed\n   add $2, $6, $2 # Add borrow\n   sub $2, $4, $2 # Subtract the most significant part\nFinal Exam                                                                        Page 14 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# 5 ISA and Microarchitecture\n\n[45 points]\n\nYou are asked to complete the following program written in MIPS assembly with a sequence of MIPS instructions that perform 64-bit integer subtraction (A - B). The 64-bit integer to be subtracted from (A) is loaded into registers $4 and $5. Similarly, the 64-bit integer to subtract (B) is loaded into registers $6 and $7. Both numbers are in two\u2019s complement form. The upper 32-bit part of each number is stored in the corresponding even-numbered register.\n\nLoop:    lw   $4, 0($1)\nlw   $5, 4($1)\nlw   $6, 8($1)\nlw   $7, 12($1)\n# 64-bit subtraction\n# goes here\naddi   $1, $1, 16\nj  Loop\n\n# (a) [15 points]\n\nComplete the above program to perform the 64-bit subtraction explained above using at most 4 MIPS instructions. (Note: A summary of the MIPS ISA is provided at the end of this question.)\n\nA possible sequence of instructions is as follows:\n\nsubu $3, $5, $7 # Subtract the least significant part\nsltu $2, $5, $7 # Check if borrowing is needed\nadd $2, $6, $2 # Add borrow\nsub $2, $4, $2 # Subtract the most significant part\n\n# Final Exam\n\nPage 14 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "5 ISA and Microarchitecture",
                    "md": "# 5 ISA and Microarchitecture",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 209.09,
                        "h": 14.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "[45 points]\n\nYou are asked to complete the following program written in MIPS assembly with a sequence of MIPS instructions that perform 64-bit integer subtraction (A - B). The 64-bit integer to be subtracted from (A) is loaded into registers $4 and $5. Similarly, the 64-bit integer to subtract (B) is loaded into registers $6 and $7. Both numbers are in two\u2019s complement form. The upper 32-bit part of each number is stored in the corresponding even-numbered register.\n\nLoop:    lw   $4, 0($1)\nlw   $5, 4($1)\nlw   $6, 8($1)\nlw   $7, 12($1)",
                    "md": "[45 points]\n\nYou are asked to complete the following program written in MIPS assembly with a sequence of MIPS instructions that perform 64-bit integer subtraction (A - B). The 64-bit integer to be subtracted from (A) is loaded into registers $4 and $5. Similarly, the 64-bit integer to subtract (B) is loaded into registers $6 and $7. Both numbers are in two\u2019s complement form. The upper 32-bit part of each number is stored in the corresponding even-numbered register.\n\nLoop:    lw   $4, 0($1)\nlw   $5, 4($1)\nlw   $6, 8($1)\nlw   $7, 12($1)",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.4,
                        "h": 213.54
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "64-bit subtraction",
                    "md": "# 64-bit subtraction",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "goes here",
                    "md": "# goes here",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "addi   $1, $1, 16\nj  Loop",
                    "md": "addi   $1, $1, 16\nj  Loop",
                    "rows": null,
                    "bBox": {
                        "x": 113.84,
                        "y": 259.2,
                        "w": 95.69,
                        "h": 21.96
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [15 points]",
                    "md": "# (a) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 8.0,
                        "h": 14.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Complete the above program to perform the 64-bit subtraction explained above using at most 4 MIPS instructions. (Note: A summary of the MIPS ISA is provided at the end of this question.)\n\nA possible sequence of instructions is as follows:\n\nsubu $3, $5, $7 # Subtract the least significant part\nsltu $2, $5, $7 # Check if borrowing is needed\nadd $2, $6, $2 # Add borrow\nsub $2, $4, $2 # Subtract the most significant part",
                    "md": "Complete the above program to perform the 64-bit subtraction explained above using at most 4 MIPS instructions. (Note: A summary of the MIPS ISA is provided at the end of this question.)\n\nA possible sequence of instructions is as follows:\n\nsubu $3, $5, $7 # Subtract the least significant part\nsltu $2, $5, $7 # Check if borrowing is needed\nadd $2, $6, $2 # Add borrow\nsub $2, $4, $2 # Subtract the most significant part",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.75,
                        "h": 332.88
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Final Exam",
                    "md": "# Final Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 784.67,
                        "w": 50.87,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 14 of 40",
                    "md": "Page 14 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 464.48,
                        "y": 784.67,
                        "w": 58.83,
                        "h": 10.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 16,
            "text": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018\n(b) [15 points] Assume that the program executes on a pipelined processor, which does not implement\n    interlocking in hardware. The pipeline assumes that all instructions are independent and relies on\n    the compiler to properly order instructions such that there is sufficient distance between dependent\n    instructions. The compiler either moves other independent instructions between two dependent\n    instructions, if it can find such instructions, or otherwise, inserts nops. There is no internal register\n    file forwarding (i.e., if an instruction writes into a register, another instruction cannot access the new\n    value of the register until the next cycle). The pipeline does not implement any data forwarding.\n    The datapath has the following five pipeline stages, similarly to the basic pipelined MIPS processor\n    we discussed in lecture. Registers are accessed in the Decode stage. The execution stage contains\n    one ALU.\n     (a) Fetch (one clock cycle)\n     (b) Decode (one clock cycle)\n     (c) Execute (one clock cycle)\n     (d) Memory (one clock cycle)\n     (e) Write-back (one clock cycle).\n    Reorder the existing instructions and insert as few as possible nop instructions to correctly execute\n    the entire program that you completed in part (a) on the given pipelined processor.  Show all the\n    instructions necessary to correctly execute the entire program.\n   We reoder the lw    instructions to first load the data that corresponds to the lower parts of the\n   two numbers since we need the lower part first.       We also reorder the completely independent\n   addi instruction to hide part of the load latency.  We insert sufficient number of nop instructions\n   until the register is written before the dependent instruction reads the same register in the decode stage.\n   This is the resulting code:\n     Loop:    lw $5, 4($1)\n              lw $7, 12($1)\n              lw $4, 0($1)\n              lw $6, 8($1)\n              addi $1, $1, 16\n              sltu $2, $5, $7\n              subu $3, $5, $7\n              nop\n              nop\n              add $2, $6, $2\n              nop\n              nop\n              nop\n              sub $2, $4, $2\n              j Loop\nFinal Exam                                                                               Page 15 of 40",
            "md": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018\n\n# (b) [15 points]\n\nAssume that the program executes on a pipelined processor, which does not implement interlocking in hardware. The pipeline assumes that all instructions are independent and relies on the compiler to properly order instructions such that there is sufficient distance between dependent instructions. The compiler either moves other independent instructions between two dependent instructions, if it can find such instructions, or otherwise, inserts nops. There is no internal register file forwarding (i.e., if an instruction writes into a register, another instruction cannot access the new value of the register until the next cycle). The pipeline does not implement any data forwarding.\n\nThe datapath has the following five pipeline stages, similarly to the basic pipelined MIPS processor we discussed in lecture. Registers are accessed in the Decode stage. The execution stage contains one ALU.\n\n- (a) Fetch (one clock cycle)\n- (b) Decode (one clock cycle)\n- (c) Execute (one clock cycle)\n- (d) Memory (one clock cycle)\n- (e) Write-back (one clock cycle)\n\nReorder the existing instructions and insert as few as possible nop instructions to correctly execute the entire program that you completed in part (a) on the given pipelined processor. Show all the instructions necessary to correctly execute the entire program.\n\nWe reorder the lw instructions to first load the data that corresponds to the lower parts of the two numbers since we need the lower part first. We also reorder the completely independent addi instruction to hide part of the load latency. We insert sufficient number of nop instructions until the register is written before the dependent instruction reads the same register in the decode stage. This is the resulting code:\n\nLoop:    lw $5, 4($1)\nlw $7, 12($1)\nlw $4, 0($1)\nlw $6, 8($1)\naddi $1, $1, 16\nsltu $2, $5, $7\nsubu $3, $5, $7\nnop\nnop\nadd $2, $6, $2\nnop\nnop\nnop\nsub $2, $4, $2\nj Loop\n\nFinal Exam                                                                               Page 15 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018",
                    "md": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [15 points]",
                    "md": "# (b) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Assume that the program executes on a pipelined processor, which does not implement interlocking in hardware. The pipeline assumes that all instructions are independent and relies on the compiler to properly order instructions such that there is sufficient distance between dependent instructions. The compiler either moves other independent instructions between two dependent instructions, if it can find such instructions, or otherwise, inserts nops. There is no internal register file forwarding (i.e., if an instruction writes into a register, another instruction cannot access the new value of the register until the next cycle). The pipeline does not implement any data forwarding.\n\nThe datapath has the following five pipeline stages, similarly to the basic pipelined MIPS processor we discussed in lecture. Registers are accessed in the Decode stage. The execution stage contains one ALU.\n\n- (a) Fetch (one clock cycle)\n- (b) Decode (one clock cycle)\n- (c) Execute (one clock cycle)\n- (d) Memory (one clock cycle)\n- (e) Write-back (one clock cycle)\n\nReorder the existing instructions and insert as few as possible nop instructions to correctly execute the entire program that you completed in part (a) on the given pipelined processor. Show all the instructions necessary to correctly execute the entire program.\n\nWe reorder the lw instructions to first load the data that corresponds to the lower parts of the two numbers since we need the lower part first. We also reorder the completely independent addi instruction to hide part of the load latency. We insert sufficient number of nop instructions until the register is written before the dependent instruction reads the same register in the decode stage. This is the resulting code:\n\nLoop:    lw $5, 4($1)\nlw $7, 12($1)\nlw $4, 0($1)\nlw $6, 8($1)\naddi $1, $1, 16\nsltu $2, $5, $7\nsubu $3, $5, $7\nnop\nnop\nadd $2, $6, $2\nnop\nnop\nnop\nsub $2, $4, $2\nj Loop\n\nFinal Exam                                                                               Page 15 of 40",
                    "md": "Assume that the program executes on a pipelined processor, which does not implement interlocking in hardware. The pipeline assumes that all instructions are independent and relies on the compiler to properly order instructions such that there is sufficient distance between dependent instructions. The compiler either moves other independent instructions between two dependent instructions, if it can find such instructions, or otherwise, inserts nops. There is no internal register file forwarding (i.e., if an instruction writes into a register, another instruction cannot access the new value of the register until the next cycle). The pipeline does not implement any data forwarding.\n\nThe datapath has the following five pipeline stages, similarly to the basic pipelined MIPS processor we discussed in lecture. Registers are accessed in the Decode stage. The execution stage contains one ALU.\n\n- (a) Fetch (one clock cycle)\n- (b) Decode (one clock cycle)\n- (c) Execute (one clock cycle)\n- (d) Memory (one clock cycle)\n- (e) Write-back (one clock cycle)\n\nReorder the existing instructions and insert as few as possible nop instructions to correctly execute the entire program that you completed in part (a) on the given pipelined processor. Show all the instructions necessary to correctly execute the entire program.\n\nWe reorder the lw instructions to first load the data that corresponds to the lower parts of the two numbers since we need the lower part first. We also reorder the completely independent addi instruction to hide part of the load latency. We insert sufficient number of nop instructions until the register is written before the dependent instruction reads the same register in the decode stage. This is the resulting code:\n\nLoop:    lw $5, 4($1)\nlw $7, 12($1)\nlw $4, 0($1)\nlw $6, 8($1)\naddi $1, $1, 16\nsltu $2, $5, $7\nsubu $3, $5, $7\nnop\nnop\nadd $2, $6, $2\nnop\nnop\nnop\nsub $2, $4, $2\nj Loop\n\nFinal Exam                                                                               Page 15 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 83.96,
                        "w": 456.89,
                        "h": 710.71
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 17,
            "text": "Initials: Solutions                    Design of Digital Circuits                     August 18th, 2018\n(c) [5 points] What is the Cycles Per Instruction (CPI) of the program when executed on the pipelined\n    processor provided in part (b)?\n   CP I \u2248 1.5\n   Explanation.\n   Since the code is an infinite loop, the number of cycles to fill the pipeline becomes negligible after a\n   large number of iterations. Thus, we can consider that the throughput is one instruction every cycle.\n   We count the number of cycles for one loop iteration.        It is 15 for 10 instructions.   This way,\n   CP I \u2248 15 = 1.5.\n            ~~10~~  \n(d) [10 points] Now, assume a processor with a multi-cycle datapath. In this multi-cycle datapath, each\n    instruction type is executed in the following number of cycles: 4 cycles for R-type, 5 cycles for load,\n    4 cycles for store, and 3 cycles for jump. What is the CPI of the program in part (a) when executed\n    on this multi-cycle datapath? Assuming the multi-cycle datapath runs at the same clock frequency\n    as the pipelined datapath in part (b), how much speedup does pipelining provide?\n                    CP I = 4.3\n                    Explanation.\n    CPI:            For the multi-cycle datapath, we have to take into account the number of cycles\n                    for each instruction type: 4 cycles for R-type, 5 cycles for load, 4 cycles for store,\n                    and 3 cycles for jump.\n                    Thus, CP I = 4\u00d75+5\u00d74+3\u00d71 = 4.3.\n                                       10\n                   Pipelining provides 287% speedup.\n    Speedup:       Explanation.\n                   We calculate the speedup as follows:\n                   Speedup = CP I\u1d50\u1d58\u02e1\u1d57\u2071\u2212\u1d9c\u02b8\u1d9c\u02e1\u1d49 =  4.3 = 2.87.\n                                CP Ipipelined   1.5\nFinal Exam                                                                                 Page 16 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (c) [5 points]\n\nWhat is the Cycles Per Instruction (CPI) of the program when executed on the pipelined processor provided in part (b)?\n\nCPI \u2248 1.5\n\n# Explanation.\n\nSince the code is an infinite loop, the number of cycles to fill the pipeline becomes negligible after a large number of iterations. Thus, we can consider that the throughput is one instruction every cycle. We count the number of cycles for one loop iteration. It is 15 for 10 instructions. This way, CPI \u2248 15 = 1.5.\n\n# (d) [10 points]\n\nNow, assume a processor with a multi-cycle datapath. In this multi-cycle datapath, each instruction type is executed in the following number of cycles: 4 cycles for R-type, 5 cycles for load, 4 cycles for store, and 3 cycles for jump. What is the CPI of the program in part (a) when executed on this multi-cycle datapath? Assuming the multi-cycle datapath runs at the same clock frequency as the pipelined datapath in part (b), how much speedup does pipelining provide?\n\nCPI = 4.3\n\n# Explanation.\n\nCPI: For the multi-cycle datapath, we have to take into account the number of cycles for each instruction type: 4 cycles for R-type, 5 cycles for load, 4 cycles for store, and 3 cycles for jump. Thus, CPI = 4\u00d75 + 5\u00d74 + 3\u00d71 = 4.3.\n\nPipelining provides 287% speedup.\n\n# Speedup:\n\nExplanation. We calculate the speedup as follows:\n\nSpeedup = CPImulti-cycle = 4.3 = 2.87.\n\nCPIpipelined 1.5\n\nFinal Exam Page 16 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [5 points]",
                    "md": "# (c) [5 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What is the Cycles Per Instruction (CPI) of the program when executed on the pipelined processor provided in part (b)?\n\nCPI \u2248 1.5",
                    "md": "What is the Cycles Per Instruction (CPI) of the program when executed on the pipelined processor provided in part (b)?\n\nCPI \u2248 1.5",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 83.96,
                        "w": 200.61,
                        "h": 618.05
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Explanation.",
                    "md": "# Explanation.",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 125.53,
                        "w": 131.89,
                        "h": 549.14
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Since the code is an infinite loop, the number of cycles to fill the pipeline becomes negligible after a large number of iterations. Thus, we can consider that the throughput is one instruction every cycle. We count the number of cycles for one loop iteration. It is 15 for 10 instructions. This way, CPI \u2248 15 = 1.5.",
                    "md": "Since the code is an infinite loop, the number of cycles to fill the pipeline becomes negligible after a large number of iterations. Thus, we can consider that the throughput is one instruction every cycle. We count the number of cycles for one loop iteration. It is 15 for 10 instructions. This way, CPI \u2248 15 = 1.5.",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 137.49,
                        "w": 442.44,
                        "h": 564.52
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) [10 points]",
                    "md": "# (d) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 241.01,
                        "y": 556.17,
                        "w": 8.0,
                        "h": 7.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Now, assume a processor with a multi-cycle datapath. In this multi-cycle datapath, each instruction type is executed in the following number of cycles: 4 cycles for R-type, 5 cycles for load, 4 cycles for store, and 3 cycles for jump. What is the CPI of the program in part (a) when executed on this multi-cycle datapath? Assuming the multi-cycle datapath runs at the same clock frequency as the pipelined datapath in part (b), how much speedup does pipelining provide?\n\nCPI = 4.3",
                    "md": "Now, assume a processor with a multi-cycle datapath. In this multi-cycle datapath, each instruction type is executed in the following number of cycles: 4 cycles for R-type, 5 cycles for load, 4 cycles for store, and 3 cycles for jump. What is the CPI of the program in part (a) when executed on this multi-cycle datapath? Assuming the multi-cycle datapath runs at the same clock frequency as the pipelined datapath in part (b), how much speedup does pipelining provide?\n\nCPI = 4.3",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 400.0,
                        "w": 433.76,
                        "h": 147.78
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Explanation.",
                    "md": "# Explanation.",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 125.53,
                        "w": 131.89,
                        "h": 549.14
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "CPI: For the multi-cycle datapath, we have to take into account the number of cycles for each instruction type: 4 cycles for R-type, 5 cycles for load, 4 cycles for store, and 3 cycles for jump. Thus, CPI = 4\u00d75 + 5\u00d74 + 3\u00d71 = 4.3.\n\nPipelining provides 287% speedup.",
                    "md": "CPI: For the multi-cycle datapath, we have to take into account the number of cycles for each instruction type: 4 cycles for R-type, 5 cycles for load, 4 cycles for store, and 3 cycles for jump. Thus, CPI = 4\u00d75 + 5\u00d74 + 3\u00d71 = 4.3.\n\nPipelining provides 287% speedup.",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 513.88,
                        "w": 414.27,
                        "h": 136.88
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Speedup:",
                    "md": "# Speedup:",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 666.16,
                        "w": 40.0,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Explanation. We calculate the speedup as follows:\n\nSpeedup = CPImulti-cycle = 4.3 = 2.87.\n\nCPIpipelined 1.5\n\nFinal Exam Page 16 of 40",
                    "md": "Explanation. We calculate the speedup as follows:\n\nSpeedup = CPImulti-cycle = 4.3 = 2.87.\n\nCPIpipelined 1.5\n\nFinal Exam Page 16 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 125.53,
                        "w": 451.32,
                        "h": 669.14
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 18,
            "text": "Initials: Solutions           Design of Digital Circuits      August 18th, 2018\nMIPS Instruction Summary\n  Opcode                      Example Assembly   Semantics\n  add                         add $1, $2, $3     $1 = $2 + $3\n  sub                         sub $1, $2, $3     $1 = $2 - $3\n  add immediate               addi $1, $2, 100   $1 = $2 + 100\n  add unsigned                addu $1, $2, $3    $1 = $2 + $3\n  subtract unsigned           subu $1, $2, $3    $1 = $2 - $3\n  add immediate unsigned      addiu $1, $2, 100  $1 = $2 + 100\n  multiply                    mult $2, $3        hi, lo = $2 * $3\n  multiply unsigned           multu $2, $3       hi, lo = $2 * $3\n  divide                      div $2, $3         lo = $2/$3, hi = $2 mod $3\n  divide unsigned             divu $2, $3        lo = $2/$3, hi = $2 mod $3\n  move from hi                mfhi $1            $1 = hi\n  move from low               mflo $1            $1 = lo\n  and                         and $1, $2, $3     $1 = $2 & $3\n  or                          or $1, $2, $3      $1 = $2 | $3\n  and immediate               andi $1, $2, 100   $1 = $2 & 100\n  or immediate                ori $1, $2, 100    $1 = $2 | 100\n  shift left logical          sll $1, $2, 10     $1 = $2 \u00ab 10\n  shift right logical         srl $1, $2, 10     $1 = $2 \u00bb 10\n  load word                   lw $1, 100($2)     $1 = memory[$2 + 100]\n  store word                  sw $1, 100($2)     memory[$2 + 100] = $1\n  load upper immediate        lui $1, 100        $1 = 100 \u00ab 16\n  branch on equal             beq $1, $2, label  if ($1 == $2) goto label\n  branch on not equal         bne $1, $2, label  if ($1 != $2) goto label\n  set on less than            slt $1, $2, $3     if ($2 < $3) $1 = 1 else $1 = 0\n  set on less than immediate  slti $1, $2, 100   if ($2 < 100) $1 = 1 else $1 = 0\n  set on less than unsigned   sltu $1, $2, $3    if ($2 < $3) $1 = 1 else $1 = 0\n  set on less than immediate  sltui $1, $2, 100  if ($2 < 100) $1 = 1 else $1 = 0\n  jump                        j label            goto label\n  jump register               jr $31             goto $31\n  jump and link               jal label          $31 = PC + 4; goto label\nFinal Exam                                                       Page 17 of 40",
            "md": "Initials: Solutions           Design of Digital Circuits      August 18th, 2018\n# MIPS Instruction Summary\n\n| Opcode                     | Example Assembly  | Semantics                        | |\n| -------------------------- | ----------------- | -------------------------------- |---|\n| add                        | add $1, $2, $3    | $1 = $2 + $3                     | |\n| sub                        | sub $1, $2, $3    | $1 = $2 - $3                     | |\n| add immediate              | addi $1, $2, 100  | $1 = $2 + 100                    | |\n| add unsigned               | addu $1, $2, $3   | $1 = $2 + $3                     | |\n| subtract unsigned          | subu $1, $2, $3   | $1 = $2 - $3                     | |\n| add immediate unsigned     | addiu $1, $2, 100 | $1 = $2 + 100                    | |\n| multiply                   | mult $2, $3       | hi, lo = $2 \\* $3                | |\n| multiply unsigned          | multu $2, $3      | hi, lo = $2 \\* $3                | |\n| divide                     | div $2, $3        | lo = $2/$3, hi = $2 mod $3       | |\n| divide unsigned            | divu $2, $3       | lo = $2/$3, hi = $2 mod $3       | |\n| move from hi               | mfhi $1           | $1 = hi                          | |\n| move from low              | mflo $1           | $1 = lo                          | |\n| and                        | and $1, $2, $3    | $1 = $2 & $3                     | |\n| or                         | or $1, $2, $3     | $1 = $2 \\| $3                    |\n| and immediate              | andi $1, $2, 100  | $1 = $2 & 100                    | |\n| or immediate               | ori $1, $2, 100   | $1 = $2 \\| 100                   |\n| shift left logical         | sll $1, $2, 10    | $1 = $2 \u00ab 10                     | |\n| shift right logical        | srl $1, $2, 10    | $1 = $2 \u00bb 10                     | |\n| load word                  | lw $1, 100($2)    | $1 = memory\\[$2 + 100]           | |\n| store word                 | sw $1, 100($2)    | memory\\[$2 + 100] = $1           | |\n| load upper immediate       | lui $1, 100       | $1 = 100 \u00ab 16                    | |\n| branch on equal            | beq $1, $2, label | if ($1 == $2) goto label         | |\n| branch on not equal        | bne $1, $2, label | if ($1 != $2) goto label         | |\n| set on less than           | slt $1, $2, $3    | if ($2 < $3) $1 = 1 else $1 = 0  | |\n| set on less than immediate | slti $1, $2, 100  | if ($2 < 100) $1 = 1 else $1 = 0 | |\n| set on less than unsigned  | sltu $1, $2, $3   | if ($2 < $3) $1 = 1 else $1 = 0  | |\n| set on less than immediate | sltui $1, $2, 100 | if ($2 < 100) $1 = 1 else $1 = 0 | |\n| jump                       | j label           | goto label                       | |\n| jump register              | jr $31            | goto $31                         | |\n| jump and link              | jal label         | $31 = PC + 4; goto label         | |\n\nFinal Exam                                                       Page 17 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions           Design of Digital Circuits      August 18th, 2018",
                    "md": "Initials: Solutions           Design of Digital Circuits      August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "MIPS Instruction Summary",
                    "md": "# MIPS Instruction Summary",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 193.12,
                        "h": 14.0
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Opcode                     | Example Assembly  | Semantics                        |   |\n| -------------------------- | ----------------- | -------------------------------- | - |\n| add                        | add $1, $2, $3    | $1 = $2 + $3                     |   |\n| sub                        | sub $1, $2, $3    | $1 = $2 - $3                     |   |\n| add immediate              | addi $1, $2, 100  | $1 = $2 + 100                    |   |\n| add unsigned               | addu $1, $2, $3   | $1 = $2 + $3                     |   |\n| subtract unsigned          | subu $1, $2, $3   | $1 = $2 - $3                     |   |\n| add immediate unsigned     | addiu $1, $2, 100 | $1 = $2 + 100                    |   |\n| multiply                   | mult $2, $3       | hi, lo = $2 \\* $3                |   |\n| multiply unsigned          | multu $2, $3      | hi, lo = $2 \\* $3                |   |\n| divide                     | div $2, $3        | lo = $2/$3, hi = $2 mod $3       |   |\n| divide unsigned            | divu $2, $3       | lo = $2/$3, hi = $2 mod $3       |   |\n| move from hi               | mfhi $1           | $1 = hi                          |   |\n| move from low              | mflo $1           | $1 = lo                          |   |\n| and                        | and $1, $2, $3    | $1 = $2 & $3                     |   |\n| or                         | or $1, $2, $3     | $1 = $2 \\| $3                    |   |\n| and immediate              | andi $1, $2, 100  | $1 = $2 & 100                    |   |\n| or immediate               | ori $1, $2, 100   | $1 = $2 \\| 100                   |   |\n| shift left logical         | sll $1, $2, 10    | $1 = $2 \u00ab 10                     |   |\n| shift right logical        | srl $1, $2, 10    | $1 = $2 \u00bb 10                     |   |\n| load word                  | lw $1, 100($2)    | $1 = memory\\[$2 + 100]           |   |\n| store word                 | sw $1, 100($2)    | memory\\[$2 + 100] = $1           |   |\n| load upper immediate       | lui $1, 100       | $1 = 100 \u00ab 16                    |   |\n| branch on equal            | beq $1, $2, label | if ($1 == $2) goto label         |   |\n| branch on not equal        | bne $1, $2, label | if ($1 != $2) goto label         |   |\n| set on less than           | slt $1, $2, $3    | if ($2 < $3) $1 = 1 else $1 = 0  |   |\n| set on less than immediate | slti $1, $2, 100  | if ($2 < 100) $1 = 1 else $1 = 0 |   |\n| set on less than unsigned  | sltu $1, $2, $3   | if ($2 < $3) $1 = 1 else $1 = 0  |   |\n| set on less than immediate | sltui $1, $2, 100 | if ($2 < 100) $1 = 1 else $1 = 0 |   |\n| jump                       | j label           | goto label                       |   |\n| jump register              | jr $31            | goto $31                         |   |\n| jump and link              | jal label         | $31 = PC + 4; goto label         |   |",
                    "rows": [
                        [
                            "Opcode",
                            "Example Assembly",
                            "Semantics",
                            ""
                        ],
                        [
                            "add",
                            "add $1, $2, $3",
                            "$1 = $2 + $3",
                            ""
                        ],
                        [
                            "sub",
                            "sub $1, $2, $3",
                            "$1 = $2 - $3",
                            ""
                        ],
                        [
                            "add immediate",
                            "addi $1, $2, 100",
                            "$1 = $2 + 100",
                            ""
                        ],
                        [
                            "add unsigned",
                            "addu $1, $2, $3",
                            "$1 = $2 + $3",
                            ""
                        ],
                        [
                            "subtract unsigned",
                            "subu $1, $2, $3",
                            "$1 = $2 - $3",
                            ""
                        ],
                        [
                            "add immediate unsigned",
                            "addiu $1, $2, 100",
                            "$1 = $2 + 100",
                            ""
                        ],
                        [
                            "multiply",
                            "mult $2, $3",
                            "hi, lo = $2 * $3",
                            ""
                        ],
                        [
                            "multiply unsigned",
                            "multu $2, $3",
                            "hi, lo = $2 * $3",
                            ""
                        ],
                        [
                            "divide",
                            "div $2, $3",
                            "lo = $2/$3, hi = $2 mod $3",
                            ""
                        ],
                        [
                            "divide unsigned",
                            "divu $2, $3",
                            "lo = $2/$3, hi = $2 mod $3",
                            ""
                        ],
                        [
                            "move from hi",
                            "mfhi $1",
                            "$1 = hi",
                            ""
                        ],
                        [
                            "move from low",
                            "mflo $1",
                            "$1 = lo",
                            ""
                        ],
                        [
                            "and",
                            "and $1, $2, $3",
                            "$1 = $2 & $3",
                            ""
                        ],
                        [
                            "or",
                            "or $1, $2, $3",
                            "$1 = $2 | $3",
                            ""
                        ],
                        [
                            "and immediate",
                            "andi $1, $2, 100",
                            "$1 = $2 & 100",
                            ""
                        ],
                        [
                            "or immediate",
                            "ori $1, $2, 100",
                            "$1 = $2 | 100",
                            ""
                        ],
                        [
                            "shift left logical",
                            "sll $1, $2, 10",
                            "$1 = $2 \u00ab 10",
                            ""
                        ],
                        [
                            "shift right logical",
                            "srl $1, $2, 10",
                            "$1 = $2 \u00bb 10",
                            ""
                        ],
                        [
                            "load word",
                            "lw $1, 100($2)",
                            "$1 = memory[$2 + 100]",
                            ""
                        ],
                        [
                            "store word",
                            "sw $1, 100($2)",
                            "memory[$2 + 100] = $1",
                            ""
                        ],
                        [
                            "load upper immediate",
                            "lui $1, 100",
                            "$1 = 100 \u00ab 16",
                            ""
                        ],
                        [
                            "branch on equal",
                            "beq $1, $2, label",
                            "if ($1 == $2) goto label",
                            ""
                        ],
                        [
                            "branch on not equal",
                            "bne $1, $2, label",
                            "if ($1 != $2) goto label",
                            ""
                        ],
                        [
                            "set on less than",
                            "slt $1, $2, $3",
                            "if ($2 < $3) $1 = 1 else $1 = 0",
                            ""
                        ],
                        [
                            "set on less than immediate",
                            "slti $1, $2, 100",
                            "if ($2 < 100) $1 = 1 else $1 = 0",
                            ""
                        ],
                        [
                            "set on less than unsigned",
                            "sltu $1, $2, $3",
                            "if ($2 < $3) $1 = 1 else $1 = 0",
                            ""
                        ],
                        [
                            "set on less than immediate",
                            "sltui $1, $2, 100",
                            "if ($2 < 100) $1 = 1 else $1 = 0",
                            ""
                        ],
                        [
                            "jump",
                            "j label",
                            "goto label",
                            ""
                        ],
                        [
                            "jump register",
                            "jr $31",
                            "goto $31",
                            ""
                        ],
                        [
                            "jump and link",
                            "jal label",
                            "$31 = PC + 4; goto label",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                       Page 17 of 40",
                    "md": "Final Exam                                                       Page 17 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 784.67,
                        "w": 451.32,
                        "h": 10.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 19,
            "text": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018\n6     Pipelining       [35 points]\nConsider two pipelined machines implementing MIPS ISA, Machine I and Machine II:\n    Both machines have the following five pipeline stages, very similarly to the basic 5-stage pipelined\nMIPS processor we discussed in lectures, and one ALU :\n   1. Fetch (one clock cycle)\n   2. Decode (one clock cycle)\n   3. Execute (one clock cycle)\n   4. Memory (one clock cycle)\n   5. Write-back (one clock cycle).\nMachine I    does not implement interlocking in hardware. It assumes all instructions are independent\n    and relies on the compiler to order instructions such that there is sufficient distance between depen-\n    dent instructions. The compiler either moves other independent instructions between two dependent\n    instructions, if it can find such instructions, or otherwise, inserts nops. Assume internal register file\n    forwarding (an instruction writes into a register in the first half of a cycle and another instruction\n    can correctly access the updated value of the same register in the next half of the cycle). Assume\n    that the processor predicts all branches as always-taken.\nMachine II   implements data forwarding in hardware. On detection of a flow dependence, it can forward\n    an operand from the memory stage or from the write-back stage to the execute stage.       The load\n    instruction (lw) can only be forwarded from the write-back stage because data becomes available in\n    the memory stage but not in the execute stage like for the other instructions. Assume internal register\n    file forwarding (an instruction writes into a register in the first half of a cycle and another instruction\n    can access the updated value of the same register in the next half of the cycle). The compiler does\n    not reorder instructions. Assume that the processor predicts all branches as always-taken.\n    Consider the following code segment:\nCopy: lw       $2, 100($5)\n        sw     $2, 200($6)\n        addi $1, $1, 1\n        bne    $1, $25, Copy\n    Initially, $5 = 0, $6 = 0, $1 = 0, and $25 = 25.\n(a) [10 points] When the given code segment is executed on Machine I, the compiler has to reorder\n     instructions and insert nops if needed. Write the resulting code that has minimal modifications\n     from the original.\n     Copy:    lw $2, 100($5)\n              addi $1, $1, 1\n              nop\n              sw $2, 200($6)\n              bne $1, $25, Copy\nFinal Exam                                                                               Page 18 of 40",
            "md": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018\n# 6     Pipelining       [35 points]\n\nConsider two pipelined machines implementing MIPS ISA, Machine I and Machine II:\n\nBoth machines have the following five pipeline stages, very similarly to the basic 5-stage pipelined MIPS processor we discussed in lectures, and one ALU :\n\n1. Fetch (one clock cycle)\n2. Decode (one clock cycle)\n3. Execute (one clock cycle)\n4. Memory (one clock cycle)\n5. Write-back (one clock cycle).\n\nMachine I does not implement interlocking in hardware. It assumes all instructions are independent and relies on the compiler to order instructions such that there is sufficient distance between dependent instructions. The compiler either moves other independent instructions between two dependent instructions, if it can find such instructions, or otherwise, inserts nops. Assume internal register file forwarding (an instruction writes into a register in the first half of a cycle and another instruction can correctly access the updated value of the same register in the next half of the cycle). Assume that the processor predicts all branches as always-taken.\n\nMachine II implements data forwarding in hardware. On detection of a flow dependence, it can forward an operand from the memory stage or from the write-back stage to the execute stage. The load instruction (lw) can only be forwarded from the write-back stage because data becomes available in the memory stage but not in the execute stage like for the other instructions. Assume internal register file forwarding (an instruction writes into a register in the first half of a cycle and another instruction can access the updated value of the same register in the next half of the cycle). The compiler does not reorder instructions. Assume that the processor predicts all branches as always-taken.\n\nConsider the following code segment:\n\nCopy: lw       $2, 100($5)\nsw     $2, 200($6)\naddi $1, $1, 1\nbne    $1, $25, Copy\nInitially, $5 = 0, $6 = 0, $1 = 0, and $25 = 25.\n# (a) [10 points] When the given code segment is executed on Machine I, the compiler has to reorder instructions and insert nops if needed. Write the resulting code that has minimal modifications from the original.\n\nCopy:    lw $2, 100($5)\naddi $1, $1, 1\nnop\nsw $2, 200($6)\nbne $1, $25, Copy\nFinal Exam                                                                               Page 18 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018",
                    "md": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "6     Pipelining       [35 points]",
                    "md": "# 6     Pipelining       [35 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 151.48,
                        "h": 14.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Consider two pipelined machines implementing MIPS ISA, Machine I and Machine II:\n\nBoth machines have the following five pipeline stages, very similarly to the basic 5-stage pipelined MIPS processor we discussed in lectures, and one ALU :\n\n1. Fetch (one clock cycle)\n2. Decode (one clock cycle)\n3. Execute (one clock cycle)\n4. Memory (one clock cycle)\n5. Write-back (one clock cycle).\n\nMachine I does not implement interlocking in hardware. It assumes all instructions are independent and relies on the compiler to order instructions such that there is sufficient distance between dependent instructions. The compiler either moves other independent instructions between two dependent instructions, if it can find such instructions, or otherwise, inserts nops. Assume internal register file forwarding (an instruction writes into a register in the first half of a cycle and another instruction can correctly access the updated value of the same register in the next half of the cycle). Assume that the processor predicts all branches as always-taken.\n\nMachine II implements data forwarding in hardware. On detection of a flow dependence, it can forward an operand from the memory stage or from the write-back stage to the execute stage. The load instruction (lw) can only be forwarded from the write-back stage because data becomes available in the memory stage but not in the execute stage like for the other instructions. Assume internal register file forwarding (an instruction writes into a register in the first half of a cycle and another instruction can access the updated value of the same register in the next half of the cycle). The compiler does not reorder instructions. Assume that the processor predicts all branches as always-taken.\n\nConsider the following code segment:\n\nCopy: lw       $2, 100($5)\nsw     $2, 200($6)\naddi $1, $1, 1\nbne    $1, $25, Copy\nInitially, $5 = 0, $6 = 0, $1 = 0, and $25 = 25.",
                    "md": "Consider two pipelined machines implementing MIPS ISA, Machine I and Machine II:\n\nBoth machines have the following five pipeline stages, very similarly to the basic 5-stage pipelined MIPS processor we discussed in lectures, and one ALU :\n\n1. Fetch (one clock cycle)\n2. Decode (one clock cycle)\n3. Execute (one clock cycle)\n4. Memory (one clock cycle)\n5. Write-back (one clock cycle).\n\nMachine I does not implement interlocking in hardware. It assumes all instructions are independent and relies on the compiler to order instructions such that there is sufficient distance between dependent instructions. The compiler either moves other independent instructions between two dependent instructions, if it can find such instructions, or otherwise, inserts nops. Assume internal register file forwarding (an instruction writes into a register in the first half of a cycle and another instruction can correctly access the updated value of the same register in the next half of the cycle). Assume that the processor predicts all branches as always-taken.\n\nMachine II implements data forwarding in hardware. On detection of a flow dependence, it can forward an operand from the memory stage or from the write-back stage to the execute stage. The load instruction (lw) can only be forwarded from the write-back stage because data becomes available in the memory stage but not in the execute stage like for the other instructions. Assume internal register file forwarding (an instruction writes into a register in the first half of a cycle and another instruction can access the updated value of the same register in the next half of the cycle). The compiler does not reorder instructions. Assume that the processor predicts all branches as always-taken.\n\nConsider the following code segment:\n\nCopy: lw       $2, 100($5)\nsw     $2, 200($6)\naddi $1, $1, 1\nbne    $1, $25, Copy\nInitially, $5 = 0, $6 = 0, $1 = 0, and $25 = 25.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.71,
                        "h": 620.81
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [10 points] When the given code segment is executed on Machine I, the compiler has to reorder instructions and insert nops if needed. Write the resulting code that has minimal modifications from the original.",
                    "md": "# (a) [10 points] When the given code segment is executed on Machine I, the compiler has to reorder instructions and insert nops if needed. Write the resulting code that has minimal modifications from the original.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 241.27,
                        "w": 451.51,
                        "h": 399.34
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Copy:    lw $2, 100($5)\naddi $1, $1, 1\nnop\nsw $2, 200($6)\nbne $1, $25, Copy\nFinal Exam                                                                               Page 18 of 40",
                    "md": "Copy:    lw $2, 100($5)\naddi $1, $1, 1\nnop\nsw $2, 200($6)\nbne $1, $25, Copy\nFinal Exam                                                                               Page 18 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.32,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 20,
            "text": "Initials: Solutions                                       Design of Digital Circuits  August 18th, 2018\n                     (b) [10 points] When the given code segment is executed on Machine II, dependencies between instruc-\n    tions are resolved in hardware. Explain when data is forwarded and which instructions are stalled\n    and when they are stalled.\n   In every iteration, data are forwarded for sw and for bne. The instruction sw is dependent on lw, so\n   it is stalled one cycle in every iteration\n(c) [5 points] Calculate the machine code size of the code segments executed on Machine I (part (a))\n    and Machine II (part (b)).\n    Machine I:       Machine I - 20 bytes (because of the additional nop)\n    Machine II:     Machine II - 16 bytes\n(d) [7 points] Calculate the number of cycles it takes to execute the code segment on Machine I and\n    Machine II.\n                     The compiler reorders instructions and places one nop. This is the execution\n                     timeline of the first iteration:\n                      1   2   3    4    5    6    7    8    9\n                      F   D   E    M    W\n    Machine I:            F   D    E    M    W\n                              N    N    N    N    N\n                                   F    D    E   M                      W\n                                        F    D   E                      M W\n                     9 cycles for one iteration. As there are 5 instructions in each iteration and 25\n                     iterations, the total number of cycles is 129 cycles.\n                    The machine stalls sw one cycle in the decode stage.   This is the execution\n                    timeline of the first iteration:\n                     1    2   3    4    5   6                         7 8  9\n                     F    D   E    M    W\n    Machine II:           F   D    D    E   M                         W\n                              F    F    D   E                         M W\n                                        F   D                         E M W\n                    9 cycles for one iteration. As there are 4 instructions in each iteration and 25\n                    iterations, and one stall cycle in each iteration, the total number of cycles is\n                    129 cycles.\nFinal Exam                                                                             Page 19 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (b) [10 points]\n\nWhen the given code segment is executed on Machine II, dependencies between instructions are resolved in hardware. Explain when data is forwarded and which instructions are stalled and when they are stalled.\n\nIn every iteration, data are forwarded for sw and for bne. The instruction sw is dependent on lw, so it is stalled one cycle in every iteration.\n\n# (c) [5 points]\n\nCalculate the machine code size of the code segments executed on Machine I (part (a)) and Machine II (part (b)).\n\n| Machine I:  | Machine I - 20 bytes (because of the additional nop) |\n| ----------- | ---------------------------------------------------- |\n| Machine II: | Machine II - 16 bytes                                |\n\n# (d) [7 points]\n\nCalculate the number of cycles it takes to execute the code segment on Machine I and Machine II.\n\nThe compiler reorders instructions and places one nop. This is the execution timeline of the first iteration:\n\n1 2 3 4 5 6 7 8 9\n\nF D E M W\n\nMachine I: F D E M W\n\nN N N N N\n\nF D E M W\n\nF D E M W\n\n9 cycles for one iteration. As there are 5 instructions in each iteration and 25 iterations, the total number of cycles is 129 cycles.\n\nThe machine stalls sw one cycle in the decode stage. This is the execution timeline of the first iteration:\n\n1 2 3 4 5 6 7 8 9\n\nF D E M W\n\nMachine II: F D D E M W\n\nF F D E M W\n\nF D E M W\n\n9 cycles for one iteration. As there are 4 instructions in each iteration and 25 iterations, and one stall cycle in each iteration, the total number of cycles is 129 cycles.\n\nFinal Exam Page 19 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 229.86,
                        "h": 464.1
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 169.67,
                        "y": 43.11,
                        "w": 183.26,
                        "h": 643.19
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 170.43,
                        "y": 43.11,
                        "w": 352.93,
                        "h": 594.97
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [10 points]",
                    "md": "# (b) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 170.43,
                        "y": 460.94,
                        "w": 131.43,
                        "h": 177.14
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "When the given code segment is executed on Machine II, dependencies between instructions are resolved in hardware. Explain when data is forwarded and which instructions are stalled and when they are stalled.\n\nIn every iteration, data are forwarded for sw and for bne. The instruction sw is dependent on lw, so it is stalled one cycle in every iteration.",
                    "md": "When the given code segment is executed on Machine II, dependencies between instructions are resolved in hardware. Explain when data is forwarded and which instructions are stalled and when they are stalled.\n\nIn every iteration, data are forwarded for sw and for bne. The instruction sw is dependent on lw, so it is stalled one cycle in every iteration.",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 83.96,
                        "w": 442.34,
                        "h": 602.34
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [5 points]",
                    "md": "# (c) [5 points]",
                    "rows": null,
                    "bBox": {
                        "x": 209.07,
                        "y": 460.94,
                        "w": 92.79,
                        "h": 177.14
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Calculate the machine code size of the code segments executed on Machine I (part (a)) and Machine II (part (b)).",
                    "md": "Calculate the machine code size of the code segments executed on Machine I (part (a)) and Machine II (part (b)).",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 230.13,
                        "w": 433.97,
                        "h": 456.17
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Machine I:  | Machine I - 20 bytes (because of the additional nop) |\n| ----------- | ---------------------------------------------------- |\n| Machine II: | Machine II - 16 bytes                                |",
                    "rows": [
                        [
                            "Machine I:",
                            "Machine I - 20 bytes (because of the additional nop)"
                        ],
                        [
                            "Machine II:",
                            "Machine II - 16 bytes"
                        ]
                    ],
                    "bBox": {
                        "x": 89.71,
                        "y": 280.33,
                        "w": 306.23,
                        "h": 388.9
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) [7 points]",
                    "md": "# (d) [7 points]",
                    "rows": null,
                    "bBox": {
                        "x": 188.13,
                        "y": 460.94,
                        "w": 113.74,
                        "h": 225.36
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Calculate the number of cycles it takes to execute the code segment on Machine I and Machine II.\n\nThe compiler reorders instructions and places one nop. This is the execution timeline of the first iteration:\n\n1 2 3 4 5 6 7 8 9\n\nF D E M W\n\nMachine I: F D E M W\n\nN N N N N\n\nF D E M W\n\nF D E M W\n\n9 cycles for one iteration. As there are 5 instructions in each iteration and 25 iterations, the total number of cycles is 129 cycles.\n\nThe machine stalls sw one cycle in the decode stage. This is the execution timeline of the first iteration:\n\n1 2 3 4 5 6 7 8 9\n\nF D E M W\n\nMachine II: F D D E M W\n\nF F D E M W\n\nF D E M W\n\n9 cycles for one iteration. As there are 4 instructions in each iteration and 25 iterations, and one stall cycle in each iteration, the total number of cycles is 129 cycles.\n\nFinal Exam Page 19 of 40",
                    "md": "Calculate the number of cycles it takes to execute the code segment on Machine I and Machine II.\n\nThe compiler reorders instructions and places one nop. This is the execution timeline of the first iteration:\n\n1 2 3 4 5 6 7 8 9\n\nF D E M W\n\nMachine I: F D E M W\n\nN N N N N\n\nF D E M W\n\nF D E M W\n\n9 cycles for one iteration. As there are 5 instructions in each iteration and 25 iterations, the total number of cycles is 129 cycles.\n\nThe machine stalls sw one cycle in the decode stage. This is the execution timeline of the first iteration:\n\n1 2 3 4 5 6 7 8 9\n\nF D E M W\n\nMachine II: F D D E M W\n\nF F D E M W\n\nF D E M W\n\n9 cycles for one iteration. As there are 4 instructions in each iteration and 25 iterations, and one stall cycle in each iteration, the total number of cycles is 129 cycles.\n\nFinal Exam Page 19 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 280.33,
                        "w": 451.32,
                        "h": 514.34
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 21,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n(e) [3 points] Which machine is faster for this code segment? Explain.\n   For this code segment, both machines take the same number of cycles. We cannot say which one is\n   faster, since we do not know the clock frequency.\nFinal Exam                                                                             Page 20 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (e) [3 points] Which machine is faster for this code segment? Explain.\n\nFor this code segment, both machines take the same number of cycles. We cannot say which one is faster, since we do not know the clock frequency.\n\nFinal Exam                                                                             Page 20 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(e) [3 points] Which machine is faster for this code segment? Explain.",
                    "md": "# (e) [3 points] Which machine is faster for this code segment? Explain.",
                    "rows": null,
                    "bBox": {
                        "x": 72.55,
                        "y": 72.0,
                        "w": 306.92,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "For this code segment, both machines take the same number of cycles. We cannot say which one is faster, since we do not know the clock frequency.\n\nFinal Exam                                                                             Page 20 of 40",
                    "md": "For this code segment, both machines take the same number of cycles. We cannot say which one is faster, since we do not know the clock frequency.\n\nFinal Exam                                                                             Page 20 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 89.72,
                        "w": 457.02,
                        "h": 704.95
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 22,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n7    Out-of-order Execution               [45 points]\nIn this problem, we will give you the state of the Register Alias Table (RAT) and Reservation Stations\n(RS) for an out-of-order execution engine that employs Tomasulo\u2019s algorithm, as we discussed in lectures.\nYour first task is to determine the original sequence of four instructions in program order.\n    The out-of-order machine in this problem behaves as follows:\n \u2022 The frontend of the machine has a one-cycle fetch stage and a one-cycle decode stage. The machine\n    can fetch one instruction per cycle, and can decode one instruction per cycle.\n \u2022 The machine executes only register-type instructions, e.g., OP Rdest \u2190 Rsrc1, Rsrc2., where OP can\n    be ADD or M U L.\n \u2022 The machine dispatches one instruction per cycle into the reservation stations, in program order.\n    Dispatch occurs during the decode stage.\n \u2022  An instruction always allocates the first reservation station that is available (in top-to-bottom order)\n    at the required functional unit.\n \u2022 When an instruction in a reservation station finishes executing, the reservation station is cleared.\n \u2022  The adder and multiplier are not pipelined. An ADD operation takes 2 cycles. A multiply operation\n    takes 3 cycles.\n \u2022  The result of an addition and multiplication is broadcast to the reservation station entries and the\n    RAT in the writeback stage. A dependent instruction can begin execution in the next cycle after the\n    writeback if it has all of its operands available in the reservation station entry. There is only one\n    broadcast bus, and thus multiple instructions cannot broadcast in the same cycle.\n \u2022 When multiple instructions are ready to execute at a functional unit at the same cycle, the oldest\n    ready instruction is chosen to be executed first.\n    Initially, the machine is empty. Four instructions then are fetched, decoded, and dispatched into\nreservation stations. Pictured below is the state of the machine when the final instruction has been\ndispatched into a reservation station:\n                                              RAT\n                                     Reg    V   Tag     Value\n                                      R0   \u2013     \u2013        \u2013\n                                      R1   0     A         5\n                                      R2   1     \u2013         8\n                                      R3   0     E        \u2013\n                                      R4   0     B        \u2013\n                                      R5   \u2013     \u2013        \u2013\n            ID V   Tag  Value  V   Tag  Value          ID V   Tag  Value   V  Tag  Value\n            A  0    D     \u2013    1    \u2013     8            D  1    \u2013     5    1    \u2013     5\n            B  0    A     \u2013    0    A     \u2013            E  0    A     \u2013    0    B     \u2013\n            C  \u2013    \u2013     \u2013    \u2013    \u2013     \u2013            F  \u2013    \u2013     \u2013    \u2013    \u2013     \u2013\n                           +                                         \u00d7\nFinal Exam                                                                             Page 21 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# 7 Out-of-order Execution [45 points]\n\nIn this problem, we will give you the state of the Register Alias Table (RAT) and Reservation Stations (RS) for an out-of-order execution engine that employs Tomasulo\u2019s algorithm, as we discussed in lectures. Your first task is to determine the original sequence of four instructions in program order.\n\nThe out-of-order machine in this problem behaves as follows:\n\n- The frontend of the machine has a one-cycle fetch stage and a one-cycle decode stage. The machine can fetch one instruction per cycle, and can decode one instruction per cycle.\n- The machine executes only register-type instructions, e.g., OP Rdest \u2190 Rsrc1, Rsrc2., where OP can be ADD or MUL.\n- The machine dispatches one instruction per cycle into the reservation stations, in program order. Dispatch occurs during the decode stage.\n- An instruction always allocates the first reservation station that is available (in top-to-bottom order) at the required functional unit.\n- When an instruction in a reservation station finishes executing, the reservation station is cleared.\n- The adder and multiplier are not pipelined. An ADD operation takes 2 cycles. A multiply operation takes 3 cycles.\n- The result of an addition and multiplication is broadcast to the reservation station entries and the RAT in the writeback stage. A dependent instruction can begin execution in the next cycle after the writeback if it has all of its operands available in the reservation station entry. There is only one broadcast bus, and thus multiple instructions cannot broadcast in the same cycle.\n- When multiple instructions are ready to execute at a functional unit at the same cycle, the oldest ready instruction is chosen to be executed first.\n\nInitially, the machine is empty. Four instructions then are fetched, decoded, and dispatched into reservation stations. Pictured below is the state of the machine when the final instruction has been dispatched into a reservation station:\n\n| RAT | Reg | V | Tag | Value |\n| --- | --- | - | --- | ----- |\n|     | R0  | \u2013 | \u2013   | \u2013     |\n|     | R1  | 0 | A   | 5     |\n|     | R2  | 1 | \u2013   | 8     |\n|     | R3  | 0 | E   | \u2013     |\n|     | R4  | 0 | B   | \u2013     |\n|     | R5  | \u2013 | \u2013   | \u2013     |\n\n| ID | V | Tag | Value | V | Tag | Value | ID | V | Tag | Value | V | Tag | Value |\n| -- | - | --- | ----- | - | --- | ----- | -- | - | --- | ----- | - | --- | ----- |\n| A  | 0 | D   | \u2013     | 1 | \u2013   | 8     | D  | 1 | \u2013   | 5     | 1 | \u2013   | 5     |\n| B  | 0 | A   | \u2013     | 0 | A   | \u2013     | E  | 0 | A   | \u2013     | 0 | B   | \u2013     |\n| C  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     | F  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n\nFinal Exam\n\nPage 21 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 290.57,
                        "h": 587.18
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 125.94,
                        "y": 43.11,
                        "w": 236.63,
                        "h": 602.7
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 125.94,
                        "y": 43.11,
                        "w": 397.42,
                        "h": 587.18
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "7 Out-of-order Execution [45 points]",
                    "md": "# 7 Out-of-order Execution [45 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 389.54,
                        "h": 578.19
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "In this problem, we will give you the state of the Register Alias Table (RAT) and Reservation Stations (RS) for an out-of-order execution engine that employs Tomasulo\u2019s algorithm, as we discussed in lectures. Your first task is to determine the original sequence of four instructions in program order.\n\nThe out-of-order machine in this problem behaves as follows:\n\n- The frontend of the machine has a one-cycle fetch stage and a one-cycle decode stage. The machine can fetch one instruction per cycle, and can decode one instruction per cycle.\n- The machine executes only register-type instructions, e.g., OP Rdest \u2190 Rsrc1, Rsrc2., where OP can be ADD or MUL.\n- The machine dispatches one instruction per cycle into the reservation stations, in program order. Dispatch occurs during the decode stage.\n- An instruction always allocates the first reservation station that is available (in top-to-bottom order) at the required functional unit.\n- When an instruction in a reservation station finishes executing, the reservation station is cleared.\n- The adder and multiplier are not pipelined. An ADD operation takes 2 cycles. A multiply operation takes 3 cycles.\n- The result of an addition and multiplication is broadcast to the reservation station entries and the RAT in the writeback stage. A dependent instruction can begin execution in the next cycle after the writeback if it has all of its operands available in the reservation station entry. There is only one broadcast bus, and thus multiple instructions cannot broadcast in the same cycle.\n- When multiple instructions are ready to execute at a functional unit at the same cycle, the oldest ready instruction is chosen to be executed first.\n\nInitially, the machine is empty. Four instructions then are fetched, decoded, and dispatched into reservation stations. Pictured below is the state of the machine when the final instruction has been dispatched into a reservation station:",
                    "md": "In this problem, we will give you the state of the Register Alias Table (RAT) and Reservation Stations (RS) for an out-of-order execution engine that employs Tomasulo\u2019s algorithm, as we discussed in lectures. Your first task is to determine the original sequence of four instructions in program order.\n\nThe out-of-order machine in this problem behaves as follows:\n\n- The frontend of the machine has a one-cycle fetch stage and a one-cycle decode stage. The machine can fetch one instruction per cycle, and can decode one instruction per cycle.\n- The machine executes only register-type instructions, e.g., OP Rdest \u2190 Rsrc1, Rsrc2., where OP can be ADD or MUL.\n- The machine dispatches one instruction per cycle into the reservation stations, in program order. Dispatch occurs during the decode stage.\n- An instruction always allocates the first reservation station that is available (in top-to-bottom order) at the required functional unit.\n- When an instruction in a reservation station finishes executing, the reservation station is cleared.\n- The adder and multiplier are not pipelined. An ADD operation takes 2 cycles. A multiply operation takes 3 cycles.\n- The result of an addition and multiplication is broadcast to the reservation station entries and the RAT in the writeback stage. A dependent instruction can begin execution in the next cycle after the writeback if it has all of its operands available in the reservation station entry. There is only one broadcast bus, and thus multiple instructions cannot broadcast in the same cycle.\n- When multiple instructions are ready to execute at a functional unit at the same cycle, the oldest ready instruction is chosen to be executed first.\n\nInitially, the machine is empty. Four instructions then are fetched, decoded, and dispatched into reservation stations. Pictured below is the state of the machine when the final instruction has been dispatched into a reservation station:",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.66,
                        "h": 578.19
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| RAT | Reg | V | Tag | Value |\n| --- | --- | - | --- | ----- |\n|     | R0  | \u2013 | \u2013   | \u2013     |\n|     | R1  | 0 | A   | 5     |\n|     | R2  | 1 | \u2013   | 8     |\n|     | R3  | 0 | E   | \u2013     |\n|     | R4  | 0 | B   | \u2013     |\n|     | R5  | \u2013 | \u2013   | \u2013     |",
                    "rows": [
                        [
                            "RAT",
                            "Reg",
                            "V",
                            "Tag",
                            "Value"
                        ],
                        [
                            "",
                            "R0",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ],
                        [
                            "",
                            "R1",
                            "0",
                            "A",
                            "5"
                        ],
                        [
                            "",
                            "R2",
                            "1",
                            "\u2013",
                            "8"
                        ],
                        [
                            "",
                            "R3",
                            "0",
                            "E",
                            "\u2013"
                        ],
                        [
                            "",
                            "R4",
                            "0",
                            "B",
                            "\u2013"
                        ],
                        [
                            "",
                            "R5",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.77,
                        "h": 751.56
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| ID | V | Tag | Value | V | Tag | Value | ID | V | Tag | Value | V | Tag | Value |\n| -- | - | --- | ----- | - | --- | ----- | -- | - | --- | ----- | - | --- | ----- |\n| A  | 0 | D   | \u2013     | 1 | \u2013   | 8     | D  | 1 | \u2013   | 5     | 1 | \u2013   | 5     |\n| B  | 0 | A   | \u2013     | 0 | A   | \u2013     | E  | 0 | A   | \u2013     | 0 | B   | \u2013     |\n| C  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     | F  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |",
                    "rows": [
                        [
                            "ID",
                            "V",
                            "Tag",
                            "Value",
                            "V",
                            "Tag",
                            "Value",
                            "ID",
                            "V",
                            "Tag",
                            "Value",
                            "V",
                            "Tag",
                            "Value"
                        ],
                        [
                            "A",
                            "0",
                            "D",
                            "\u2013",
                            "1",
                            "\u2013",
                            "8",
                            "D",
                            "1",
                            "\u2013",
                            "5",
                            "1",
                            "\u2013",
                            "5"
                        ],
                        [
                            "B",
                            "0",
                            "A",
                            "\u2013",
                            "0",
                            "A",
                            "\u2013",
                            "E",
                            "0",
                            "A",
                            "\u2013",
                            "0",
                            "B",
                            "\u2013"
                        ],
                        [
                            "C",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "F",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.77,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam\n\nPage 21 of 40",
                    "md": "Final Exam\n\nPage 21 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 474.73,
                        "w": 451.32,
                        "h": 319.94
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 23,
            "text": "Initials: Solutions                  Design of Digital Circuits                   August 18th, 2018\n(a) [15 points] Give the four instructions that have been dispatched into the machine, in program order.\n    The source registers for the first instruction can be specified in either order. Give instructions in the\n    following format: \u201copcode destination \u21d0 source1, source2.\u201d\n          MUL           R1     \u21d0     R1    ,                                                       R1\n          ADD           R1     \u21d0     R1    ,                                                       R2\n          ADD           R4     \u21d0     R1    ,                                                       R1\n          MUL           R3     \u21d0     R1    ,                                                       R4\n                                              (b) [15 points] Now assume that the machine flushes all instructions out of the pipeline and restarts fetch\n    from the first instruction in the sequence above. Show the full pipeline timing diagram below for\n    the sequence of four instructions that you determined above, from the fetch of the first instruction\n    to the writeback of the last instruction. Assume that the machine stops fetching instructions after\n    the fourth instruction.\n    As we saw in lectures, use \u201cF\u201d for fetch, \u201cD\u201d for decode, \u201cEn\u201d to signify the nth cycle of execution\n    for an instruction, and \u201cW\u201d to signify writeback. Fill in each instruction as well. You may or may\n    not need all columns shown.\n     Cycle:                1   2    3    4    5     6    7    8    9    10   11    12   13   14   15    16\n     MUL R1 \u2190 R1, R1       F   D    E1   E2   E3    W\n     ADD R1 \u2190 R1, R2           F    D                    E1   E2   W\n     ADD R4 \u2190 R1, R1                F    D                              E1   E2    W\n     MUL R3 \u2190 R1, R4                     F    D                                         E1   E2   E3    W\nFinal Exam                                                                            Page 22 of 40",
            "md": "Initials: Solutions                  Design of Digital Circuits                   August 18th, 2018\n\n# (a) [15 points]\n\nGive the four instructions that have been dispatched into the machine, in program order. The source registers for the first instruction can be specified in either order. Give instructions in the following format: \u201copcode destination \u21d0 source1, source2.\u201d\n\nMUL           R1     \u21d0     R1    ,                                                       R1\nADD           R1     \u21d0     R1    ,                                                       R2\nADD           R4     \u21d0     R1    ,                                                       R1\nMUL           R3     \u21d0     R1    ,                                                       R4\n\n# (b) [15 points]\n\nNow assume that the machine flushes all instructions out of the pipeline and restarts fetch from the first instruction in the sequence above. Show the full pipeline timing diagram below for the sequence of four instructions that you determined above, from the fetch of the first instruction to the writeback of the last instruction. Assume that the machine stops fetching instructions after the fourth instruction.\n\n| Cycle:          | 1 | 2 | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 |\n| --------------- | - | - | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| MUL R1 \u2190 R1, R1 | F | D | E1 | E2 | E3 | W  |    |    |    |    |    |    |    |    |    |    |\n| ADD R1 \u2190 R1, R2 |   | F | D  |    | E1 | E2 | W  |    |    |    |    |    |    |    |    |    |\n| ADD R4 \u2190 R1, R1 |   |   | F  | D  |    |    | E1 | E2 | W  |    |    |    |    |    |    |    |\n| MUL R3 \u2190 R1, R4 |   |   |    | F  | D  |    |    | E1 | E2 | E3 | W  |    |    |    |    |    |\n\nFinal Exam                                                                            Page 22 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                   August 18th, 2018",
                    "md": "Initials: Solutions                  Design of Digital Circuits                   August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 393.9
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [15 points]",
                    "md": "# (a) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 196.6,
                        "y": 327.39,
                        "w": 333.6,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Give the four instructions that have been dispatched into the machine, in program order. The source registers for the first instruction can be specified in either order. Give instructions in the following format: \u201copcode destination \u21d0 source1, source2.\u201d\n\nMUL           R1     \u21d0     R1    ,                                                       R1\nADD           R1     \u21d0     R1    ,                                                       R2\nADD           R4     \u21d0     R1    ,                                                       R1\nMUL           R3     \u21d0     R1    ,                                                       R4",
                    "md": "Give the four instructions that have been dispatched into the machine, in program order. The source registers for the first instruction can be specified in either order. Give instructions in the following format: \u201copcode destination \u21d0 source1, source2.\u201d\n\nMUL           R1     \u21d0     R1    ,                                                       R1\nADD           R1     \u21d0     R1    ,                                                       R2\nADD           R4     \u21d0     R1    ,                                                       R1\nMUL           R3     \u21d0     R1    ,                                                       R4",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 83.96,
                        "w": 464.6,
                        "h": 353.06
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [15 points]",
                    "md": "# (b) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 196.6,
                        "y": 327.39,
                        "w": 333.6,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Now assume that the machine flushes all instructions out of the pipeline and restarts fetch from the first instruction in the sequence above. Show the full pipeline timing diagram below for the sequence of four instructions that you determined above, from the fetch of the first instruction to the writeback of the last instruction. Assume that the machine stops fetching instructions after the fourth instruction.",
                    "md": "Now assume that the machine flushes all instructions out of the pipeline and restarts fetch from the first instruction in the sequence above. Show the full pipeline timing diagram below for the sequence of four instructions that you determined above, from the fetch of the first instruction to the writeback of the last instruction. Assume that the machine stops fetching instructions after the fourth instruction.",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 114.78,
                        "w": 464.6,
                        "h": 322.23
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Cycle:          | 1 | 2 | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 |\n| --------------- | - | - | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| MUL R1 \u2190 R1, R1 | F | D | E1 | E2 | E3 | W  |    |    |    |    |    |    |    |    |    |    |\n| ADD R1 \u2190 R1, R2 |   | F | D  |    | E1 | E2 | W  |    |    |    |    |    |    |    |    |    |\n| ADD R4 \u2190 R1, R1 |   |   | F  | D  |    |    | E1 | E2 | W  |    |    |    |    |    |    |    |\n| MUL R3 \u2190 R1, R4 |   |   |    | F  | D  |    |    | E1 | E2 | E3 | W  |    |    |    |    |    |",
                    "rows": [
                        [
                            "Cycle:",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "9",
                            "10",
                            "11",
                            "12",
                            "13",
                            "14",
                            "15",
                            "16"
                        ],
                        [
                            "MUL R1 \u2190 R1, R1",
                            "F",
                            "D",
                            "E1",
                            "E2",
                            "E3",
                            "W",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "ADD R1 \u2190 R1, R2",
                            "",
                            "F",
                            "D",
                            "",
                            "E1",
                            "E2",
                            "W",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "ADD R4 \u2190 R1, R1",
                            "",
                            "",
                            "F",
                            "D",
                            "",
                            "",
                            "E1",
                            "E2",
                            "W",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "MUL R3 \u2190 R1, R4",
                            "",
                            "",
                            "",
                            "F",
                            "D",
                            "",
                            "",
                            "E1",
                            "E2",
                            "E3",
                            "W",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 482.87,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                                            Page 22 of 40",
                    "md": "Final Exam                                                                            Page 22 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 327.39,
                        "w": 451.32,
                        "h": 467.28
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 24,
            "text": "Initials: Solutions         Design of Digital Circuits        August 18th, 2018\n(c) [15 points] Finally, show the state of the RAT and reservation stations at the end of the 12th cycle\n   of execution in the figure below. Complete all blank parts.\n                                  RAT\n                           Reg   V  Tag   Value\n                            R0  \u2013    \u2013      \u2013\n                            R1  1    \u2013     33\n                            R2  1    \u2013      8\n                            R3  0    E      \u2013\n                            R4  1    \u2013     66\n                            R5  \u2013    \u2013      \u2013\n         ID V Tag Value V Tag Value      ID V Tag Value V Tag  Value\n         A  \u2013  \u2013    \u2013   \u2013  \u2013    \u2013        D  \u2013  \u2013    \u2013   \u2013  \u2013    \u2013\n         B  \u2013  \u2013    \u2013   \u2013  \u2013    \u2013        E  1  \u2013   33  1   \u2013   66\n         C  \u2013  \u2013    \u2013   \u2013  \u2013    \u2013        F  \u2013  \u2013    \u2013  \u2013   \u2013    \u2013\n                    +                               \u00d7\nFinal Exam                                                       Page 23 of 40",
            "md": "\nInitials: Solutions         Design of Digital Circuits        August 18th, 2018\n\n# (c) [15 points]\n\nFinally, show the state of the RAT and reservation stations at the end of the 12th cycle of execution in the figure below. Complete all blank parts.\n\n# RAT\n\n| Reg | V | Tag | Value |\n| --- | - | --- | ----- |\n| R0  | \u2013 | \u2013   | \u2013     |\n| R1  | 1 | \u2013   | 33    |\n| R2  | 1 | \u2013   | 8     |\n| R3  | 0 | E   | \u2013     |\n| R4  | 1 | \u2013   | 66    |\n| R5  | \u2013 | \u2013   | \u2013     |\n\n# Reservation Stations\n\n| ID | V | Tag | Value | V | Tag | Value |\n| -- | - | --- | ----- | - | --- | ----- |\n| A  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| B  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| C  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| D  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| E  | 1 | \u2013   | 33    | 1 | \u2013   | 66    |\n| F  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n\n+                               \u00d7\n\nFinal Exam                                                       Page 23 of 40\n\n\n",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions         Design of Digital Circuits        August 18th, 2018",
                    "md": "Initials: Solutions         Design of Digital Circuits        August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 286.98
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [15 points]",
                    "md": "# (c) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 126.52,
                        "y": 163.0,
                        "w": 286.76,
                        "h": 166.67
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Finally, show the state of the RAT and reservation stations at the end of the 12th cycle of execution in the figure below. Complete all blank parts.",
                    "md": "Finally, show the state of the RAT and reservation stations at the end of the 12th cycle of execution in the figure below. Complete all blank parts.",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 83.96,
                        "w": 324.03,
                        "h": 246.14
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "RAT",
                    "md": "# RAT",
                    "rows": null,
                    "bBox": {
                        "x": 125.94,
                        "y": 102.06,
                        "w": 187.16,
                        "h": 195.04
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Reg | V | Tag | Value |\n| --- | - | --- | ----- |\n| R0  | \u2013 | \u2013   | \u2013     |\n| R1  | 1 | \u2013   | 33    |\n| R2  | 1 | \u2013   | 8     |\n| R3  | 0 | E   | \u2013     |\n| R4  | 1 | \u2013   | 66    |\n| R5  | \u2013 | \u2013   | \u2013     |",
                    "rows": [
                        [
                            "Reg",
                            "V",
                            "Tag",
                            "Value"
                        ],
                        [
                            "R0",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ],
                        [
                            "R1",
                            "1",
                            "\u2013",
                            "33"
                        ],
                        [
                            "R2",
                            "1",
                            "\u2013",
                            "8"
                        ],
                        [
                            "R3",
                            "0",
                            "E",
                            "\u2013"
                        ],
                        [
                            "R4",
                            "1",
                            "\u2013",
                            "66"
                        ],
                        [
                            "R5",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.62,
                        "h": 751.56
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Reservation Stations",
                    "md": "# Reservation Stations",
                    "rows": null,
                    "bBox": {
                        "x": 125.94,
                        "y": 128.3,
                        "w": 287.8,
                        "h": 185.31
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| ID | V | Tag | Value | V | Tag | Value |\n| -- | - | --- | ----- | - | --- | ----- |\n| A  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| B  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| C  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| D  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |\n| E  | 1 | \u2013   | 33    | 1 | \u2013   | 66    |\n| F  | \u2013 | \u2013   | \u2013     | \u2013 | \u2013   | \u2013     |",
                    "rows": [
                        [
                            "ID",
                            "V",
                            "Tag",
                            "Value",
                            "V",
                            "Tag",
                            "Value"
                        ],
                        [
                            "A",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ],
                        [
                            "B",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ],
                        [
                            "C",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ],
                        [
                            "D",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ],
                        [
                            "E",
                            "1",
                            "\u2013",
                            "33",
                            "1",
                            "\u2013",
                            "66"
                        ],
                        [
                            "F",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013",
                            "\u2013"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.62,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "+                               \u00d7\n\nFinal Exam                                                       Page 23 of 40",
                    "md": "+                               \u00d7\n\nFinal Exam                                                       Page 23 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 196.63,
                        "w": 451.32,
                        "h": 598.04
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 25,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n8    Vector Processing            [40 points]\nAssume a vector processor that implements the following ISA:\n          Opcode      Operands  Latency (cycles)                 Description\n               SET    Vst, #n          1           Vst \u2190 n (Vst = Vector Stride Register)\n               SET    Vln, #n          1           Vln \u2190 n (Vln = Vector Length Register)\n               VLD     Vi, #A    100, pipelined              Vi \u2190 M em[Address]\n               VST     Vi, #A    100, pipelined              M em[Address] \u2190 Vi\n               VMUL Vi, Vj , Vk  10, pipelined                  Vi \u2190 Vj \u2217 Vk\n               VADD Vi, Vj , Vk   5, pipelined                  Vi \u2190 Vj + Vk\n               VDIV Vi, Vj , Vk  20, pipelined                  Vi \u2190 Vj /Vk\n      Assume the following:\n   \u2022 The processor has an in-order pipeline.\n   \u2022 The size of a vector element is 4 bytes.\n   \u2022 Vst and Vln are 10-bit registers.\n   \u2022 The processor does not support chaining between vector functional units.\n   \u2022 The main memory has N banks.\n   \u2022  Vector elements stored in consecutive memory addresses are interleaved between the memory banks.\n      E.g., if a vector element at address A maps to bank B, a vector element at address A + 4 maps\n      to bank (B + 1)%N , where % is the modulo operator and N     is the number of banks.  N is not\n      necessarily a power of two.\n   \u2022 The memory is byte addressable and the address space is represented using 32 bits.\n   \u2022  Vector elements are stored in memory in 4-byte-aligned manner.\n   \u2022 Each memory bank has a 4 KB row buffer.\n   \u2022 Each memory bank has a single read and a single write port so that a load and a store operation\n      can be performed simultaneously.\n   \u2022  There are separate functional units for executing VLD and VST instructions.\n(a) [5 points] What should the minimum value of N   be to avoid stalls while executing a VLD or VST\n    instruction, assuming a vector stride of 1? Explain.\n   100 banks (because the latency of VLD and VST instructions is 100 cycles)\nFinal Exam                                                                             Page 24 of 40",
            "md": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n\n# 8    Vector Processing            [40 points]\n\nAssume a vector processor that implements the following ISA:\n\n| Opcode | Operands   | Latency (cycles) | Description                            |\n| ------ | ---------- | ---------------- | -------------------------------------- |\n| SET    | Vst, #n    | 1                | Vst \u2190 n (Vst = Vector Stride Register) |\n| SET    | Vln, #n    | 1                | Vln \u2190 n (Vln = Vector Length Register) |\n| VLD    | Vi, #A     | 100, pipelined   | Vi \u2190 Mem\\[Address]                     |\n| VST    | Vi, #A     | 100, pipelined   | Mem\\[Address] \u2190 Vi                     |\n| VMUL   | Vi, Vj, Vk | 10, pipelined    | Vi \u2190 Vj \u2217 Vk                           |\n| VADD   | Vi, Vj, Vk | 5, pipelined     | Vi \u2190 Vj + Vk                           |\n| VDIV   | Vi, Vj, Vk | 20, pipelined    | Vi \u2190 Vj / Vk                           |\n\nAssume the following:\n\n- The processor has an in-order pipeline.\n- The size of a vector element is 4 bytes.\n- Vst and Vln are 10-bit registers.\n- The processor does not support chaining between vector functional units.\n- The main memory has N banks.\n- Vector elements stored in consecutive memory addresses are interleaved between the memory banks.\n- E.g., if a vector element at address A maps to bank B, a vector element at address A + 4 maps to bank (B + 1)%N, where % is the modulo operator and N is the number of banks. N is not necessarily a power of two.\n- The memory is byte addressable and the address space is represented using 32 bits.\n- Vector elements are stored in memory in 4-byte-aligned manner.\n- Each memory bank has a 4 KB row buffer.\n- Each memory bank has a single read and a single write port so that a load and a store operation can be performed simultaneously.\n- There are separate functional units for executing VLD and VST instructions.\n\n# (a) [5 points] What should the minimum value of N be to avoid stalls while executing a VLD or VST instruction, assuming a vector stride of 1? Explain.\n\n100 banks (because the latency of VLD and VST instructions is 100 cycles)\n\nFinal Exam                                                                             Page 24 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018",
                    "md": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 139.36
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "8    Vector Processing            [40 points]",
                    "md": "# 8    Vector Processing            [40 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 205.02,
                        "h": 14.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Assume a vector processor that implements the following ISA:",
                    "md": "Assume a vector processor that implements the following ISA:",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 93.82,
                        "w": 271.41,
                        "h": 10.0
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Opcode | Operands   | Latency (cycles) | Description                            |\n| ------ | ---------- | ---------------- | -------------------------------------- |\n| SET    | Vst, #n    | 1                | Vst \u2190 n (Vst = Vector Stride Register) |\n| SET    | Vln, #n    | 1                | Vln \u2190 n (Vln = Vector Length Register) |\n| VLD    | Vi, #A     | 100, pipelined   | Vi \u2190 Mem\\[Address]                     |\n| VST    | Vi, #A     | 100, pipelined   | Mem\\[Address] \u2190 Vi                     |\n| VMUL   | Vi, Vj, Vk | 10, pipelined    | Vi \u2190 Vj \u2217 Vk                           |\n| VADD   | Vi, Vj, Vk | 5, pipelined     | Vi \u2190 Vj + Vk                           |\n| VDIV   | Vi, Vj, Vk | 20, pipelined    | Vi \u2190 Vj / Vk                           |",
                    "rows": [
                        [
                            "Opcode",
                            "Operands",
                            "Latency (cycles)",
                            "Description"
                        ],
                        [
                            "SET",
                            "Vst, #n",
                            "1",
                            "Vst \u2190 n (Vst = Vector Stride Register)"
                        ],
                        [
                            "SET",
                            "Vln, #n",
                            "1",
                            "Vln \u2190 n (Vln = Vector Length Register)"
                        ],
                        [
                            "VLD",
                            "Vi, #A",
                            "100, pipelined",
                            "Vi \u2190 Mem[Address]"
                        ],
                        [
                            "VST",
                            "Vi, #A",
                            "100, pipelined",
                            "Mem[Address] \u2190 Vi"
                        ],
                        [
                            "VMUL",
                            "Vi, Vj, Vk",
                            "10, pipelined",
                            "Vi \u2190 Vj \u2217 Vk"
                        ],
                        [
                            "VADD",
                            "Vi, Vj, Vk",
                            "5, pipelined",
                            "Vi \u2190 Vj + Vk"
                        ],
                        [
                            "VDIV",
                            "Vi, Vj, Vk",
                            "20, pipelined",
                            "Vi \u2190 Vj / Vk"
                        ]
                    ],
                    "bBox": {
                        "x": 86.48,
                        "y": 43.11,
                        "w": 436.88,
                        "h": 606.93
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Assume the following:\n\n- The processor has an in-order pipeline.\n- The size of a vector element is 4 bytes.\n- Vst and Vln are 10-bit registers.\n- The processor does not support chaining between vector functional units.\n- The main memory has N banks.\n- Vector elements stored in consecutive memory addresses are interleaved between the memory banks.\n- E.g., if a vector element at address A maps to bank B, a vector element at address A + 4 maps to bank (B + 1)%N, where % is the modulo operator and N is the number of banks. N is not necessarily a power of two.\n- The memory is byte addressable and the address space is represented using 32 bits.\n- Vector elements are stored in memory in 4-byte-aligned manner.\n- Each memory bank has a 4 KB row buffer.\n- Each memory bank has a single read and a single write port so that a load and a store operation can be performed simultaneously.\n- There are separate functional units for executing VLD and VST instructions.",
                    "md": "Assume the following:\n\n- The processor has an in-order pipeline.\n- The size of a vector element is 4 bytes.\n- Vst and Vln are 10-bit registers.\n- The processor does not support chaining between vector functional units.\n- The main memory has N banks.\n- Vector elements stored in consecutive memory addresses are interleaved between the memory banks.\n- E.g., if a vector element at address A maps to bank B, a vector element at address A + 4 maps to bank (B + 1)%N, where % is the modulo operator and N is the number of banks. N is not necessarily a power of two.\n- The memory is byte addressable and the address space is represented using 32 bits.\n- Vector elements are stored in memory in 4-byte-aligned manner.\n- Each memory bank has a 4 KB row buffer.\n- Each memory bank has a single read and a single write port so that a load and a store operation can be performed simultaneously.\n- There are separate functional units for executing VLD and VST instructions.",
                    "rows": null,
                    "bBox": {
                        "x": 86.94,
                        "y": 148.16,
                        "w": 436.59,
                        "h": 450.24
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [5 points] What should the minimum value of N be to avoid stalls while executing a VLD or VST instruction, assuming a vector stride of 1? Explain.",
                    "md": "# (a) [5 points] What should the minimum value of N be to avoid stalls while executing a VLD or VST instruction, assuming a vector stride of 1? Explain.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 148.16,
                        "w": 451.07,
                        "h": 484.11
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "100 banks (because the latency of VLD and VST instructions is 100 cycles)\n\nFinal Exam                                                                             Page 24 of 40",
                    "md": "100 banks (because the latency of VLD and VST instructions is 100 cycles)\n\nFinal Exam                                                                             Page 24 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 148.16,
                        "w": 451.32,
                        "h": 646.51
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 26,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n(b) [8 points] What should the minimum value of N   be to avoid stalls while executing a VLD or VST\n    instruction, assuming a vector stride of 2? Explain.\n   101 banks.\n   Explanation. To avoid stalls, we need to ensure that consecutive vector elements access 100 different\n   banks.\n   With a vector stride of 2, consecutive elements of a vector will map to every other bank. For example,\n   if the first element maps to bank 0, the next element will map to bank 2, and so on.\n   With 100 banks, the 51st element of a vector will map to bank 100%100 = 0, conflicting with the first\n   element of the vector.\n   Howevert, with 101 banks, the 51st element will map to bank 1, which was skipped by the previous\n   vector elements.\n   Let\u2019s assume there are 102 elements in a vector and the first elements accesses bank 0. The 101 banks\n   will be accessed in the following order:\n   (0, 2, ..., 100, 102, 104, ..., 200, 202)%101 = (0, 2, ..., 100, 1, 3, ..., 99, 0)\n   We can see that none of the elements conflict in the DRAM banks. Note that, when the last vector\n   elements accesses bank 0, the bank is already available for a new access because the 100 cycle latency\n   of accessing the first element is overlapped by accessing the other 101 elements.\n(c) [12 points] Assume:\n      \u2022 A machine that has a memory with as many banks as you found is part (a).\n      \u2022 The vector stride is set to 1.\n      \u2022 The value of the vector length is set to M (but we do not know M)\n    The machine executes the following program:\n    VLD V1 \u2190 A\n    VLD V2 \u2190 (A + 32768)\n    VADD V3 \u2190 V1, V1\n    VMUL V4 \u2190 V2, V3\n    VST (A + 32768*2) \u2190 V4\n    The total number of cycles needed to complete the execution of the above program is 4306. What is\n    M?\n     M   =  1000\n     Explanation.\n     VLD   |-100-|--(M-1)--|\n     VLD                       |-100-|--(M-1)--|\n     VADD                       |-5-|--(M-1)--|\n     VMUL                                        |-10-|--(M-1)--|\n     VST                                                           |-100-|--(M-1)--|\n     (M + 100 \u2212 1) +  100  +  (M \u2212 1)  +   10 +   (M \u2212 1)  +  100  +  (M \u2212 1)\n     =  306  +  4 \u2217 M  =  4306   \u2192    M   =   1000 elements\nFinal Exam                                                                             Page 25 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (b) [8 points]\n\nWhat should the minimum value of N be to avoid stalls while executing a VLD or VST instruction, assuming a vector stride of 2? Explain.\n\n101 banks.\n\nExplanation. To avoid stalls, we need to ensure that consecutive vector elements access 100 different banks. With a vector stride of 2, consecutive elements of a vector will map to every other bank. For example, if the first element maps to bank 0, the next element will map to bank 2, and so on. With 100 banks, the 51st element of a vector will map to bank 100%100 = 0, conflicting with the first element of the vector. However, with 101 banks, the 51st element will map to bank 1, which was skipped by the previous vector elements.\n\nLet\u2019s assume there are 102 elements in a vector and the first elements accesses bank 0. The 101 banks will be accessed in the following order:\n\n(0, 2, ..., 100, 102, 104, ..., 200, 202)%101 = (0, 2, ..., 100, 1, 3, ..., 99, 0)\n\nWe can see that none of the elements conflict in the DRAM banks. Note that, when the last vector elements accesses bank 0, the bank is already available for a new access because the 100 cycle latency of accessing the first element is overlapped by accessing the other 101 elements.\n\n# (c) [12 points]\n\nAssume:\n\n- A machine that has a memory with as many banks as you found is part (a).\n- The vector stride is set to 1.\n- The value of the vector length is set to M (but we do not know M).\n\nThe machine executes the following program:\n\nVLD V1 \u2190 A\nVLD V2 \u2190 (A + 32768)\nVADD V3 \u2190 V1, V1\nVMUL V4 \u2190 V2, V3\nVST (A + 32768*2) \u2190 V4\n\nThe total number of cycles needed to complete the execution of the above program is 4306. What is M?\n\nM = 1000\n\nExplanation.\n\n| VLD  | \\|-100-\\|--(M-1)--\\| |\n| ---- | -------------------- |---|---|---|\n| VLD  | \\|-100-\\|--(M-1)--\\| |\n| VADD | \\|-5-\\|--(M-1)--\\|   |\n| VMUL | \\|-10-\\|--(M-1)--\\|  |\n| VST  | \\|-100-\\|--(M-1)--\\| |\n\n(M + 100 \u2212 1) + 100 + (M \u2212 1) + 10 + (M \u2212 1) + 100 + (M \u2212 1) = 306 + 4 \u2217 M = 4306 \u2192 M = 1000 elements\n\nFinal Exam Page 25 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [8 points]",
                    "md": "# (b) [8 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What should the minimum value of N be to avoid stalls while executing a VLD or VST instruction, assuming a vector stride of 2? Explain.\n\n101 banks.\n\nExplanation. To avoid stalls, we need to ensure that consecutive vector elements access 100 different banks. With a vector stride of 2, consecutive elements of a vector will map to every other bank. For example, if the first element maps to bank 0, the next element will map to bank 2, and so on. With 100 banks, the 51st element of a vector will map to bank 100%100 = 0, conflicting with the first element of the vector. However, with 101 banks, the 51st element will map to bank 1, which was skipped by the previous vector elements.\n\nLet\u2019s assume there are 102 elements in a vector and the first elements accesses bank 0. The 101 banks will be accessed in the following order:\n\n(0, 2, ..., 100, 102, 104, ..., 200, 202)%101 = (0, 2, ..., 100, 1, 3, ..., 99, 0)\n\nWe can see that none of the elements conflict in the DRAM banks. Note that, when the last vector elements accesses bank 0, the bank is already available for a new access because the 100 cycle latency of accessing the first element is overlapped by accessing the other 101 elements.",
                    "md": "What should the minimum value of N be to avoid stalls while executing a VLD or VST instruction, assuming a vector stride of 2? Explain.\n\n101 banks.\n\nExplanation. To avoid stalls, we need to ensure that consecutive vector elements access 100 different banks. With a vector stride of 2, consecutive elements of a vector will map to every other bank. For example, if the first element maps to bank 0, the next element will map to bank 2, and so on. With 100 banks, the 51st element of a vector will map to bank 100%100 = 0, conflicting with the first element of the vector. However, with 101 banks, the 51st element will map to bank 1, which was skipped by the previous vector elements.\n\nLet\u2019s assume there are 102 elements in a vector and the first elements accesses bank 0. The 101 banks will be accessed in the following order:\n\n(0, 2, ..., 100, 102, 104, ..., 200, 202)%101 = (0, 2, ..., 100, 1, 3, ..., 99, 0)\n\nWe can see that none of the elements conflict in the DRAM banks. Note that, when the last vector elements accesses bank 0, the bank is already available for a new access because the 100 cycle latency of accessing the first element is overlapped by accessing the other 101 elements.",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 72.0,
                        "w": 442.66,
                        "h": 576.67
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [12 points]",
                    "md": "# (c) [12 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Assume:\n\n- A machine that has a memory with as many banks as you found is part (a).\n- The vector stride is set to 1.\n- The value of the vector length is set to M (but we do not know M).\n\nThe machine executes the following program:\n\nVLD V1 \u2190 A\nVLD V2 \u2190 (A + 32768)\nVADD V3 \u2190 V1, V1\nVMUL V4 \u2190 V2, V3\nVST (A + 32768*2) \u2190 V4\n\nThe total number of cycles needed to complete the execution of the above program is 4306. What is M?\n\nM = 1000\n\nExplanation.",
                    "md": "Assume:\n\n- A machine that has a memory with as many banks as you found is part (a).\n- The vector stride is set to 1.\n- The value of the vector length is set to M (but we do not know M).\n\nThe machine executes the following program:\n\nVLD V1 \u2190 A\nVLD V2 \u2190 (A + 32768)\nVADD V3 \u2190 V1, V1\nVMUL V4 \u2190 V2, V3\nVST (A + 32768*2) \u2190 V4\n\nThe total number of cycles needed to complete the execution of the above program is 4306. What is M?\n\nM = 1000\n\nExplanation.",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 385.52,
                        "w": 433.87,
                        "h": 263.15
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "\\| VLD  | |-100-|--(M-1)--| |\n\\| ---- | -------------------- |---|---|---|\n\\| VLD  | |-100-|--(M-1)--| |\n\\| VADD | |-5-|--(M-1)--|   |\n\\| VMUL | |-10-|--(M-1)--|  |\n\\| VST  | |-100-|--(M-1)--| |",
                    "rows": [],
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "(M + 100 \u2212 1) + 100 + (M \u2212 1) + 10 + (M \u2212 1) + 100 + (M \u2212 1) = 306 + 4 \u2217 M = 4306 \u2192 M = 1000 elements\n\nFinal Exam Page 25 of 40",
                    "md": "(M + 100 \u2212 1) + 100 + (M \u2212 1) + 10 + (M \u2212 1) + 100 + (M \u2212 1) = 306 + 4 \u2217 M = 4306 \u2192 M = 1000 elements\n\nFinal Exam Page 25 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 519.12,
                        "w": 451.32,
                        "h": 275.55
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 27,
            "text": "Initials: Solutions                                                                Design of Digital Circuits  August 18th, 2018\n                                            (d) [15 points] If we modify the vector processor to support chaining, how many cycles would be required\n    to execute the same program in part (c)? Explain.\n     VLD  |--100--|--(VLEN-1)--|\n     VLD                        |---100---|---(VLEN-1)---|\n     VADD                       |-1-|-5-|---(VLEN-1)---|   (this is delayed because the processor\n                                                           executes  the  instructions in order)\n     VMUL                                   |-10-|---(VLEN-1)---|\n     VST                                         |-100-|---(VLEN-1)---|\n         100 + (VLEN-1)  + 100  + 10 + 100  + (VLEN-1) = 310  + 2*1000 -  2 = 2308 cycles\nFinal Exam                                                                     Page 26 of 40",
            "md": "Initials: Solutions\n\n# Design of Digital Circuits\n\nAugust 18th, 2018\n\n# (d) [15 points]\n\nIf we modify the vector processor to support chaining, how many cycles would be required to execute the same program in part (c)? Explain.\n\n| VLD  | --100-- | --(VLEN-1)-- |                |                |\n| ---- | ------- | ------------ | -------------- | -------------- |\n| VLD  |         | ---100---    | ---(VLEN-1)--- |                |\n| VADD | -1-     | -5-          | ---(VLEN-1)--- |                |\n| VMUL |         |              | -10-           | ---(VLEN-1)--- |\n| VST  |         |              | -100-          | ---(VLEN-1)--- |\n\n100 + (VLEN-1) + 100 + 10 + 100 + (VLEN-1) = 310 + 2*1000 - 2 = 2308 cycles\n\n# Final Exam\n\nPage 26 of 40\n\n",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "August 18th, 2018",
                    "md": "August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 437.4,
                        "y": 43.11,
                        "w": 85.95,
                        "h": 151.07
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) [15 points]",
                    "md": "# (d) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "If we modify the vector processor to support chaining, how many cycles would be required to execute the same program in part (c)? Explain.",
                    "md": "If we modify the vector processor to support chaining, how many cycles would be required to execute the same program in part (c)? Explain.",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 83.96,
                        "w": 342.18,
                        "h": 66.38
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| VLD  | --100-- | --(VLEN-1)-- |                |                |\n| ---- | ------- | ------------ | -------------- | -------------- |\n| VLD  |         | ---100---    | ---(VLEN-1)--- |                |\n| VADD | -1-     | -5-          | ---(VLEN-1)--- |                |\n| VMUL |         |              | -10-           | ---(VLEN-1)--- |\n| VST  |         |              | -100-          | ---(VLEN-1)--- |",
                    "rows": [
                        [
                            "VLD",
                            "--100--",
                            "--(VLEN-1)--",
                            "",
                            ""
                        ],
                        [
                            "VLD",
                            "",
                            "---100---",
                            "---(VLEN-1)---",
                            ""
                        ],
                        [
                            "VADD",
                            "-1-",
                            "-5-",
                            "---(VLEN-1)---",
                            ""
                        ],
                        [
                            "VMUL",
                            "",
                            "",
                            "-10-",
                            "---(VLEN-1)---"
                        ],
                        [
                            "VST",
                            "",
                            "",
                            "-100-",
                            "---(VLEN-1)---"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 500.04,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "100 + (VLEN-1) + 100 + 10 + 100 + (VLEN-1) = 310 + 2*1000 - 2 = 2308 cycles",
                    "md": "100 + (VLEN-1) + 100 + 10 + 100 + (VLEN-1) = 310 + 2*1000 - 2 = 2308 cycles",
                    "rows": null,
                    "bBox": {
                        "x": 114.62,
                        "y": 185.18,
                        "w": 403.21,
                        "h": 9.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Final Exam",
                    "md": "# Final Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 784.67,
                        "w": 50.87,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 26 of 40",
                    "md": "Page 26 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 437.4,
                        "y": 185.18,
                        "w": 85.91,
                        "h": 609.49
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 28,
            "text": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n9    GPUs and SIMD               [45 points]\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are\nkept busy with active threads during the run of the program. As we saw in lecture and practice exercises,\nthe SIMD utilization of a program is computed across the complete run of the program.\n   The following code segment is run on a GPU. Each thread executes a single iteration of the shown\nloop. Assume that the data values of the arrays A and B are already in vector registers, so there are no\nloads and stores in this program. (Hint: Notice that there are 3 instructions in each iteration.) A warp\nin the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU.\nfor (i = 0; i < 1025; i++) {\n     if (A[i] < 33) {                // Instruction 1\n                B[i] = A[i] << 1;    // Instruction 2\n     }\n     else {\n                B[i] = A[i] >> 1;    // Instruction 3\n     }\n}\n   Please answer the following six questions.\n(a) [2 points] How many warps does it take to execute this program?\n   33 warps.\n   Explanation:\n   The number of warps is calculated as:\n   #W arps = d #T otal_threadse,\n                 #W arp_size\n   where\n   #T otal_threads = 1025 = 210 + 1   (i.e., one thread per loop iteration),\n   and\n   #W arp_size = 32 = 25 (given).\n   Thus, the number of warps needed to run this program is:\n   #W arps = d 2\u00b9\u2070+1 e = 25 + 1 = 33.\n                  25\n(b) [10 points] What is the maximum    possible SIMD utilization of this program?  (Hint:  The warp\n    scheduler does not issue instructions when no threads are active).\n    1025 .\n     ~~1056~~  \n   Explanation:\n   Even though all active threads in a warp follow the same execution path, the last warp will only have\n   one active thread.\nFinal Exam                                                                             Page 27 of 40",
            "md": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018\n\n# 9    GPUs and SIMD               [45 points]\n\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of the program. As we saw in lecture and practice exercises, the SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A and B are already in vector registers, so there are no loads and stores in this program. (Hint: Notice that there are 3 instructions in each iteration.) A warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU.\n\nfor (i = 0; i < 1025; i++) {\nif (A[i] < 33) {                // Instruction 1\nB[i] = A[i] << 1;    // Instruction 2\n}\nelse {\nB[i] = A[i] >> 1;    // Instruction 3\n}\n}\n\nPlease answer the following six questions.\n\n# (a) [2 points] How many warps does it take to execute this program?\n\n33 warps.\n\nExplanation:\n\nThe number of warps is calculated as:\n\n#W arps = d #T otal_threadse,\n\n#W arp_size\n\nwhere\n\n#T otal_threads = 1025 = 210 + 1   (i.e., one thread per loop iteration),\n\nand\n\n#W arp_size = 32 = 25 (given).\n\nThus, the number of warps needed to run this program is:\n\n#W arps = d 2\u00b9\u2070+1 e = 25 + 1 = 33.\n\n# (b) [10 points] What is the maximum possible SIMD utilization of this program?  (Hint:  The warp scheduler does not issue instructions when no threads are active).\n\n1025 .\n\n~~1056~~\n\nExplanation:\n\nEven though all active threads in a warp follow the same execution path, the last warp will only have one active thread.\n\nFinal Exam                                                                             Page 27 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018",
                    "md": "Initials: Solutions                   Design of Digital Circuits                   August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "9    GPUs and SIMD               [45 points]",
                    "md": "# 9    GPUs and SIMD               [45 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 200.46,
                        "h": 382.22
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of the program. As we saw in lecture and practice exercises, the SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A and B are already in vector registers, so there are no loads and stores in this program. (Hint: Notice that there are 3 instructions in each iteration.) A warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU.\n\nfor (i = 0; i < 1025; i++) {\nif (A[i] < 33) {                // Instruction 1\nB[i] = A[i] << 1;    // Instruction 2\n}\nelse {\nB[i] = A[i] >> 1;    // Instruction 3\n}\n}\n\nPlease answer the following six questions.",
                    "md": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of the program. As we saw in lecture and practice exercises, the SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. Each thread executes a single iteration of the shown loop. Assume that the data values of the arrays A and B are already in vector registers, so there are no loads and stores in this program. (Hint: Notice that there are 3 instructions in each iteration.) A warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU.\n\nfor (i = 0; i < 1025; i++) {\nif (A[i] < 33) {                // Instruction 1\nB[i] = A[i] << 1;    // Instruction 2\n}\nelse {\nB[i] = A[i] >> 1;    // Instruction 3\n}\n}\n\nPlease answer the following six questions.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 93.82,
                        "w": 451.76,
                        "h": 485.46
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [2 points] How many warps does it take to execute this program?",
                    "md": "# (a) [2 points] How many warps does it take to execute this program?",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 314.99,
                        "w": 302.15,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "33 warps.\n\nExplanation:\n\nThe number of warps is calculated as:",
                    "md": "33 warps.\n\nExplanation:\n\nThe number of warps is calculated as:",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 332.24,
                        "w": 165.71,
                        "h": 302.18
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "W arps = d T otal_threadse,",
                    "md": "#W arps = d #T otal_threadse,",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "W arp_size",
                    "md": "#W arp_size",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "where",
                    "md": "where",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 403.97,
                        "w": 25.0,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "T otal_threads = 1025 = 210 + 1   (i.e., one thread per loop iteration),",
                    "md": "#T otal_threads = 1025 = 210 + 1   (i.e., one thread per loop iteration),",
                    "rows": null,
                    "bBox": {
                        "x": 150.94,
                        "y": 415.93,
                        "w": 245.75,
                        "h": 86.27
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "and",
                    "md": "and",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 439.84,
                        "w": 16.0,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "W arp_size = 32 = 25 (given).",
                    "md": "#W arp_size = 32 = 25 (given).",
                    "rows": null,
                    "bBox": {
                        "x": 150.94,
                        "y": 495.2,
                        "w": 6.97,
                        "h": 7.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Thus, the number of warps needed to run this program is:",
                    "md": "Thus, the number of warps needed to run this program is:",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 475.7,
                        "w": 253.33,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "W arps = d 2\u00b9\u2070+1 e = 25 + 1 = 33.",
                    "md": "#W arps = d 2\u00b9\u2070+1 e = 25 + 1 = 33.",
                    "rows": null,
                    "bBox": {
                        "x": 150.94,
                        "y": 495.2,
                        "w": 6.97,
                        "h": 7.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [10 points] What is the maximum possible SIMD utilization of this program?  (Hint:  The warp scheduler does not issue instructions when no threads are active).",
                    "md": "# (b) [10 points] What is the maximum possible SIMD utilization of this program?  (Hint:  The warp scheduler does not issue instructions when no threads are active).",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 569.28,
                        "w": 451.49,
                        "h": 21.96
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1025 .\n\n~~1056~~\n\nExplanation:\n\nEven though all active threads in a warp follow the same execution path, the last warp will only have one active thread.\n\nFinal Exam                                                                             Page 27 of 40",
                    "md": "1025 .\n\n~~1056~~\n\nExplanation:\n\nEven though all active threads in a warp follow the same execution path, the last warp will only have one active thread.\n\nFinal Exam                                                                             Page 27 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 356.15,
                        "w": 457.08,
                        "h": 438.52
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 29,
            "text": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018\n(c) [5 points] Please describe what needs to be true about array A to reach the maximum possible SIMD\n    utilization asked in part (b). (Please cover all cases in your answer.)\n   For every 32 consecutive elements of  A, every element should be lower than 33 (if), or greater than\n   or equal to 33 (else). (NOTE: The solution is correct if both cases are given.)\n(d) [13 points] What is the minimum   possible SIMD utilization of this program?\n    1025 .\n     ~~1568~~  \n   Explanation:\n   Instruction 1 is executed by every active thread ( 1025    utilization).\n   Then, part of the threads in each warp executes      ~~1056~~  \n                                                        Instruction 2      and the other part executes\n   Instruction      3. We consider that Instruction 2 is executed by \u03b1 threads in each warp (except\n   the last warp), where 0 < \u03b1 \u2264 32, and Instruction 3 is executed by the remaining 32 \u2212 \u03b1 threads.\n   The only active thread in the last warp executes either Instruction 2 or Instruction 3. The\n   other instruction is not issued for this warp.\n   The minimum SIMD utilization sums to 1025+\u03b1\u00d732+(32\u2212\u03b1)\u00d732+1 = 1025 .\n                                               1056+1024+1024+32       ~~1568~~  \n(e) [5 points] Please describe what needs to be true about array A to reach the minimum possible SIMD\n    utilization asked in part (d). (Please cover all cases in your answer.)\n   For every 32 consecutive elements of  A, part of the elements should be lower than 33 (if), and the\n   other part should be greater than or equal to 33 (else).\n (f) [10 points] What is the SIMD utilization of this program if A[i] = i? Show your work.\n    1025 .\n     ~~1072~~  \n   Explanation:\n   Instruction 1 is executed by every active thread ( 1025    utilization).\n   Instruction 2 is executed by the first 33 threads,   ~~1056~~  \n                                                         i.e., all threads in the first warp and one thread\n   in the second warp.\n   Instruction 3 is executed by the remaining active threads.\n   The SIMD utilization sums to    1025+32+1+31+960+1   = 2050 = 1025 .\n                                   ~~1056+32+32+32+960+32</s>  <s>2144</s>  <s>1072~~  \nFinal Exam                                                                               Page 28 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (c) [5 points]\n\nPlease describe what needs to be true about array A to reach the maximum possible SIMD utilization asked in part (b). (Please cover all cases in your answer.)\n\nFor every 32 consecutive elements of A, every element should be lower than 33 (if), or greater than or equal to 33 (else). (NOTE: The solution is correct if both cases are given.)\n\n# (d) [13 points]\n\nWhat is the minimum possible SIMD utilization of this program?\n\n1025.\n\n~~1568~~\n\nExplanation:\n\nInstruction 1 is executed by every active thread (1025 utilization). Then, part of the threads in each warp executes ~~1056~~ Instruction 2 and the other part executes Instruction 3. We consider that Instruction 2 is executed by \u03b1 threads in each warp (except the last warp), where 0 < \u03b1 \u2264 32, and Instruction 3 is executed by the remaining 32 \u2212 \u03b1 threads. The only active thread in the last warp executes either Instruction 2 or Instruction 3. The other instruction is not issued for this warp.\n\nThe minimum SIMD utilization sums to 1025 + \u03b1 \u00d7 32 + (32 \u2212 \u03b1) \u00d7 32 + 1 = 1025.\n\n~~1056 + 1024 + 1024 + 32 1568~~\n\n# (e) [5 points]\n\nPlease describe what needs to be true about array A to reach the minimum possible SIMD utilization asked in part (d). (Please cover all cases in your answer.)\n\nFor every 32 consecutive elements of A, part of the elements should be lower than 33 (if), and the other part should be greater than or equal to 33 (else).\n\n# (f) [10 points]\n\nWhat is the SIMD utilization of this program if A[i] = i? Show your work.\n\n1025.\n\n~~1072~~\n\nExplanation:\n\nInstruction 1 is executed by every active thread (1025 utilization). Instruction 2 is executed by the first 33 threads, ~~1056~~ i.e., all threads in the first warp and one thread in the second warp. Instruction 3 is executed by the remaining active threads.\n\nThe SIMD utilization sums to 1025 + 32 + 1 + 31 + 960 + 1 = 2050 = 1025.\n\n~~1056 + 32 + 32 + 32 + 960 + 32 2144 1072~~\n\nFinal Exam Page 28 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [5 points]",
                    "md": "# (c) [5 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Please describe what needs to be true about array A to reach the maximum possible SIMD utilization asked in part (b). (Please cover all cases in your answer.)\n\nFor every 32 consecutive elements of A, every element should be lower than 33 (if), or greater than or equal to 33 (else). (NOTE: The solution is correct if both cases are given.)",
                    "md": "Please describe what needs to be true about array A to reach the maximum possible SIMD utilization asked in part (b). (Please cover all cases in your answer.)\n\nFor every 32 consecutive elements of A, every element should be lower than 33 (if), or greater than or equal to 33 (else). (NOTE: The solution is correct if both cases are given.)",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 83.96,
                        "w": 442.33,
                        "h": 369.58
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) [13 points]",
                    "md": "# (d) [13 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What is the minimum possible SIMD utilization of this program?\n\n1025.\n\n~~1568~~\n\nExplanation:\n\nInstruction 1 is executed by every active thread (1025 utilization). Then, part of the threads in each warp executes ~~1056~~ Instruction 2 and the other part executes Instruction 3. We consider that Instruction 2 is executed by \u03b1 threads in each warp (except the last warp), where 0 < \u03b1 \u2264 32, and Instruction 3 is executed by the remaining 32 \u2212 \u03b1 threads. The only active thread in the last warp executes either Instruction 2 or Instruction 3. The other instruction is not issued for this warp.\n\nThe minimum SIMD utilization sums to 1025 + \u03b1 \u00d7 32 + (32 \u2212 \u03b1) \u00d7 32 + 1 = 1025.\n\n~~1056 + 1024 + 1024 + 32 1568~~",
                    "md": "What is the minimum possible SIMD utilization of this program?\n\n1025.\n\n~~1568~~\n\nExplanation:\n\nInstruction 1 is executed by every active thread (1025 utilization). Then, part of the threads in each warp executes ~~1056~~ Instruction 2 and the other part executes Instruction 3. We consider that Instruction 2 is executed by \u03b1 threads in each warp (except the last warp), where 0 < \u03b1 \u2264 32, and Instruction 3 is executed by the remaining 32 \u2212 \u03b1 threads. The only active thread in the last warp executes either Instruction 2 or Instruction 3. The other instruction is not issued for this warp.\n\nThe minimum SIMD utilization sums to 1025 + \u03b1 \u00d7 32 + (32 \u2212 \u03b1) \u00d7 32 + 1 = 1025.\n\n~~1056 + 1024 + 1024 + 32 1568~~",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 198.8,
                        "w": 442.43,
                        "h": 406.4
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(e) [5 points]",
                    "md": "# (e) [5 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Please describe what needs to be true about array A to reach the minimum possible SIMD utilization asked in part (d). (Please cover all cases in your answer.)\n\nFor every 32 consecutive elements of A, part of the elements should be lower than 33 (if), and the other part should be greater than or equal to 33 (else).",
                    "md": "Please describe what needs to be true about array A to reach the minimum possible SIMD utilization asked in part (d). (Please cover all cases in your answer.)\n\nFor every 32 consecutive elements of A, part of the elements should be lower than 33 (if), and the other part should be greater than or equal to 33 (else).",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 102.28,
                        "w": 442.42,
                        "h": 363.21
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(f) [10 points]",
                    "md": "# (f) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 595.28,
                        "h": 841.89
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What is the SIMD utilization of this program if A[i] = i? Show your work.\n\n1025.\n\n~~1072~~\n\nExplanation:\n\nInstruction 1 is executed by every active thread (1025 utilization). Instruction 2 is executed by the first 33 threads, ~~1056~~ i.e., all threads in the first warp and one thread in the second warp. Instruction 3 is executed by the remaining active threads.\n\nThe SIMD utilization sums to 1025 + 32 + 1 + 31 + 960 + 1 = 2050 = 1025.\n\n~~1056 + 32 + 32 + 32 + 960 + 32 2144 1072~~\n\nFinal Exam Page 28 of 40",
                    "md": "What is the SIMD utilization of this program if A[i] = i? Show your work.\n\n1025.\n\n~~1072~~\n\nExplanation:\n\nInstruction 1 is executed by every active thread (1025 utilization). Instruction 2 is executed by the first 33 threads, ~~1056~~ i.e., all threads in the first warp and one thread in the second warp. Instruction 3 is executed by the remaining active threads.\n\nThe SIMD utilization sums to 1025 + 32 + 1 + 31 + 960 + 1 = 2050 = 1025.\n\n~~1056 + 32 + 32 + 32 + 960 + 32 2144 1072~~\n\nFinal Exam Page 28 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 217.15,
                        "w": 456.47,
                        "h": 577.52
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 30,
            "text": "Initials: Solutions                    Design of Digital Circuits                   August 18th, 2018\n10     Memory Hierarchy               [40 points]\nAn enterprising computer architect is building a new machine for high-frequency stock trading and\nneeds to choose a CPU. She will need to optimize her setup for memory access latency       in order to\ngain a competitive edge in the market. She is considering two different prototype enthusiast CPUs that\nadvertise high memory performance:\n(A) Dragonfire-980 Hyper-Z\n(B) Peregrine G-Class XTreme\nShe needs to characterize these CPUs to select the best one, and she knows from Prof. Mutlu\u2019s course\nthat she is capable of reverse-engineering everything she needs to know. Unfortunately, these CPUs are\nnot yet publicly available, and their exact specifications are unavailable. Luckily, important documents\nwere recently leaked, claiming that the two CPUs have:\n    \u2022  Exactly 1 high-performance core\n    \u2022 LRU replacement policies (for any set-associative caches)\n    \u2022  Inclusive caching (i.e., data in a given cache level is present upward throughout the memory hier-\n       archy. For example, if a cache line is present in L1, the cache line is also present in L2 and L3 if\n       available.)\n    \u2022  Constant-latency memory structures (i.e., an access to any part of a given memory structure takes\n       the same amount of time)\n    \u2022 Cache line, size, and associativity are all size aligned to powers of two\n    Being an ingenious engineer, she devises the following simple application in order to extract all\nof the information she needs to know.    The application uses a high-resolution timer to measure the\namount of time it takes to read data from memory with a specific pattern parameterized by STRIDE\nand MAX_ADDRESS:\nstart_timer()\nrepeat N times:\n          memory_address <- random_data()\n          READ[(memory_address * STRIDE) % MAX_ADDRESS]\nend_timer()\n            Assume 1) this code runs for a long time, so all memory structures are fully warmed up, i.e., repeatedly\naccessed data is already cached, and 2) N is large enough such that the timer captures only steady-state\ninformation.\n                   By sweeping STRIDE and MAX_ADDRESS, the computer architect can glean information about the\nvarious memory structures in each CPU.\n    She produces Figure 1 for CPU A and Figure 2 for CPU B.\n              Your task: Using the data from the graphs, reverse-engineer the following system parameters. If the\nparameter does not make sense   (e.g., L3 cache in a 2-cache system), mark the box with an \"X\". If the\ngraphs provide insufficient information to ascertain a desired parameter, simply mark it as \"N/A\".\n   NOTE 1 TO SOLUTION READER:\n          This analysis provides insufficient information to determine the line size of the cache(s). This is because\n            we are always \u2019striding\u2019 in power-of-two values starting at address 0. This means that either our access\n              pattern entirely fits within the cache (in which case we observe constant latency since the cache is\n           already warmed up), or the access pattern is striding using values larger than the line size, so we never\n   see two accesses to the same cache line.\nFinal Exam                                                                               Page 29 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# 10 Memory Hierarchy [40 points]\n\nAn enterprising computer architect is building a new machine for high-frequency stock trading and needs to choose a CPU. She will need to optimize her setup for memory access latency in order to gain a competitive edge in the market. She is considering two different prototype enthusiast CPUs that advertise high memory performance:\n\n- (A) Dragonfire-980 Hyper-Z\n- (B) Peregrine G-Class XTreme\n\nShe needs to characterize these CPUs to select the best one, and she knows from Prof. Mutlu\u2019s course that she is capable of reverse-engineering everything she needs to know. Unfortunately, these CPUs are not yet publicly available, and their exact specifications are unavailable. Luckily, important documents were recently leaked, claiming that the two CPUs have:\n\n- Exactly 1 high-performance core\n- LRU replacement policies (for any set-associative caches)\n- Inclusive caching (i.e., data in a given cache level is present upward throughout the memory hierarchy. For example, if a cache line is present in L1, the cache line is also present in L2 and L3 if available.)\n- Constant-latency memory structures (i.e., an access to any part of a given memory structure takes the same amount of time)\n- Cache line, size, and associativity are all size aligned to powers of two\n\nBeing an ingenious engineer, she devises the following simple application in order to extract all of the information she needs to know. The application uses a high-resolution timer to measure the amount of time it takes to read data from memory with a specific pattern parameterized by STRIDE and MAX_ADDRESS:\n\nstart_timer()\nrepeat N times:\nmemory_address <- random_data()\nREAD[(memory_address * STRIDE) % MAX_ADDRESS]\nend_timer()\n\nAssume 1) this code runs for a long time, so all memory structures are fully warmed up, i.e., repeatedly accessed data is already cached, and 2) N is large enough such that the timer captures only steady-state information.\n\nBy sweeping STRIDE and MAX_ADDRESS, the computer architect can glean information about the various memory structures in each CPU.\n\nShe produces Figure 1 for CPU A and Figure 2 for CPU B.\n\nYour task: Using the data from the graphs, reverse-engineer the following system parameters. If the parameter does not make sense (e.g., L3 cache in a 2-cache system), mark the box with an \"X\". If the graphs provide insufficient information to ascertain a desired parameter, simply mark it as \"N/A\".\n\nNOTE 1 TO SOLUTION READER: This analysis provides insufficient information to determine the line size of the cache(s). This is because we are always \u2019striding\u2019 in power-of-two values starting at address 0. This means that either our access pattern entirely fits within the cache (in which case we observe constant latency since the cache is already warmed up), or the access pattern is striding using values larger than the line size, so we never see two accesses to the same cache line.\n\nFinal Exam Page 29 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "10 Memory Hierarchy [40 points]",
                    "md": "# 10 Memory Hierarchy [40 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 220.24,
                        "h": 14.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "An enterprising computer architect is building a new machine for high-frequency stock trading and needs to choose a CPU. She will need to optimize her setup for memory access latency in order to gain a competitive edge in the market. She is considering two different prototype enthusiast CPUs that advertise high memory performance:\n\n- (A) Dragonfire-980 Hyper-Z\n- (B) Peregrine G-Class XTreme\n\nShe needs to characterize these CPUs to select the best one, and she knows from Prof. Mutlu\u2019s course that she is capable of reverse-engineering everything she needs to know. Unfortunately, these CPUs are not yet publicly available, and their exact specifications are unavailable. Luckily, important documents were recently leaked, claiming that the two CPUs have:\n\n- Exactly 1 high-performance core\n- LRU replacement policies (for any set-associative caches)\n- Inclusive caching (i.e., data in a given cache level is present upward throughout the memory hierarchy. For example, if a cache line is present in L1, the cache line is also present in L2 and L3 if available.)\n- Constant-latency memory structures (i.e., an access to any part of a given memory structure takes the same amount of time)\n- Cache line, size, and associativity are all size aligned to powers of two\n\nBeing an ingenious engineer, she devises the following simple application in order to extract all of the information she needs to know. The application uses a high-resolution timer to measure the amount of time it takes to read data from memory with a specific pattern parameterized by STRIDE and MAX_ADDRESS:\n\nstart_timer()\nrepeat N times:\nmemory_address <- random_data()\nREAD[(memory_address * STRIDE) % MAX_ADDRESS]\nend_timer()\n\nAssume 1) this code runs for a long time, so all memory structures are fully warmed up, i.e., repeatedly accessed data is already cached, and 2) N is large enough such that the timer captures only steady-state information.\n\nBy sweeping STRIDE and MAX_ADDRESS, the computer architect can glean information about the various memory structures in each CPU.\n\nShe produces Figure 1 for CPU A and Figure 2 for CPU B.\n\nYour task: Using the data from the graphs, reverse-engineer the following system parameters. If the parameter does not make sense (e.g., L3 cache in a 2-cache system), mark the box with an \"X\". If the graphs provide insufficient information to ascertain a desired parameter, simply mark it as \"N/A\".\n\nNOTE 1 TO SOLUTION READER: This analysis provides insufficient information to determine the line size of the cache(s). This is because we are always \u2019striding\u2019 in power-of-two values starting at address 0. This means that either our access pattern entirely fits within the cache (in which case we observe constant latency since the cache is already warmed up), or the access pattern is striding using values larger than the line size, so we never see two accesses to the same cache line.\n\nFinal Exam Page 29 of 40",
                    "md": "An enterprising computer architect is building a new machine for high-frequency stock trading and needs to choose a CPU. She will need to optimize her setup for memory access latency in order to gain a competitive edge in the market. She is considering two different prototype enthusiast CPUs that advertise high memory performance:\n\n- (A) Dragonfire-980 Hyper-Z\n- (B) Peregrine G-Class XTreme\n\nShe needs to characterize these CPUs to select the best one, and she knows from Prof. Mutlu\u2019s course that she is capable of reverse-engineering everything she needs to know. Unfortunately, these CPUs are not yet publicly available, and their exact specifications are unavailable. Luckily, important documents were recently leaked, claiming that the two CPUs have:\n\n- Exactly 1 high-performance core\n- LRU replacement policies (for any set-associative caches)\n- Inclusive caching (i.e., data in a given cache level is present upward throughout the memory hierarchy. For example, if a cache line is present in L1, the cache line is also present in L2 and L3 if available.)\n- Constant-latency memory structures (i.e., an access to any part of a given memory structure takes the same amount of time)\n- Cache line, size, and associativity are all size aligned to powers of two\n\nBeing an ingenious engineer, she devises the following simple application in order to extract all of the information she needs to know. The application uses a high-resolution timer to measure the amount of time it takes to read data from memory with a specific pattern parameterized by STRIDE and MAX_ADDRESS:\n\nstart_timer()\nrepeat N times:\nmemory_address <- random_data()\nREAD[(memory_address * STRIDE) % MAX_ADDRESS]\nend_timer()\n\nAssume 1) this code runs for a long time, so all memory structures are fully warmed up, i.e., repeatedly accessed data is already cached, and 2) N is large enough such that the timer captures only steady-state information.\n\nBy sweeping STRIDE and MAX_ADDRESS, the computer architect can glean information about the various memory structures in each CPU.\n\nShe produces Figure 1 for CPU A and Figure 2 for CPU B.\n\nYour task: Using the data from the graphs, reverse-engineer the following system parameters. If the parameter does not make sense (e.g., L3 cache in a 2-cache system), mark the box with an \"X\". If the graphs provide insufficient information to ascertain a desired parameter, simply mark it as \"N/A\".\n\nNOTE 1 TO SOLUTION READER: This analysis provides insufficient information to determine the line size of the cache(s). This is because we are always \u2019striding\u2019 in power-of-two values starting at address 0. This means that either our access pattern entirely fits within the cache (in which case we observe constant latency since the cache is already warmed up), or the access pattern is striding using values larger than the line size, so we never see two accesses to the same cache line.\n\nFinal Exam Page 29 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 454.42,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 31,
            "text": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018\n   NOTE 2 TO SOLUTION READER:\n   This problem is not actually that hard.\n   The way to think about these plots is that each point is an access pattern.   The easiest points to\n   understand are those that result in an access pattern of {0, 0, 0, 0, ...} and randomly from {0,\n   A}, where A is your stride.  Just by looking at those you should be able to determine pretty much\n   everything.\n   The access latencies and sizes are trivial to read off if you understand what the test code is trying\n   to do. The associativities are nuanced, but you can tell from the aforementioned access patterns by\n   simulating carefully.\n   If you want to go all-in, you can compute probabilities: if I access {0, A} then 50% of the time I\u2019ll hit\n   and 50% miss. It\u2019s easy to get the cache latencies, so I can just match points from there on :)\nFinal Exam                                                                               Page 30 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# NOTE 2 TO SOLUTION READER:\n\nThis problem is not actually that hard. The way to think about these plots is that each point is an access pattern. The easiest points to understand are those that result in an access pattern of {0, 0, 0, 0, ...} and randomly from {0, A}, where A is your stride. Just by looking at those you should be able to determine pretty much everything.\n\nThe access latencies and sizes are trivial to read off if you understand what the test code is trying to do. The associativities are nuanced, but you can tell from the aforementioned access patterns by simulating carefully.\n\nIf you want to go all-in, you can compute probabilities: if I access {0, A} then 50% of the time I\u2019ll hit and 50% miss. It\u2019s easy to get the cache latencies, so I can just match points from there on :)\n\nFinal Exam Page 30 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 443.26,
                        "y": 43.11,
                        "w": 80.1,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "NOTE 2 TO SOLUTION READER:",
                    "md": "# NOTE 2 TO SOLUTION READER:",
                    "rows": null,
                    "bBox": {
                        "x": 83.71,
                        "y": 72.29,
                        "w": 161.37,
                        "h": 10.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "This problem is not actually that hard. The way to think about these plots is that each point is an access pattern. The easiest points to understand are those that result in an access pattern of {0, 0, 0, 0, ...} and randomly from {0, A}, where A is your stride. Just by looking at those you should be able to determine pretty much everything.\n\nThe access latencies and sizes are trivial to read off if you understand what the test code is trying to do. The associativities are nuanced, but you can tell from the aforementioned access patterns by simulating carefully.\n\nIf you want to go all-in, you can compute probabilities: if I access {0, A} then 50% of the time I\u2019ll hit and 50% miss. It\u2019s easy to get the cache latencies, so I can just match points from there on :)\n\nFinal Exam Page 30 of 40",
                    "md": "This problem is not actually that hard. The way to think about these plots is that each point is an access pattern. The easiest points to understand are those that result in an access pattern of {0, 0, 0, 0, ...} and randomly from {0, A}, where A is your stride. Just by looking at those you should be able to determine pretty much everything.\n\nThe access latencies and sizes are trivial to read off if you understand what the test code is trying to do. The associativities are nuanced, but you can tell from the aforementioned access patterns by simulating carefully.\n\nIf you want to go all-in, you can compute probabilities: if I access {0, A} then 50% of the time I\u2019ll hit and 50% miss. It\u2019s easy to get the cache latencies, so I can just match points from there on :)\n\nFinal Exam Page 30 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 84.24,
                        "w": 454.44,
                        "h": 710.43
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 32,
            "text": "Initials: Solutions                    Design of Digital Circuits                    August 18th, 2018\n(a) [15 points] Fill in the blanks for Dragonfire-980 Hyper-Z.\n    120\n    110                                                  8      16      32\n    100                                         4\n      90                                 2                                                 STRIDE\n      80                                                                                       1\n (ns) 70                                                                                       2\n time                                                                                          4\n      60                                                                                       8\n      50                        1                                                              16\n      40                                                                                       32\n      30\n      20\n      10\n      0    22      23      24      25       26      27      28      29      210     211\n                                           MAX_ADDRESS\nFigure 1: Execution time of the test code on CPU A for various values of STRIDE and MAX_ADDRESS.\nSTRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, and\n8 overlap in the figure.\n               Table 1: Fill in the following table for CPU A (Dragonfire-980 Hyper-Z)\n System Parameter                              CPU A: Dragonfire-980 Hyper-Z\n                                     L1                 L2                 L3              DRAM\n Cache Line Size (B)                N/A                N/A                N/A             N/A OR X\n Cache Associativity                 2                  X                  X                 X\n Total Cache Size (B)                16                 X                  X                 X\n Access Latency from (ns) 1          20                 X                  X                 100\n 1 DRAM access latency means the latency of fetching the data from DRAM to L3, not        the latency of\n   bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means\n   the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to\n   the CPU from the L1 cache.\nFinal Exam                                                                                Page 31 of 40",
            "md": "Initials: Solutions\n\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (a) [15 points] Fill in the blanks for Dragonfire-980 Hyper-Z.\n\n<svg width=\"400\" height=\"200\">\n\n<text x=\"10\" y=\"130\">120</text>\n<text x=\"30\" y=\"120\">110</text>\n<text x=\"50\" y=\"110\">100</text>\n<text x=\"70\" y=\"100\">90</text>\n<text x=\"90\" y=\"90\">80</text>\n<text x=\"110\" y=\"80\">70</text>\n<text x=\"130\" y=\"70\">60</text>\n<text x=\"150\" y=\"60\">50</text>\n<text x=\"170\" y=\"50\">40</text>\n<text x=\"190\" y=\"40\">30</text>\n<text x=\"210\" y=\"30\">20</text>\n<text x=\"230\" y=\"20\">10</text>\n<text x=\"250\" y=\"10\">0</text>\n<text x=\"220\" y=\"150\">22</text>\n<text x=\"240\" y=\"150\">23</text>\n<text x=\"260\" y=\"150\">24</text>\n<text x=\"280\" y=\"150\">25</text>\n<text x=\"300\" y=\"150\">26</text>\n<text x=\"320\" y=\"150\">27</text>\n<text x=\"340\" y=\"150\">28</text>\n<text x=\"360\" y=\"150\">29</text>\n<text x=\"380\" y=\"150\">210</text>\n<text x=\"400\" y=\"150\">211</text>\n</svg>\nFigure 1: Execution time of the test code on CPU A for various values of STRIDE and MAX_ADDRESS. STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, and 8 overlap in the figure.\n\n# Table 1: Fill in the following table for CPU A (Dragonfire-980 Hyper-Z)\n\n| System Parameter         | CPU A: Dragonfire-980 Hyper-Z | L1  | L2  | L3       | DRAM |\n| ------------------------ | ----------------------------- | --- | --- | -------- | ---- |\n| Cache Line Size (B)      | N/A                           | N/A | N/A | N/A OR X |      |\n| Cache Associativity      | 2                             | X   | X   | X        |      |\n| Total Cache Size (B)     | 16                            | X   | X   | X        |      |\n| Access Latency from (ns) | 1                             | 20  | X   | X        | 100  |\n\n1 DRAM access latency means the latency of fetching the data from DRAM to L3, not the latency of bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to the CPU from the L1 cache.\n\nFinal Exam Page 31 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 93.76,
                        "y": 43.11,
                        "w": 429.6,
                        "h": 474.38
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [15 points] Fill in the blanks for Dragonfire-980 Hyper-Z.",
                    "md": "# (a) [15 points] Fill in the blanks for Dragonfire-980 Hyper-Z.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 72.0,
                        "w": 418.93,
                        "h": 196.13
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "<svg width=\"400\" height=\"200\">\n\n<text x=\"10\" y=\"130\">120</text>\n<text x=\"30\" y=\"120\">110</text>\n<text x=\"50\" y=\"110\">100</text>\n<text x=\"70\" y=\"100\">90</text>\n<text x=\"90\" y=\"90\">80</text>\n<text x=\"110\" y=\"80\">70</text>\n<text x=\"130\" y=\"70\">60</text>\n<text x=\"150\" y=\"60\">50</text>\n<text x=\"170\" y=\"50\">40</text>\n<text x=\"190\" y=\"40\">30</text>\n<text x=\"210\" y=\"30\">20</text>\n<text x=\"230\" y=\"20\">10</text>\n<text x=\"250\" y=\"10\">0</text>\n<text x=\"220\" y=\"150\">22</text>\n<text x=\"240\" y=\"150\">23</text>\n<text x=\"260\" y=\"150\">24</text>\n<text x=\"280\" y=\"150\">25</text>\n<text x=\"300\" y=\"150\">26</text>\n<text x=\"320\" y=\"150\">27</text>\n<text x=\"340\" y=\"150\">28</text>\n<text x=\"360\" y=\"150\">29</text>\n<text x=\"380\" y=\"150\">210</text>\n<text x=\"400\" y=\"150\">211</text>\n</svg>\nFigure 1: Execution time of the test code on CPU A for various values of STRIDE and MAX_ADDRESS. STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, and 8 overlap in the figure.",
                    "md": "<svg width=\"400\" height=\"200\">\n\n<text x=\"10\" y=\"130\">120</text>\n<text x=\"30\" y=\"120\">110</text>\n<text x=\"50\" y=\"110\">100</text>\n<text x=\"70\" y=\"100\">90</text>\n<text x=\"90\" y=\"90\">80</text>\n<text x=\"110\" y=\"80\">70</text>\n<text x=\"130\" y=\"70\">60</text>\n<text x=\"150\" y=\"60\">50</text>\n<text x=\"170\" y=\"50\">40</text>\n<text x=\"190\" y=\"40\">30</text>\n<text x=\"210\" y=\"30\">20</text>\n<text x=\"230\" y=\"20\">10</text>\n<text x=\"250\" y=\"10\">0</text>\n<text x=\"220\" y=\"150\">22</text>\n<text x=\"240\" y=\"150\">23</text>\n<text x=\"260\" y=\"150\">24</text>\n<text x=\"280\" y=\"150\">25</text>\n<text x=\"300\" y=\"150\">26</text>\n<text x=\"320\" y=\"150\">27</text>\n<text x=\"340\" y=\"150\">28</text>\n<text x=\"360\" y=\"150\">29</text>\n<text x=\"380\" y=\"150\">210</text>\n<text x=\"400\" y=\"150\">211</text>\n</svg>\nFigure 1: Execution time of the test code on CPU A for various values of STRIDE and MAX_ADDRESS. STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, and 8 overlap in the figure.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 106.75,
                        "w": 451.51,
                        "h": 410.73
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Table 1: Fill in the following table for CPU A (Dragonfire-980 Hyper-Z)",
                    "md": "# Table 1: Fill in the following table for CPU A (Dragonfire-980 Hyper-Z)",
                    "rows": null,
                    "bBox": {
                        "x": 93.76,
                        "y": 118.13,
                        "w": 397.17,
                        "h": 253.01
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| System Parameter         | CPU A: Dragonfire-980 Hyper-Z | L1  | L2  | L3       | DRAM |\n| ------------------------ | ----------------------------- | --- | --- | -------- | ---- |\n| Cache Line Size (B)      | N/A                           | N/A | N/A | N/A OR X |      |\n| Cache Associativity      | 2                             | X   | X   | X        |      |\n| Total Cache Size (B)     | 16                            | X   | X   | X        |      |\n| Access Latency from (ns) | 1                             | 20  | X   | X        | 100  |",
                    "rows": [
                        [
                            "System Parameter",
                            "CPU A: Dragonfire-980 Hyper-Z",
                            "L1",
                            "L2",
                            "L3",
                            "DRAM"
                        ],
                        [
                            "Cache Line Size (B)",
                            "N/A",
                            "N/A",
                            "N/A",
                            "N/A OR X",
                            ""
                        ],
                        [
                            "Cache Associativity",
                            "2",
                            "X",
                            "X",
                            "X",
                            ""
                        ],
                        [
                            "Total Cache Size (B)",
                            "16",
                            "X",
                            "X",
                            "X",
                            ""
                        ],
                        [
                            "Access Latency from (ns)",
                            "1",
                            "20",
                            "X",
                            "X",
                            "100"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.51,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1 DRAM access latency means the latency of fetching the data from DRAM to L3, not the latency of bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to the CPU from the L1 cache.\n\nFinal Exam Page 31 of 40",
                    "md": "1 DRAM access latency means the latency of fetching the data from DRAM to L3, not the latency of bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to the CPU from the L1 cache.\n\nFinal Exam Page 31 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 131.74,
                        "w": 451.42,
                        "h": 662.93
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 33,
            "text": " Initials: Solutions                    Design of Digital Circuits                    August 18th, 2018\n(b) [25 points] Fill in the blanks for Peregrine G-Class XTreme.\n     150\n     140\n     130                                                                                     STRIDE\n     120                                                                                        1\n     110                                                                                        2\n     100                                                                                        4\n  (ns) 90                                                                                       8\n       80                                                                                       16\n  time                                                                                          32\n       70                                                                                       64\n       60                                                                                       128\n       50                                  16    32                                             256\n       40                             8                                                         512\n       30                                                                                       1024\n       20                       4    64   128   256   512  1024\n       10           1     2\n       0    22   23    24    25   26    27    28    29   210   211  212   213   214  215\n                                            MAX_ADDRESS\n Figure 2: Execution time of the test code on CPU B for various values of STRIDE and MAX_ADDRESS.\n STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, 8,\n 16, and 32 overlap in the figure.\n               Table 2: Fill in the following table for CPU B (Peregrine G-Class XTreme)\n  System Parameter                          CPU B: Peregrine G-Class XTreme\n                                  L1                  L2                  L3                 DRAM\n  Cache Line Size (B)            N/A                 N/A                 N/A               N/A OR X\n  Cache Associativity             1                   4                   X                   X\n  Total Cache Size (B)            32                 512                  X                   X\n  Access Latency (ns) 1           10                  40                  X                  100\n  1 DRAM access latency means the latency of fetching the data from DRAM to L3, not        the latency of\n    bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means\n    the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to\n    the CPU from the L1 cache.\n Final Exam                                                                                Page 32 of 40",
            "md": "Initials: Solutions\n\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (b) [25 points] Fill in the blanks for Peregrine G-Class XTreme.\n\n|           | 150 | 140 | 130 | 120 | 110 | 100 | 90 | 80  | 70  | 60  | 50   | 40  | 30  | 20  | 10 | 0 |\n| --------- | --- | --- | --- | --- | --- | --- | -- | --- | --- | --- | ---- | --- | --- | --- | -- | - |\n| STRIDE    | 1   | 2   | 4   | 8   | 16  | 32  | 64 | 128 | 256 | 512 | 1024 |     |     |     |    |   |\n| time (ns) | 22  | 23  | 24  | 25  | 26  | 27  | 28 | 29  | 210 | 211 | 212  | 213 | 214 | 215 |    |   |\n\nFigure 2: Execution time of the test code on CPU B for various values of STRIDE and MAX_ADDRESS. STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, 8, 16, and 32 overlap in the figure.\n\n# Table 2: Fill in the following table for CPU B (Peregrine G-Class XTreme)\n\n| System Parameter     | CPU B: Peregrine G-Class XTreme | L1  | L2  | L3       | DRAM |\n| -------------------- | ------------------------------- | --- | --- | -------- | ---- |\n| Cache Line Size (B)  | N/A                             | N/A | N/A | N/A OR X |      |\n| Cache Associativity  | 1                               | 4   | X   | X        |      |\n| Total Cache Size (B) | 32                              | 512 | X   | X        |      |\n| Access Latency (ns)  | 1                               | 10  | 40  | X        | 100  |\n\n1 DRAM access latency means the latency of fetching the data from DRAM to L3, not the latency of bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to the CPU from the L1 cache.\n\nFinal Exam",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 93.76,
                        "y": 43.11,
                        "w": 429.6,
                        "h": 423.67
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [25 points] Fill in the blanks for Peregrine G-Class XTreme.",
                    "md": "# (b) [25 points] Fill in the blanks for Peregrine G-Class XTreme.",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 72.0,
                        "w": 419.48,
                        "h": 459.44
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|           | 150 | 140 | 130 | 120 | 110 | 100 | 90 | 80  | 70  | 60  | 50   | 40  | 30  | 20  | 10 | 0 |\n| --------- | --- | --- | --- | --- | --- | --- | -- | --- | --- | --- | ---- | --- | --- | --- | -- | - |\n| STRIDE    | 1   | 2   | 4   | 8   | 16  | 32  | 64 | 128 | 256 | 512 | 1024 |     |     |     |    |   |\n| time (ns) | 22  | 23  | 24  | 25  | 26  | 27  | 28 | 29  | 210 | 211 | 212  | 213 | 214 | 215 |    |   |",
                    "rows": [
                        [
                            "",
                            "150",
                            "140",
                            "130",
                            "120",
                            "110",
                            "100",
                            "90",
                            "80",
                            "70",
                            "60",
                            "50",
                            "40",
                            "30",
                            "20",
                            "10",
                            "0"
                        ],
                        [
                            "STRIDE",
                            "1",
                            "2",
                            "4",
                            "8",
                            "16",
                            "32",
                            "64",
                            "128",
                            "256",
                            "512",
                            "1024",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "time (ns)",
                            "22",
                            "23",
                            "24",
                            "25",
                            "26",
                            "27",
                            "28",
                            "29",
                            "210",
                            "211",
                            "212",
                            "213",
                            "214",
                            "215",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.08,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Figure 2: Execution time of the test code on CPU B for various values of STRIDE and MAX_ADDRESS. STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, 8, 16, and 32 overlap in the figure.",
                    "md": "Figure 2: Execution time of the test code on CPU B for various values of STRIDE and MAX_ADDRESS. STRIDE values are labeled on curves themselves for clarity. Note that the curves for strides 1, 2, 4, 8, 16, and 32 overlap in the figure.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 134.29,
                        "w": 451.53,
                        "h": 397.15
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Table 2: Fill in the following table for CPU B (Peregrine G-Class XTreme)",
                    "md": "# Table 2: Fill in the following table for CPU B (Peregrine G-Class XTreme)",
                    "rows": null,
                    "bBox": {
                        "x": 133.7,
                        "y": 154.72,
                        "w": 357.23,
                        "h": 376.71
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| System Parameter     | CPU B: Peregrine G-Class XTreme | L1  | L2  | L3       | DRAM |\n| -------------------- | ------------------------------- | --- | --- | -------- | ---- |\n| Cache Line Size (B)  | N/A                             | N/A | N/A | N/A OR X |      |\n| Cache Associativity  | 1                               | 4   | X   | X        |      |\n| Total Cache Size (B) | 32                              | 512 | X   | X        |      |\n| Access Latency (ns)  | 1                               | 10  | 40  | X        | 100  |",
                    "rows": [
                        [
                            "System Parameter",
                            "CPU B: Peregrine G-Class XTreme",
                            "L1",
                            "L2",
                            "L3",
                            "DRAM"
                        ],
                        [
                            "Cache Line Size (B)",
                            "N/A",
                            "N/A",
                            "N/A",
                            "N/A OR X",
                            ""
                        ],
                        [
                            "Cache Associativity",
                            "1",
                            "4",
                            "X",
                            "X",
                            ""
                        ],
                        [
                            "Total Cache Size (B)",
                            "32",
                            "512",
                            "X",
                            "X",
                            ""
                        ],
                        [
                            "Access Latency (ns)",
                            "1",
                            "10",
                            "40",
                            "X",
                            "100"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.08,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1 DRAM access latency means the latency of fetching the data from DRAM to L3, not the latency of bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to the CPU from the L1 cache.\n\nFinal Exam",
                    "md": "1 DRAM access latency means the latency of fetching the data from DRAM to L3, not the latency of bringing the data from the DRAM all the way down to the CPU. Similarly, L3 access latency means the latency of fetching the data from L3 to L2. L1 access latency is the latency to bring the data to the CPU from the L1 cache.\n\nFinal Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 144.5,
                        "w": 451.42,
                        "h": 650.16
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 34,
            "text": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018\n11     Dataflow Meets Logic               [35 points]\nWe often use the \u201caddition node\u201d:\n                                               a      b\n                                                  +\n                                                  c\n    to represent the addition of two input tokens. If we think of the tokens as binary numbers, we can\nmodel a simple logic circuit using dataflow graphs.1 Note that a token can be used as an input to only\none  node. If the same value is needed by more than one node, it first should be replicated using one or\nmore copy nodes, and then each copied token can be supplied to one node only.\n                                 a      b  a     b  a      b     a\u2081\n                                  1     1   1    1   1     1\n                                   AND       OR       XOR      COPY\n                                    c\u00b9        c\u00b9       c\u00b9      a 1 1 a\n               Figure 3: Dataflow nodes of basic bitwise operations allowed in Part (a).\n(a) [5 points] Implement the single-bit binary addition of two \u201c1-bit\u201d input tokens a and b as a dataflow\n    graph using only  2-input {AND, OR, XOR} nodes and COPY nodes if necessary (illustrated in\n    Figure 3). Fill in the internal implementation below, where inputs and outputs (labeled with their\n    corresponding bit-widths) have been provided:\n                                       a                        b\n                                        1                        1\n                                            1                   1\n                                     COPY                COPY\n                                       1     1             1     1\n                               1              1            1               1\n                                  AND                          XOR\n                                        1                           1\n                                       1                           1\n                               sum[1]                             sum[0]\n   1Note: this is not an accurate electrical model of a circuit. Instead, the dataflow analogy is best thought of in terms of\nthe desired flow of information rather than physical phenomena.\nFinal Exam                                                                               Page 33 of 40",
            "md": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018\n# 11     Dataflow Meets Logic               [35 points]\n\nWe often use the \u201caddition node\u201d:\n\na      b\n+\nc\n\nto represent the addition of two input tokens. If we think of the tokens as binary numbers, we can model a simple logic circuit using dataflow graphs.1 Note that a token can be used as an input to only one node. If the same value is needed by more than one node, it first should be replicated using one or more copy nodes, and then each copied token can be supplied to one node only.\n\na      b  a     b  a      b     a\u2081\n1     1   1    1   1     1\nAND       OR       XOR      COPY\nc\u00b9        c\u00b9       c\u00b9      a 1 1 a\n\nFigure 3: Dataflow nodes of basic bitwise operations allowed in Part (a).\n\n# (a) [5 points] Implement the single-bit binary addition of two \u201c1-bit\u201d input tokens a and b as a dataflow graph using only  2-input {AND, OR, XOR} nodes and COPY nodes if necessary (illustrated in Figure 3). Fill in the internal implementation below, where inputs and outputs (labeled with their corresponding bit-widths) have been provided:\n\na                        b\n1                        1\n1                   1\nCOPY                COPY\n1     1             1     1\n1              1            1               1\nAND                          XOR\n1                           1\n1                           1\nsum[1]                             sum[0]\n\n1Note: this is not an accurate electrical model of a circuit. Instead, the dataflow analogy is best thought of in terms of the desired flow of information rather than physical phenomena.\n\nFinal Exam                                                                               Page 33 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018",
                    "md": "Initials: Solutions                   Design of Digital Circuits                    August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.36,
                        "h": 654.3
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "11     Dataflow Meets Logic               [35 points]",
                    "md": "# 11     Dataflow Meets Logic               [35 points]",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 338.8,
                        "h": 629.8
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "We often use the \u201caddition node\u201d:\n\na      b\n+\nc\n\nto represent the addition of two input tokens. If we think of the tokens as binary numbers, we can model a simple logic circuit using dataflow graphs.1 Note that a token can be used as an input to only one node. If the same value is needed by more than one node, it first should be replicated using one or more copy nodes, and then each copied token can be supplied to one node only.\n\na      b  a     b  a      b     a\u2081\n1     1   1    1   1     1\nAND       OR       XOR      COPY\nc\u00b9        c\u00b9       c\u00b9      a 1 1 a\n\nFigure 3: Dataflow nodes of basic bitwise operations allowed in Part (a).",
                    "md": "We often use the \u201caddition node\u201d:\n\na      b\n+\nc\n\nto represent the addition of two input tokens. If we think of the tokens as binary numbers, we can model a simple logic circuit using dataflow graphs.1 Note that a token can be used as an input to only one node. If the same value is needed by more than one node, it first should be replicated using one or more copy nodes, and then each copied token can be supplied to one node only.\n\na      b  a     b  a      b     a\u2081\n1     1   1    1   1     1\nAND       OR       XOR      COPY\nc\u00b9        c\u00b9       c\u00b9      a 1 1 a\n\nFigure 3: Dataflow nodes of basic bitwise operations allowed in Part (a).",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.74,
                        "h": 629.8
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [5 points] Implement the single-bit binary addition of two \u201c1-bit\u201d input tokens a and b as a dataflow graph using only  2-input {AND, OR, XOR} nodes and COPY nodes if necessary (illustrated in Figure 3). Fill in the internal implementation below, where inputs and outputs (labeled with their corresponding bit-widths) have been provided:",
                    "md": "# (a) [5 points] Implement the single-bit binary addition of two \u201c1-bit\u201d input tokens a and b as a dataflow graph using only  2-input {AND, OR, XOR} nodes and COPY nodes if necessary (illustrated in Figure 3). Fill in the internal implementation below, where inputs and outputs (labeled with their corresponding bit-widths) have been provided:",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 110.65,
                        "w": 451.77,
                        "h": 586.76
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "a                        b\n1                        1\n1                   1\nCOPY                COPY\n1     1             1     1\n1              1            1               1\nAND                          XOR\n1                           1\n1                           1\nsum[1]                             sum[0]\n\n1Note: this is not an accurate electrical model of a circuit. Instead, the dataflow analogy is best thought of in terms of the desired flow of information rather than physical phenomena.\n\nFinal Exam                                                                               Page 33 of 40",
                    "md": "a                        b\n1                        1\n1                   1\nCOPY                COPY\n1     1             1     1\n1              1            1               1\nAND                          XOR\n1                           1\n1                           1\nsum[1]                             sum[0]\n\n1Note: this is not an accurate electrical model of a circuit. Instead, the dataflow analogy is best thought of in terms of the desired flow of information rather than physical phenomena.\n\nFinal Exam                                                                               Page 33 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 67.62,
                        "w": 451.46,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 35,
            "text": "Initials: Solutions                      Design of Digital Circuits                August 18th, 2018\n    (b) [5 points] You may recognize the node we designed in part (a) as a model for a so-called \u201chalf-\n    adder (HA)\u201d, which is not very useful by itself since it is only useful for adding 1-bit input tokens. In\n    order to extend this design to perform binary addition of 2-bit input tokens a[1:0] and b[1:0],\n    the sum[1] token from half-adding a[0] and b[0] will have to act as an input token for another\n    half-adder node used for adding a[1] and b[1].     This results in a 3-input adder called a \u201cfull-\n    adder (FA)\u201d.\n    Fortunately, we can implement a full-adder (FA) using half-adders (HA) (i.e., the node we designed in\n    part (a). Implement the full-adder using a minimum number of half-adders and at most 1 additional\n    2-input {AND, OR, XOR} node.\n                                      a            b 1          c\n                                       1                         1\n                                     1            1\n                                         HA                 1             1\n                                        1      1                 HA\n                                   1                1           1     1\n                                        OR\n                                             1\n                                     1                            1\n                             sum[1]                              sum[0]\nFinal Exam                                                                             Page 34 of 40",
            "md": "Initials: Solutions                      Design of Digital Circuits                August 18th, 2018\n\n(b) [5 points] You may recognize the node we designed in part (a) as a model for a so-called \u201chalf-adder (HA)\u201d, which is not very useful by itself since it is only useful for adding 1-bit input tokens. In order to extend this design to perform binary addition of 2-bit input tokens a[1:0] and b[1:0], the sum[1] token from half-adding a[0] and b[0] will have to act as an input token for another half-adder node used for adding a[1] and b[1]. This results in a 3-input adder called a \u201cfull-adder (FA)\u201d. Fortunately, we can implement a full-adder (FA) using half-adders (HA) (i.e., the node we designed in part (a). Implement the full-adder using a minimum number of half-adders and at most 1 additional 2-input {AND, OR, XOR} node.\n\n| a | b | 1 | c |\n| - | - | - | - |\n|   |   | 1 |   |\n|   |   | 1 |   |\n\n| HA | 1 | 1  |   |   |   |\n| -- | - | -- | - | - | - |\n| 1  | 1 | HA |   |   |   |\n|    |   | 1  | 1 | 1 | 1 |\n\nOR1\n\nsum[1]                              sum[0]\n\nFinal Exam                                                                             Page 34 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                      Design of Digital Circuits                August 18th, 2018\n\n(b) [5 points] You may recognize the node we designed in part (a) as a model for a so-called \u201chalf-adder (HA)\u201d, which is not very useful by itself since it is only useful for adding 1-bit input tokens. In order to extend this design to perform binary addition of 2-bit input tokens a[1:0] and b[1:0], the sum[1] token from half-adding a[0] and b[0] will have to act as an input token for another half-adder node used for adding a[1] and b[1]. This results in a 3-input adder called a \u201cfull-adder (FA)\u201d. Fortunately, we can implement a full-adder (FA) using half-adders (HA) (i.e., the node we designed in part (a). Implement the full-adder using a minimum number of half-adders and at most 1 additional 2-input {AND, OR, XOR} node.",
                    "md": "Initials: Solutions                      Design of Digital Circuits                August 18th, 2018\n\n(b) [5 points] You may recognize the node we designed in part (a) as a model for a so-called \u201chalf-adder (HA)\u201d, which is not very useful by itself since it is only useful for adding 1-bit input tokens. In order to extend this design to perform binary addition of 2-bit input tokens a[1:0] and b[1:0], the sum[1] token from half-adding a[0] and b[0] will have to act as an input token for another half-adder node used for adding a[1] and b[1]. This results in a 3-input adder called a \u201cfull-adder (FA)\u201d. Fortunately, we can implement a full-adder (FA) using half-adders (HA) (i.e., the node we designed in part (a). Implement the full-adder using a minimum number of half-adders and at most 1 additional 2-input {AND, OR, XOR} node.",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.11,
                        "h": 490.52
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| a | b | 1 | c |\n| - | - | - | - |\n|   |   | 1 |   |\n|   |   | 1 |   |",
                    "rows": [
                        [
                            "a",
                            "b",
                            "1",
                            "c"
                        ],
                        [
                            "",
                            "",
                            "1",
                            ""
                        ],
                        [
                            "",
                            "",
                            "1",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.11,
                        "h": 751.56
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| HA | 1 | 1  |   |   |   |\n| -- | - | -- | - | - | - |\n| 1  | 1 | HA |   |   |   |\n|    |   | 1  | 1 | 1 | 1 |",
                    "rows": [
                        [
                            "HA",
                            "1",
                            "1",
                            "",
                            "",
                            ""
                        ],
                        [
                            "1",
                            "1",
                            "HA",
                            "",
                            "",
                            ""
                        ],
                        [
                            "",
                            "",
                            "1",
                            "1",
                            "1",
                            "1"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.11,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "OR1\n\nsum[1]                              sum[0]\n\nFinal Exam                                                                             Page 34 of 40",
                    "md": "OR1\n\nsum[1]                              sum[0]\n\nFinal Exam                                                                             Page 34 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 202.88,
                        "w": 451.32,
                        "h": 591.79
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 36,
            "text": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n (c) [5 points] The full-adder (FA) is a versatile design that can be used to implement n-bit addition.\n    Show how we might use it to implement 2-bit binary addition of two input tokens a[1:0] and\n    b[1:0]. Use only a minimum number of full-adders (i.e., the dataflow node you designed in Part\n    2). Hint: you may use constant input tokens if necessary.\n                                  a[0]                     b[1]\n                        a[1]          1                       1        b[0]\n                            1                                           1\n                                                                    0\n                                 1       1    1       1       1    1\n                                     FA                   FA\n                                     1     1              1     1\n                                     1                          1\n                             sum[2]                 1          sum[0]\n                                              sum[1]\nFinal Exam                                                                           Page 35 of 40",
            "md": "\nInitials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n\n(c) [5 points] The full-adder (FA) is a versatile design that can be used to implement n-bit addition.\n\nShow how we might use it to implement 2-bit binary addition of two input tokens a[1:0] and b[1:0]. Use only a minimum number of full-adders (i.e., the dataflow node you designed in Part 2). Hint: you may use constant input tokens if necessary.\n\n|         | a\\[0]   | b\\[1]   |       |    |   |   |   |\n| ------- | ------- | ------- | ----- | -- | - | - | - |\n| a\\[1]   | 1       | 1       | b\\[0] |    |   |   |   |\n|         |         | 1       |       |    | 1 |   |   |\n|         |         | 0       |       |    |   |   |   |\n|         |         | 1       | 1     | 1  | 1 | 1 | 1 |\n| FA      |         | 1       | 1     | FA |   |   |   |\n| 1       | 1       | 1       |       |    |   |   |   |\n| 1       |         | 1       |       |    |   |   |   |\n| sum\\[2] | 1       | sum\\[0] |       |    |   |   |   |\n|         | sum\\[1] |         |       |    |   |   |   |\n\nFinal Exam                                                                           Page 35 of 40\n\n\n",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n\n(c) [5 points] The full-adder (FA) is a versatile design that can be used to implement n-bit addition.\n\nShow how we might use it to implement 2-bit binary addition of two input tokens a[1:0] and b[1:0]. Use only a minimum number of full-adders (i.e., the dataflow node you designed in Part 2). Hint: you may use constant input tokens if necessary.",
                    "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n\n(c) [5 points] The full-adder (FA) is a versatile design that can be used to implement n-bit addition.\n\nShow how we might use it to implement 2-bit binary addition of two input tokens a[1:0] and b[1:0]. Use only a minimum number of full-adders (i.e., the dataflow node you designed in Part 2). Hint: you may use constant input tokens if necessary.",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.54,
                        "h": 406.38
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|         | a\\[0]   | b\\[1]   |       |    |   |   |   |\n| ------- | ------- | ------- | ----- | -- | - | - | - |\n| a\\[1]   | 1       | 1       | b\\[0] |    |   |   |   |\n|         |         | 1       |       |    | 1 |   |   |\n|         |         | 0       |       |    |   |   |   |\n|         |         | 1       | 1     | 1  | 1 | 1 | 1 |\n| FA      |         | 1       | 1     | FA |   |   |   |\n| 1       | 1       | 1       |       |    |   |   |   |\n| 1       |         | 1       |       |    |   |   |   |\n| sum\\[2] | 1       | sum\\[0] |       |    |   |   |   |\n|         | sum\\[1] |         |       |    |   |   |   |",
                    "rows": [
                        [
                            "",
                            "a[0]",
                            "b[1]",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "a[1]",
                            "1",
                            "1",
                            "b[0]",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "",
                            "",
                            "1",
                            "",
                            "",
                            "1",
                            "",
                            ""
                        ],
                        [
                            "",
                            "",
                            "0",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "",
                            "",
                            "1",
                            "1",
                            "1",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "FA",
                            "",
                            "1",
                            "1",
                            "FA",
                            "",
                            "",
                            ""
                        ],
                        [
                            "1",
                            "1",
                            "1",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "1",
                            "",
                            "1",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "sum[2]",
                            "1",
                            "sum[0]",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "",
                            "sum[1]",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 451.54,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                                           Page 35 of 40",
                    "md": "Final Exam                                                                           Page 35 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 216.96,
                        "w": 451.32,
                        "h": 577.71
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 37,
            "text": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n(d) [5 points] Interestingly, the full-adder can also be used to add four 1-bit input tokens. This is a\n   natural extension of the full-adder in the same way we extended the half-adder to create the full-\n   adder itself (in part (b)). Implement the 4-input node below using only a minimum    number of\n   full-adders (FA) (i.e., the dataflow node you designed in part (b)). Hint: you may use constant input\n   tokens if necessary.\n                                     b                        c\n                                      1                       1\n                      a                       1        1    1                d\n                         1                                                  1\n                                                   FA\n                                                  1     1               0\n                              0                        1       1    1\n                                   1       1    1          FA\n                                       FA                 1      1\n                                       1     1\n                                     1                          1\n                             sum[2]                 1          sum[0]\n                                             sum[1]\n(e) [15 points] As it turns out, any n \u2265 3 1-bit input binary adders can be implemented purely using\n   full-adders. Fill in the table below for the minimum number of required full adders to implement an\n   n-input 1-bit adder.\n                               n   # required full-adders\n                               3   1\n                               4   3\n                               5   3\n                               6   4\n                               7   4\n                               8   7\nFinal Exam                                                                           Page 36 of 40",
            "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n(d) [5 points] Interestingly, the full-adder can also be used to add four 1-bit input tokens. This is a natural extension of the full-adder in the same way we extended the half-adder to create the full-adder itself (in part (b)). Implement the 4-input node below using only a minimum number of full-adders (FA) (i.e., the dataflow node you designed in part (b)). Hint: you may use constant input tokens if necessary.\n\n|         | b       | c       |\n| ------- | ------- | ------- |\n| a       | 1       | 1       |\n|         | 1       | 1       |\n| d       | 1       |         |\n|         | 1       | 1       |\n|         | FA      |         |\n| 0       | 1       | 1       |\n|         | 1       | 1       |\n| 1       | 1       | 1       |\n|         | FA      |         |\n|         | 1       | 1       |\n|         | FA      |         |\n|         | 1       | 1       |\n|         | 1       |         |\n| sum\\[2] | 1       | sum\\[0] |\n|         | sum\\[1] |         |\n\n(e) [15 points] As it turns out, any n \u2265 3 1-bit input binary adders can be implemented purely using full-adders. Fill in the table below for the minimum number of required full adders to implement an n-input 1-bit adder.\n\n| n | # required full-adders |\n| - | ---------------------- |\n| 3 | 1                      |\n| 4 | 3                      |\n| 5 | 3                      |\n| 6 | 4                      |\n| 7 | 4                      |\n| 8 | 7                      |\n\nFinal Exam                                                                           Page 36 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n(d) [5 points] Interestingly, the full-adder can also be used to add four 1-bit input tokens. This is a natural extension of the full-adder in the same way we extended the half-adder to create the full-adder itself (in part (b)). Implement the 4-input node below using only a minimum number of full-adders (FA) (i.e., the dataflow node you designed in part (b)). Hint: you may use constant input tokens if necessary.",
                    "md": "Initials: Solutions                  Design of Digital Circuits                 August 18th, 2018\n\n(d) [5 points] Interestingly, the full-adder can also be used to add four 1-bit input tokens. This is a natural extension of the full-adder in the same way we extended the half-adder to create the full-adder itself (in part (b)). Implement the 4-input node below using only a minimum number of full-adders (FA) (i.e., the dataflow node you designed in part (b)). Hint: you may use constant input tokens if necessary.",
                    "rows": null,
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 451.91,
                        "h": 672.83
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|         | b       | c       |\n| ------- | ------- | ------- |\n| a       | 1       | 1       |\n|         | 1       | 1       |\n| d       | 1       |         |\n|         | 1       | 1       |\n|         | FA      |         |\n| 0       | 1       | 1       |\n|         | 1       | 1       |\n| 1       | 1       | 1       |\n|         | FA      |         |\n|         | 1       | 1       |\n|         | FA      |         |\n|         | 1       | 1       |\n|         | 1       |         |\n| sum\\[2] | 1       | sum\\[0] |\n|         | sum\\[1] |         |",
                    "rows": [
                        [
                            "",
                            "b",
                            "c"
                        ],
                        [
                            "a",
                            "1",
                            "1"
                        ],
                        [
                            "",
                            "1",
                            "1"
                        ],
                        [
                            "d",
                            "1",
                            ""
                        ],
                        [
                            "",
                            "1",
                            "1"
                        ],
                        [
                            "",
                            "FA",
                            ""
                        ],
                        [
                            "0",
                            "1",
                            "1"
                        ],
                        [
                            "",
                            "1",
                            "1"
                        ],
                        [
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "",
                            "FA",
                            ""
                        ],
                        [
                            "",
                            "1",
                            "1"
                        ],
                        [
                            "",
                            "FA",
                            ""
                        ],
                        [
                            "",
                            "1",
                            "1"
                        ],
                        [
                            "",
                            "1",
                            ""
                        ],
                        [
                            "sum[2]",
                            "1",
                            "sum[0]"
                        ],
                        [
                            "",
                            "sum[1]",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.31,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "(e) [15 points] As it turns out, any n \u2265 3 1-bit input binary adders can be implemented purely using full-adders. Fill in the table below for the minimum number of required full adders to implement an n-input 1-bit adder.",
                    "md": "(e) [15 points] As it turns out, any n \u2265 3 1-bit input binary adders can be implemented purely using full-adders. Fill in the table below for the minimum number of required full adders to implement an n-input 1-bit adder.",
                    "rows": null,
                    "bBox": {
                        "x": 72.55,
                        "y": 95.91,
                        "w": 451.21,
                        "h": 547.11
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| n | # required full-adders |\n| - | ---------------------- |\n| 3 | 1                      |\n| 4 | 3                      |\n| 5 | 3                      |\n| 6 | 4                      |\n| 7 | 4                      |\n| 8 | 7                      |",
                    "rows": [
                        [
                            "n",
                            "# required full-adders"
                        ],
                        [
                            "3",
                            "1"
                        ],
                        [
                            "4",
                            "3"
                        ],
                        [
                            "5",
                            "3"
                        ],
                        [
                            "6",
                            "4"
                        ],
                        [
                            "7",
                            "4"
                        ],
                        [
                            "8",
                            "7"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 452.31,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                                           Page 36 of 40",
                    "md": "Final Exam                                                                           Page 36 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 191.17,
                        "w": 451.32,
                        "h": 603.5
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 38,
            "text": "    Initials: Solutions                 Design of Digital Circuits                 August 18th, 2018\n    12    BONUS: Branch Prediction                   [40 points]\n    Assume a processor that implements an ISA with eight registers (R0-R7). In this ISA, the main memory\n    is byte-addressable and each word contains 4 bytes. The processor employs a branch predictor. The ISA\n    implements the instructions given in the following table:\n     Instructions       Description\n     la Ri, Address     load the Addres s into Ri\n     move Ri, Rj        Ri \u2190 Rj\n     move Ri, (Rj )     Ri \u2190 Memory[Rj ]\n     move (Ri), Rj      Memory[Ri] \u2190 Rj\n     li Ri, Imm         Ri \u2190 Imm\n     add Ri, Rj , Rk    Ri \u2190 Rj + Rk\n     addi Ri, Rj , Imm  Ri \u2190 Rj + Imm\n     cmp Ri, Rj         Compare: Set sign flag, if Ri < Rj ; set zero flag, if Ri = Rj\n     cmp Ri, (Rj )      Compare: Set sign flag, if Ri < Memory[Rj ]; set zero flag, if Ri = Memory[Rj ]\n     cmpi Ri, Imm       Compare: Set sign flag, if Ri < Imm; set zero flag, if Ri = Imm.\n     jg label           Jump to the target address if both of sign and zero flags are zero.\n     jnz label          Jump to the target address if zero flag is zero.\n     halt               Stop executing instructions.\n    The processor executes the following program. Answer the questions below related to the accuracy of\n    the branch predictors that the processor can potentially implement.\n1           la R0,  Array\n2           move R6,  R0\n3           li R1,  4\n4           move R5,  R1\n5           move R7,  R1\n6           move R2,  R0\n7           addi R2,  R2,  4\n8   Loop:\n9           move R3,  (R2)\n10          cmp R3,  (R0)\n11          jg Next_Iteration\n12          move R4,  (R0)\n13          move (R0), R3\n14          move (R2), R4\n15  Next_Iteration:\n16          addi R0,  R0,  4\n17          addi R2,  R2,  4\n18          addi R1,  R1,  -1\n19          cmpi R1,  0\n20          jnz Loop\n21          move R1,  R7\n22          addi R5,  R5,  -1\n23          move R0,  R6\n24          move R2,  R0\n25          addi R2,  R2,  4\n26          cmpi R5,  0\n27          jnz Loop\n28          halt\n29  .data\n30  Array:  word 5, 20,  1, -5,  34\n    Final Exam                                                                          Page 37 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# 12 BONUS: Branch Prediction [40 points]\n\nAssume a processor that implements an ISA with eight registers (R0-R7). In this ISA, the main memory is byte-addressable and each word contains 4 bytes. The processor employs a branch predictor. The ISA implements the instructions given in the following table:\n\n| Instructions     | Description                                                                     |\n| ---------------- | ------------------------------------------------------------------------------- |\n| la Ri, Address   | load the Address into Ri                                                        |\n| move Ri, Rj      | Ri \u2190 Rj                                                                         |\n| move Ri, (Rj)    | Ri \u2190 Memory\\[Rj]                                                                |\n| move (Ri), Rj    | Memory\\[Ri] \u2190 Rj                                                                |\n| li Ri, Imm       | Ri \u2190 Imm                                                                        |\n| add Ri, Rj, Rk   | Ri \u2190 Rj + Rk                                                                    |\n| addi Ri, Rj, Imm | Ri \u2190 Rj + Imm                                                                   |\n| cmp Ri, Rj       | Compare: Set sign flag, if Ri < Rj; set zero flag, if Ri = Rj                   |\n| cmp Ri, (Rj)     | Compare: Set sign flag, if Ri < Memory\\[Rj]; set zero flag, if Ri = Memory\\[Rj] |\n| cmpi Ri, Imm     | Compare: Set sign flag, if Ri < Imm; set zero flag, if Ri = Imm.                |\n| jg label         | Jump to the target address if both of sign and zero flags are zero.             |\n| jnz label        | Jump to the target address if zero flag is zero.                                |\n| halt             | Stop executing instructions.                                                    |\n\nThe processor executes the following program. Answer the questions below related to the accuracy of the branch predictors that the processor can potentially implement.\n\n1           la R0,  Array\n2           move R6,  R0\n3           li R1,  4\n4           move R5,  R1\n5           move R7,  R1\n6           move R2,  R0\n7           addi R2,  R2,  4\n8   Loop:\n9           move R3,  (R2)\n10          cmp R3,  (R0)\n11          jg Next_Iteration\n12          move R4,  (R0)\n13          move (R0), R3\n14          move (R2), R4\n15  Next_Iteration:\n16          addi R0,  R0,  4\n17          addi R2,  R2,  4\n18          addi R1,  R1,  -1\n19          cmpi R1,  0\n20          jnz Loop\n21          move R1,  R7\n22          addi R5,  R5,  -1\n23          move R0,  R6\n24          move R2,  R0\n25          addi R2,  R2,  4\n26          cmpi R5,  0\n27          jnz Loop\n28          halt\n29  .data\n30  Array:  word 5, 20,  1, -5,  34\n\nFinal Exam Page 37 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 77.4,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 241.96,
                        "y": 43.11,
                        "w": 110.97,
                        "h": 10.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 55.26,
                        "y": 43.11,
                        "w": 468.1,
                        "h": 631.67
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "12 BONUS: Branch Prediction [40 points]",
                    "md": "# 12 BONUS: Branch Prediction [40 points]",
                    "rows": null,
                    "bBox": {
                        "x": 55.26,
                        "y": 67.62,
                        "w": 298.48,
                        "h": 607.16
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Assume a processor that implements an ISA with eight registers (R0-R7). In this ISA, the main memory is byte-addressable and each word contains 4 bytes. The processor employs a branch predictor. The ISA implements the instructions given in the following table:",
                    "md": "Assume a processor that implements an ISA with eight registers (R0-R7). In this ISA, the main memory is byte-addressable and each word contains 4 bytes. The processor employs a branch predictor. The ISA implements the instructions given in the following table:",
                    "rows": null,
                    "bBox": {
                        "x": 58.65,
                        "y": 93.82,
                        "w": 465.02,
                        "h": 580.96
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Instructions     | Description                                                                     |\n| ---------------- | ------------------------------------------------------------------------------- |\n| la Ri, Address   | load the Address into Ri                                                        |\n| move Ri, Rj      | Ri \u2190 Rj                                                                         |\n| move Ri, (Rj)    | Ri \u2190 Memory\\[Rj]                                                                |\n| move (Ri), Rj    | Memory\\[Ri] \u2190 Rj                                                                |\n| li Ri, Imm       | Ri \u2190 Imm                                                                        |\n| add Ri, Rj, Rk   | Ri \u2190 Rj + Rk                                                                    |\n| addi Ri, Rj, Imm | Ri \u2190 Rj + Imm                                                                   |\n| cmp Ri, Rj       | Compare: Set sign flag, if Ri < Rj; set zero flag, if Ri = Rj                   |\n| cmp Ri, (Rj)     | Compare: Set sign flag, if Ri < Memory\\[Rj]; set zero flag, if Ri = Memory\\[Rj] |\n| cmpi Ri, Imm     | Compare: Set sign flag, if Ri < Imm; set zero flag, if Ri = Imm.                |\n| jg label         | Jump to the target address if both of sign and zero flags are zero.             |\n| jnz label        | Jump to the target address if zero flag is zero.                                |\n| halt             | Stop executing instructions.                                                    |",
                    "rows": [
                        [
                            "Instructions",
                            "Description"
                        ],
                        [
                            "la Ri, Address",
                            "load the Address into Ri"
                        ],
                        [
                            "move Ri, Rj",
                            "Ri \u2190 Rj"
                        ],
                        [
                            "move Ri, (Rj)",
                            "Ri \u2190 Memory[Rj]"
                        ],
                        [
                            "move (Ri), Rj",
                            "Memory[Ri] \u2190 Rj"
                        ],
                        [
                            "li Ri, Imm",
                            "Ri \u2190 Imm"
                        ],
                        [
                            "add Ri, Rj, Rk",
                            "Ri \u2190 Rj + Rk"
                        ],
                        [
                            "addi Ri, Rj, Imm",
                            "Ri \u2190 Rj + Imm"
                        ],
                        [
                            "cmp Ri, Rj",
                            "Compare: Set sign flag, if Ri < Rj; set zero flag, if Ri = Rj"
                        ],
                        [
                            "cmp Ri, (Rj)",
                            "Compare: Set sign flag, if Ri < Memory[Rj]; set zero flag, if Ri = Memory[Rj]"
                        ],
                        [
                            "cmpi Ri, Imm",
                            "Compare: Set sign flag, if Ri < Imm; set zero flag, if Ri = Imm."
                        ],
                        [
                            "jg label",
                            "Jump to the target address if both of sign and zero flags are zero."
                        ],
                        [
                            "jnz label",
                            "Jump to the target address if zero flag is zero."
                        ],
                        [
                            "halt",
                            "Stop executing instructions."
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 117.73,
                        "w": 441.14,
                        "h": 578.96
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "The processor executes the following program. Answer the questions below related to the accuracy of the branch predictors that the processor can potentially implement.\n\n1           la R0,  Array\n2           move R6,  R0\n3           li R1,  4\n4           move R5,  R1\n5           move R7,  R1\n6           move R2,  R0\n7           addi R2,  R2,  4\n8   Loop:\n9           move R3,  (R2)\n10          cmp R3,  (R0)\n11          jg Next_Iteration\n12          move R4,  (R0)\n13          move (R0), R3\n14          move (R2), R4\n15  Next_Iteration:\n16          addi R0,  R0,  4\n17          addi R2,  R2,  4\n18          addi R1,  R1,  -1\n19          cmpi R1,  0\n20          jnz Loop\n21          move R1,  R7\n22          addi R5,  R5,  -1\n23          move R0,  R6\n24          move R2,  R0\n25          addi R2,  R2,  4\n26          cmpi R5,  0\n27          jnz Loop\n28          halt\n29  .data\n30  Array:  word 5, 20,  1, -5,  34\n\nFinal Exam Page 37 of 40",
                    "md": "The processor executes the following program. Answer the questions below related to the accuracy of the branch predictors that the processor can potentially implement.\n\n1           la R0,  Array\n2           move R6,  R0\n3           li R1,  4\n4           move R5,  R1\n5           move R7,  R1\n6           move R2,  R0\n7           addi R2,  R2,  4\n8   Loop:\n9           move R3,  (R2)\n10          cmp R3,  (R0)\n11          jg Next_Iteration\n12          move R4,  (R0)\n13          move (R0), R3\n14          move (R2), R4\n15  Next_Iteration:\n16          addi R0,  R0,  4\n17          addi R2,  R2,  4\n18          addi R1,  R1,  -1\n19          cmpi R1,  0\n20          jnz Loop\n21          move R1,  R7\n22          addi R5,  R5,  -1\n23          move R0,  R6\n24          move R2,  R0\n25          addi R2,  R2,  4\n26          cmpi R5,  0\n27          jnz Loop\n28          halt\n29  .data\n30  Array:  word 5, 20,  1, -5,  34\n\nFinal Exam Page 37 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 55.26,
                        "y": 67.62,
                        "w": 468.06,
                        "h": 727.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 39,
            "text": "Initials: Solutions               Design of Digital Circuits               August 18th, 2018\n(a) [15 points] What would be the prediction accuracy using a global one-bit-history (last-time) branch\n    predictor shared between all the branches? The initial state of the predictor is \"taken\".\n   Answer: 19/36.\n   Note that initial values of both R1 and R5 are 4; and they change only before the branches in lines 20\n   and 27 respectively. Both branches follow the pattern of T-T-T-NT, which creates a nested loop.\n   At each iteration of the internal loop, adjacent elements (pointed by R0 and R2) are swapped, if\n   M emory[R0] \u2264   M emory[R2]. Then, both R0 and R4 are incremented by 4. So they point to the\n   next element in the next iteration.\n   Therefore, the code sorts the elements in Array in increasing order.\n   Table below shows the behavior of each branch through the code. Here T means that the corresponding\n    branch is taken at specified turn, whereas N indicates that it is not taken.\n             1   2    3   4   5          6   7  8  9  10 11  12  13   14  15   16  17  18\n    Line11   T        N       N              T        N      N        T        T\n    Line20       T        T              T      N        T       T        T        N\n    Line27                                         T                                   T\n             19  20   21  22  23         24  25 26 27 28 29  30  31   32  33   34  35  36\n    Line11   N        T       T              T        T      T        T        T\n    Line20       T        T              T      N        T       T        T        N\n    Line27                                         T                                   N\n   One-bit-history branch predictor suggests that the next branch\u2019s behavior will be the same with the\n   last one. Table below shows the predictor states, hits, and misses through the execution.\n                      1   2   3          4   5  6  7  8  9   10  11   12  13   14  15\n    Predictor State   T   T   T    N         T  N  T  T  N   T   N    T   N    T   T\n    Branch Behavior   T   T    N         T   N  T  T  N  T   N   T    N   T    T   T\n    Hit/Miss          H   H   M          M   M  M  H  M  M   M   M    M   M    H   H\n                      16  17  18         19  20 21 22 23 24  25  26   27  28   29  30\n    Predictor State   T   T    N         T   N  T  T  T  T   T   T    N   T    T   T\n    Branch Behavior   T   N   T    N         T  T  T  T  T   T   N    T   T    T   T\n    Hit/Miss          H   M   M          M   M  H  H  H  H   H   M    M   H    H   H\n                      31  32  33         34  35 36\n    Predictor State   T   T   T          T   T  N\n    Branch Behavior   T   T   T          T   N  N\n    Hit/Miss          H   H    H   H         M  H\nFinal Exam                                                                     Page 38 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (a) [15 points]\n\nWhat would be the prediction accuracy using a global one-bit-history (last-time) branch predictor shared between all the branches? The initial state of the predictor is \"taken\".\n\nAnswer: 19/36.\n\nNote that initial values of both R1 and R5 are 4; and they change only before the branches in lines 20 and 27 respectively. Both branches follow the pattern of T-T-T-NT, which creates a nested loop. At each iteration of the internal loop, adjacent elements (pointed by R0 and R2) are swapped, if Memory[R0] \u2264 Memory[R2]. Then, both R0 and R4 are incremented by 4. So they point to the next element in the next iteration. Therefore, the code sorts the elements in Array in increasing order.\n\n# Table below shows the behavior of each branch through the code.\n\n|        | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |\n| ------ | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Line11 | T  |    | N  |    | T  |    | N  |    | T  | T  |    |    |    |    |    |    |    |    |\n| Line20 | T  | T  |    | T  | N  | T  | T  | T  | N  |    |    |    |    |    |    |    |    |    |\n| Line27 |    |    |    | T  |    |    |    |    |    |    |    |    |    |    |    |    |    |    |\n|        | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |\n| Line11 | N  | T  | T  |    | T  | T  | T  | T  | T  |    |    |    |    |    |    |    |    |    |\n| Line20 | T  | T  |    | T  | N  | T  | T  | T  | N  |    |    |    |    |    |    |    |    |    |\n| Line27 |    |    |    | T  |    |    |    |    |    |    |    |    |    |    |    |    |    |    |\n\n# One-bit-history branch predictor suggests that the next branch\u2019s behavior will be the same with the last one.\n\n# Table below shows the predictor states, hits, and misses through the execution.\n\n|                 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 |   |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | - |\n| Predictor State | T  | T  | T  | N  | T  | N  | T  | T  | N  | T  | N  | T  | N  | T  | T  |   |\n| Branch Behavior | T  | T  | N  | T  | N  | T  | T  | N  | T  | N  | T  | N  | T  | T  | T  |   |\n| Hit/Miss        | H  | H  | M  | M  | M  | H  | M  | M  | M  | M  | M  | M  | M  | M  | H  | H |\n|                 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 |   |\n| Predictor State | T  | T  | N  | T  | N  | T  | T  | T  | T  | T  | T  | N  | T  | T  | T  |   |\n| Branch Behavior | T  | N  | T  | N  | T  | T  | T  | T  | T  | T  | N  | T  | T  | T  | T  |   |\n| Hit/Miss        | H  | M  | M  | M  | M  | H  | H  | H  | H  | H  | M  | M  | H  | H  | H  |   |\n\nFinal Exam                                                                     Page 38 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 442.66,
                        "h": 524.31
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 134.96,
                        "y": 43.11,
                        "w": 379.7,
                        "h": 524.31
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 135.1,
                        "y": 43.11,
                        "w": 388.26,
                        "h": 536.27
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) [15 points]",
                    "md": "# (a) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 134.96,
                        "y": 266.51,
                        "w": 379.7,
                        "h": 300.91
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What would be the prediction accuracy using a global one-bit-history (last-time) branch predictor shared between all the branches? The initial state of the predictor is \"taken\".\n\nAnswer: 19/36.\n\nNote that initial values of both R1 and R5 are 4; and they change only before the branches in lines 20 and 27 respectively. Both branches follow the pattern of T-T-T-NT, which creates a nested loop. At each iteration of the internal loop, adjacent elements (pointed by R0 and R2) are swapped, if Memory[R0] \u2264 Memory[R2]. Then, both R0 and R4 are incremented by 4. So they point to the next element in the next iteration. Therefore, the code sorts the elements in Array in increasing order.",
                    "md": "What would be the prediction accuracy using a global one-bit-history (last-time) branch predictor shared between all the branches? The initial state of the predictor is \"taken\".\n\nAnswer: 19/36.\n\nNote that initial values of both R1 and R5 are 4; and they change only before the branches in lines 20 and 27 respectively. Both branches follow the pattern of T-T-T-NT, which creates a nested loop. At each iteration of the internal loop, adjacent elements (pointed by R0 and R2) are swapped, if Memory[R0] \u2264 Memory[R2]. Then, both R0 and R4 are incremented by 4. So they point to the next element in the next iteration. Therefore, the code sorts the elements in Array in increasing order.",
                    "rows": null,
                    "bBox": {
                        "x": 86.47,
                        "y": 83.96,
                        "w": 442.41,
                        "h": 495.42
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Table below shows the behavior of each branch through the code.",
                    "md": "# Table below shows the behavior of each branch through the code.",
                    "rows": null,
                    "bBox": {
                        "x": 134.96,
                        "y": 278.87,
                        "w": 379.7,
                        "h": 300.51
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|        | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 |\n| ------ | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Line11 | T  |    | N  |    | T  |    | N  |    | T  | T  |    |    |    |    |    |    |    |    |\n| Line20 | T  | T  |    | T  | N  | T  | T  | T  | N  |    |    |    |    |    |    |    |    |    |\n| Line27 |    |    |    | T  |    |    |    |    |    |    |    |    |    |    |    |    |    |    |\n|        | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |\n| Line11 | N  | T  | T  |    | T  | T  | T  | T  | T  |    |    |    |    |    |    |    |    |    |\n| Line20 | T  | T  |    | T  | N  | T  | T  | T  | N  |    |    |    |    |    |    |    |    |    |\n| Line27 |    |    |    | T  |    |    |    |    |    |    |    |    |    |    |    |    |    |    |",
                    "rows": [
                        [
                            "",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "9",
                            "10",
                            "11",
                            "12",
                            "13",
                            "14",
                            "15",
                            "16",
                            "17",
                            "18"
                        ],
                        [
                            "Line11",
                            "T",
                            "",
                            "N",
                            "",
                            "T",
                            "",
                            "N",
                            "",
                            "T",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "Line20",
                            "T",
                            "T",
                            "",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            "N",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "Line27",
                            "",
                            "",
                            "",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "",
                            "19",
                            "20",
                            "21",
                            "22",
                            "23",
                            "24",
                            "25",
                            "26",
                            "27",
                            "28",
                            "29",
                            "30",
                            "31",
                            "32",
                            "33",
                            "34",
                            "35",
                            "36"
                        ],
                        [
                            "Line11",
                            "N",
                            "T",
                            "T",
                            "",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "Line20",
                            "T",
                            "T",
                            "",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            "N",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "Line27",
                            "",
                            "",
                            "",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 457.02,
                        "h": 751.56
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "One-bit-history branch predictor suggests that the next branch\u2019s behavior will be the same with the last one.",
                    "md": "# One-bit-history branch predictor suggests that the next branch\u2019s behavior will be the same with the last one.",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 278.87,
                        "w": 442.42,
                        "h": 300.51
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Table below shows the predictor states, hits, and misses through the execution.",
                    "md": "# Table below shows the predictor states, hits, and misses through the execution.",
                    "rows": null,
                    "bBox": {
                        "x": 92.45,
                        "y": 278.87,
                        "w": 422.21,
                        "h": 300.51
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|                 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 |   |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | - |\n| Predictor State | T  | T  | T  | N  | T  | N  | T  | T  | N  | T  | N  | T  | N  | T  | T  |   |\n| Branch Behavior | T  | T  | N  | T  | N  | T  | T  | N  | T  | N  | T  | N  | T  | T  | T  |   |\n| Hit/Miss        | H  | H  | M  | M  | M  | H  | M  | M  | M  | M  | M  | M  | M  | M  | H  | H |\n|                 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 |   |\n| Predictor State | T  | T  | N  | T  | N  | T  | T  | T  | T  | T  | T  | N  | T  | T  | T  |   |\n| Branch Behavior | T  | N  | T  | N  | T  | T  | T  | T  | T  | T  | N  | T  | T  | T  | T  |   |\n| Hit/Miss        | H  | M  | M  | M  | M  | H  | H  | H  | H  | H  | M  | M  | H  | H  | H  |   |",
                    "rows": [
                        [
                            "",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "9",
                            "10",
                            "11",
                            "12",
                            "13",
                            "14",
                            "15",
                            ""
                        ],
                        [
                            "Predictor State",
                            "T",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            ""
                        ],
                        [
                            "Branch Behavior",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            ""
                        ],
                        [
                            "Hit/Miss",
                            "H",
                            "H",
                            "M",
                            "M",
                            "M",
                            "H",
                            "M",
                            "M",
                            "M",
                            "M",
                            "M",
                            "M",
                            "M",
                            "M",
                            "H",
                            "H"
                        ],
                        [
                            "",
                            "16",
                            "17",
                            "18",
                            "19",
                            "20",
                            "21",
                            "22",
                            "23",
                            "24",
                            "25",
                            "26",
                            "27",
                            "28",
                            "29",
                            "30",
                            ""
                        ],
                        [
                            "Predictor State",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            ""
                        ],
                        [
                            "Branch Behavior",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            "T",
                            ""
                        ],
                        [
                            "Hit/Miss",
                            "H",
                            "M",
                            "M",
                            "M",
                            "M",
                            "H",
                            "H",
                            "H",
                            "H",
                            "H",
                            "M",
                            "M",
                            "H",
                            "H",
                            "H",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 457.02,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                                     Page 38 of 40",
                    "md": "Final Exam                                                                     Page 38 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 266.51,
                        "w": 451.32,
                        "h": 528.16
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 40,
            "text": "Initials: Solutions                                                              Design of Digital Circuits  August 18th, 2018\n                                           (b) [15 points] What would be the prediction accuracy using a global two-bit-history (two-bit counter)\n    branch predictor shared between all the branches? Assume that the initial state of the two-bit\n    counter is \"weakly taken\".   The \"weakly taken\" state transitions to the \"weakly not-taken\" state\n    on misprediction. Similarly, the \"weakly not-taken\" state transitions to the \"weakly taken\" state\n    on misprediction. A correct prediction in one of the \"weak\" states transitions the state to the\n    corresponding \"strong\" state.\n   Answer: 26/36.\n   Explanation:\n   Table below shows the predictor states, hits, and misses through the code. Used abbreviations are as\n   follows: ST: Strongly Taken, WT: Weakly Taken, WN: Weakly Not-taken, SN: Strongly Not-taken.\n   Branch behavior is the same with question (a), since both of them are shared predictors.\n                      1     2    3    4    5     6    7     8     9    10   11    12   13            14\n     Predictor State  WT    ST   ST   WT   ST    WT   ST    ST    WT   ST   WT    ST   WT            ST\n     Branch Behavior  T     T    N    T    N     T    T     N     T    N    T     N    T             T\n     Hit/Miss          H    H    M    H    M     H    H     M     H    M    H     M    H             H\n                      15    16   17   18   19    20   21    22    23   24   25    26   27            28\n     Predictor State  ST    ST   ST   WT   ST    WT   ST    ST    ST   ST   ST    ST   WT            ST\n     Branch Behavior  T     T    N    T    N     T    T     T     T    T    T     N    T             T\n     Hit/Miss          H    H    M    H    M     H    H     H     H    H    H     M    H             H\n                      29    30   31   32   33    34   35    36\n     Predictor State  ST    ST   ST   ST   ST    ST   ST    WT\n     Branch Behavior  T     T    T    T    T     T    N     N\n     Hit/Miss          H    H    H    H    H     H    M     M\nFinal Exam                                                                     Page 39 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (b) [15 points]\n\nWhat would be the prediction accuracy using a global two-bit-history (two-bit counter) branch predictor shared between all the branches? Assume that the initial state of the two-bit counter is \"weakly taken\". The \"weakly taken\" state transitions to the \"weakly not-taken\" state on misprediction. Similarly, the \"weakly not-taken\" state transitions to the \"weakly taken\" state on misprediction. A correct prediction in one of the \"weak\" states transitions the state to the corresponding \"strong\" state.\n\nAnswer: 26/36.\n\nExplanation:\n\nTable below shows the predictor states, hits, and misses through the code. Used abbreviations are as follows: ST: Strongly Taken, WT: Weakly Taken, WN: Weakly Not-taken, SN: Strongly Not-taken. Branch behavior is the same with question (a), since both of them are shared predictors.\n\n|                 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Predictor State | WT | ST | ST | WT | ST | WT | ST | ST | WT | ST | WT | ST | WT | ST |\n| Branch Behavior | T  | T  | N  | T  | N  | T  | T  | N  | T  | N  | T  | N  | T  | T  |\n| Hit/Miss        | H  | H  | M  | H  | M  | H  | H  | M  | H  | M  | H  | M  | H  | H  |\n\n|                 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Predictor State | ST | ST | ST | WT | ST | WT | ST | ST | ST | ST | ST | ST | WT | ST |\n| Branch Behavior | T  | T  | N  | T  | N  | T  | T  | T  | T  | T  | T  | N  | T  | T  |\n| Hit/Miss        | H  | H  | M  | H  | M  | H  | H  | H  | H  | H  | H  | M  | H  | H  |\n\n|                 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Predictor State | ST | ST | ST | ST | ST | ST | ST | WT |\n| Branch Behavior | T  | T  | T  | T  | T  | T  | N  | N  |\n| Hit/Miss        | H  | H  | H  | H  | H  | H  | M  | M  |\n\nFinal Exam Page 39 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 469.46,
                        "h": 354.15
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 183.02,
                        "y": 43.11,
                        "w": 358.44,
                        "h": 354.15
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 180.26,
                        "y": 43.11,
                        "w": 364.44,
                        "h": 366.11
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) [15 points]",
                    "md": "# (b) [15 points]",
                    "rows": null,
                    "bBox": {
                        "x": 181.64,
                        "y": 242.6,
                        "w": 359.82,
                        "h": 154.66
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What would be the prediction accuracy using a global two-bit-history (two-bit counter) branch predictor shared between all the branches? Assume that the initial state of the two-bit counter is \"weakly taken\". The \"weakly taken\" state transitions to the \"weakly not-taken\" state on misprediction. Similarly, the \"weakly not-taken\" state transitions to the \"weakly taken\" state on misprediction. A correct prediction in one of the \"weak\" states transitions the state to the corresponding \"strong\" state.\n\nAnswer: 26/36.\n\nExplanation:\n\nTable below shows the predictor states, hits, and misses through the code. Used abbreviations are as follows: ST: Strongly Taken, WT: Weakly Taken, WN: Weakly Not-taken, SN: Strongly Not-taken. Branch behavior is the same with question (a), since both of them are shared predictors.",
                    "md": "What would be the prediction accuracy using a global two-bit-history (two-bit counter) branch predictor shared between all the branches? Assume that the initial state of the two-bit counter is \"weakly taken\". The \"weakly taken\" state transitions to the \"weakly not-taken\" state on misprediction. Similarly, the \"weakly not-taken\" state transitions to the \"weakly taken\" state on misprediction. A correct prediction in one of the \"weak\" states transitions the state to the corresponding \"strong\" state.\n\nAnswer: 26/36.\n\nExplanation:\n\nTable below shows the predictor states, hits, and misses through the code. Used abbreviations are as follows: ST: Strongly Taken, WT: Weakly Taken, WN: Weakly Not-taken, SN: Strongly Not-taken. Branch behavior is the same with question (a), since both of them are shared predictors.",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 83.96,
                        "w": 458.22,
                        "h": 325.26
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|                 | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Predictor State | WT | ST | ST | WT | ST | WT | ST | ST | WT | ST | WT | ST | WT | ST |\n| Branch Behavior | T  | T  | N  | T  | N  | T  | T  | N  | T  | N  | T  | N  | T  | T  |\n| Hit/Miss        | H  | H  | M  | H  | M  | H  | H  | M  | H  | M  | H  | M  | H  | H  |",
                    "rows": [
                        [
                            "",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "9",
                            "10",
                            "11",
                            "12",
                            "13",
                            "14"
                        ],
                        [
                            "Predictor State",
                            "WT",
                            "ST",
                            "ST",
                            "WT",
                            "ST",
                            "WT",
                            "ST",
                            "ST",
                            "WT",
                            "ST",
                            "WT",
                            "ST",
                            "WT",
                            "ST"
                        ],
                        [
                            "Branch Behavior",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T"
                        ],
                        [
                            "Hit/Miss",
                            "H",
                            "H",
                            "M",
                            "H",
                            "M",
                            "H",
                            "H",
                            "M",
                            "H",
                            "M",
                            "H",
                            "M",
                            "H",
                            "H"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 473.25,
                        "h": 751.56
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|                 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Predictor State | ST | ST | ST | WT | ST | WT | ST | ST | ST | ST | ST | ST | WT | ST |\n| Branch Behavior | T  | T  | N  | T  | N  | T  | T  | T  | T  | T  | T  | N  | T  | T  |\n| Hit/Miss        | H  | H  | M  | H  | M  | H  | H  | H  | H  | H  | H  | M  | H  | H  |",
                    "rows": [
                        [
                            "",
                            "15",
                            "16",
                            "17",
                            "18",
                            "19",
                            "20",
                            "21",
                            "22",
                            "23",
                            "24",
                            "25",
                            "26",
                            "27",
                            "28"
                        ],
                        [
                            "Predictor State",
                            "ST",
                            "ST",
                            "ST",
                            "WT",
                            "ST",
                            "WT",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "WT",
                            "ST"
                        ],
                        [
                            "Branch Behavior",
                            "T",
                            "T",
                            "N",
                            "T",
                            "N",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "N",
                            "T",
                            "T"
                        ],
                        [
                            "Hit/Miss",
                            "H",
                            "H",
                            "M",
                            "H",
                            "M",
                            "H",
                            "H",
                            "H",
                            "H",
                            "H",
                            "H",
                            "M",
                            "H",
                            "H"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 473.25,
                        "h": 751.56
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|                 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |\n| --------------- | -- | -- | -- | -- | -- | -- | -- | -- |\n| Predictor State | ST | ST | ST | ST | ST | ST | ST | WT |\n| Branch Behavior | T  | T  | T  | T  | T  | T  | N  | N  |\n| Hit/Miss        | H  | H  | H  | H  | H  | H  | M  | M  |",
                    "rows": [
                        [
                            "",
                            "29",
                            "30",
                            "31",
                            "32",
                            "33",
                            "34",
                            "35",
                            "36"
                        ],
                        [
                            "Predictor State",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "ST",
                            "WT"
                        ],
                        [
                            "Branch Behavior",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "T",
                            "N",
                            "N"
                        ],
                        [
                            "Hit/Miss",
                            "H",
                            "H",
                            "H",
                            "H",
                            "H",
                            "H",
                            "M",
                            "M"
                        ]
                    ],
                    "bBox": {
                        "x": 71.45,
                        "y": 43.11,
                        "w": 473.25,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam Page 39 of 40",
                    "md": "Final Exam Page 39 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 242.6,
                        "w": 451.32,
                        "h": 552.07
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 41,
            "text": "Initials: Solutions               Design of Digital Circuits               August 18th, 2018\n (c) [10 points] What would be the prediction accuracy using a local two-bit-history (two-bit counter)\n    branch predictor that is separate for each branch? The initial state is \"weakly taken\" and the state\n    transitions are the same as in part (b).\n   Answer:\n      \u2022  L11: 8/16\n      \u2022  L20: 12/16\n      \u2022  L27: 3/4\n      \u2022  All Branches: 23/36\n   Explanation:  Private predictors update their states only based on the behaviors of corresponding\n   branches.\n                          1      2   3     4     5     6    7     8     9    10    11    12\n     L11 Predictor State  WT         ST          WT        WN                WT          WN\n     L11 Branch Behavior  T          N           N          T                N           N\n     L11 Hit/Miss         H          M           M          M                M           H\n     L20 Predictor State        WT         ST         ST          ST               WT\n     L20 Branch Behavior        T          T          T           N                T\n     L20 Hit/Miss               H          H          H           M                H\n     L27 Predictor State                                               WT\n     L27 Branch Behavior                                               T\n     L27 Hit/Miss                                                      H\n                          13    14    15   16    17   18    19    20   21    22    23    24\n     L11 Predictor State        SN         WN               WT         WN          WT\n     L11 Branch Behavior        T          T                N          T           T\n     L11 Hit/Miss               M          M                M          M           H\n     L20 Predictor State  ST         ST          ST               WT         ST          ST\n     L20 Branch Behavior  T          T           N                T          T           T\n     L20 Hit/Miss         H          H           M                H          H           H\n     L27 Predictor State                              ST\n     L27 Branch Behavior                              T\n     L27 Hit/Miss                                     H\n                          25    26    27   28    29   30    31    32    33   34    35    36\n     L11 Predictor State  ST               ST         ST          ST         ST\n     L11 Branch Behavior  T                T          T           T          T\n     L11 Hit/Miss         H                H          H           H          H\n     L20 Predictor State        ST               WT        ST          ST          ST\n     L20 Branch Behavior        N                T          T          T           N\n     L20 Hit/Miss               M                H          H          H           M\n     L27 Predictor State             ST                                                  ST\n     L27 Branch Behavior             T                                                   N\n     L27 Hit/Miss                    H                                                   M\nFinal Exam                                                                     Page 40 of 40",
            "md": "Initials: Solutions\n# Design of Digital Circuits\n\n# August 18th, 2018\n\n# (c) [10 points]\n\nWhat would be the prediction accuracy using a local two-bit-history (two-bit counter) branch predictor that is separate for each branch? The initial state is \"weakly taken\" and the state transitions are the same as in part (b).\n\n# Answer:\n\n- L11: 8/16\n- L20: 12/16\n- L27: 3/4\n- All Branches: 23/36\n\nExplanation: Private predictors update their states only based on the behaviors of corresponding branches.\n\n|                     | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 |   |   |   |   |\n| ------------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | - | - | - | - |\n| L11 Predictor State | WT | ST | WT |    |    | WN | WT | WN |    |    |    |    |   |   |   |   |\n| L11 Branch Behavior | T  | N  | N  | T  | N  | N  |    |    |    |    |    |    |   |   |   |   |\n| L11 Hit/Miss        | H  | M  | M  | M  | M  | H  |    |    |    |    |    |    |   |   |   |   |\n| L20 Predictor State | WT |    | ST | ST | ST | WT |    |    |    |    |    |    |   |   |   |   |\n| L20 Branch Behavior | T  | T  | T  |    |    |    | N  | T  |    |    |    |    |   |   |   |   |\n| L20 Hit/Miss        | H  | H  | H  | M  | H  |    |    |    |    |    |    |    |   |   |   |   |\n| L27 Predictor State |    |    |    |    |    |    | WT |    |    |    |    |    |   |   |   |   |\n| L27 Branch Behavior |    |    |    |    |    |    | T  |    |    |    |    |    |   |   |   |   |\n| L27 Hit/Miss        |    |    |    |    | H  |    |    |    |    |    |    |    |   |   |   |   |\n|                     | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 |   |   |   |   |\n| L11 Predictor State | SN |    | WN |    |    | WT | WN | WT |    |    |    |    |   |   |   |   |\n| L11 Branch Behavior | T  | T  |    | N  | T  | T  |    |    |    |    |    |    |   |   |   |   |\n| L11 Hit/Miss        | M  | M  |    | M  | M  | H  |    |    |    |    |    |    |   |   |   |   |\n| L20 Predictor State |    |    | ST | ST | ST | WT | ST | ST |    |    |    |    |   |   |   |   |\n| L20 Branch Behavior | T  | T  |    |    |    |    | N  | T  | T  | T  |    |    |   |   |   |   |\n| L20 Hit/Miss        | H  | H  | M  | H  | H  | H  |    |    |    |    |    |    |   |   |   |   |\n| L27 Predictor State |    |    |    |    | ST |    |    |    |    |    |    |    |   |   |   |   |\n| L27 Branch Behavior |    |    |    |    |    |    | T  |    |    |    |    |    |   |   |   |   |\n| L27 Hit/Miss        |    |    |    |    | H  |    |    |    |    |    |    |    |   |   |   |   |\n\nFinal Exam                                                                     Page 40 of 40",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Initials: Solutions",
                    "md": "Initials: Solutions",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 452.33,
                        "h": 625.89
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 202.53,
                        "y": 43.11,
                        "w": 321.81,
                        "h": 625.89
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "August 18th, 2018",
                    "md": "# August 18th, 2018",
                    "rows": null,
                    "bBox": {
                        "x": 199.76,
                        "y": 43.11,
                        "w": 327.8,
                        "h": 637.85
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) [10 points]",
                    "md": "# (c) [10 points]",
                    "rows": null,
                    "bBox": {
                        "x": 202.53,
                        "y": 226.62,
                        "w": 321.81,
                        "h": 442.38
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "What would be the prediction accuracy using a local two-bit-history (two-bit counter) branch predictor that is separate for each branch? The initial state is \"weakly taken\" and the state transitions are the same as in part (b).",
                    "md": "What would be the prediction accuracy using a local two-bit-history (two-bit counter) branch predictor that is separate for each branch? The initial state is \"weakly taken\" and the state transitions are the same as in part (b).",
                    "rows": null,
                    "bBox": {
                        "x": 89.71,
                        "y": 83.96,
                        "w": 437.86,
                        "h": 597.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Answer:",
                    "md": "# Answer:",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 113.64,
                        "w": 437.71,
                        "h": 555.36
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "- L11: 8/16\n- L20: 12/16\n- L27: 3/4\n- All Branches: 23/36\n\nExplanation: Private predictors update their states only based on the behaviors of corresponding branches.",
                    "md": "- L11: 8/16\n- L20: 12/16\n- L27: 3/4\n- All Branches: 23/36\n\nExplanation: Private predictors update their states only based on the behaviors of corresponding branches.",
                    "rows": null,
                    "bBox": {
                        "x": 86.48,
                        "y": 129.58,
                        "w": 442.55,
                        "h": 551.37
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|                     | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 |   |   |   |   |\n| ------------------- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | -- | - | - | - | - |\n| L11 Predictor State | WT | ST | WT |    |    | WN | WT | WN |    |    |    |    |   |   |   |   |\n| L11 Branch Behavior | T  | N  | N  | T  | N  | N  |    |    |    |    |    |    |   |   |   |   |\n| L11 Hit/Miss        | H  | M  | M  | M  | M  | H  |    |    |    |    |    |    |   |   |   |   |\n| L20 Predictor State | WT |    | ST | ST | ST | WT |    |    |    |    |    |    |   |   |   |   |\n| L20 Branch Behavior | T  | T  | T  |    |    |    | N  | T  |    |    |    |    |   |   |   |   |\n| L20 Hit/Miss        | H  | H  | H  | M  | H  |    |    |    |    |    |    |    |   |   |   |   |\n| L27 Predictor State |    |    |    |    |    |    | WT |    |    |    |    |    |   |   |   |   |\n| L27 Branch Behavior |    |    |    |    |    |    | T  |    |    |    |    |    |   |   |   |   |\n| L27 Hit/Miss        |    |    |    |    | H  |    |    |    |    |    |    |    |   |   |   |   |\n|                     | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 |   |   |   |   |\n| L11 Predictor State | SN |    | WN |    |    | WT | WN | WT |    |    |    |    |   |   |   |   |\n| L11 Branch Behavior | T  | T  |    | N  | T  | T  |    |    |    |    |    |    |   |   |   |   |\n| L11 Hit/Miss        | M  | M  |    | M  | M  | H  |    |    |    |    |    |    |   |   |   |   |\n| L20 Predictor State |    |    | ST | ST | ST | WT | ST | ST |    |    |    |    |   |   |   |   |\n| L20 Branch Behavior | T  | T  |    |    |    |    | N  | T  | T  | T  |    |    |   |   |   |   |\n| L20 Hit/Miss        | H  | H  | M  | H  | H  | H  |    |    |    |    |    |    |   |   |   |   |\n| L27 Predictor State |    |    |    |    | ST |    |    |    |    |    |    |    |   |   |   |   |\n| L27 Branch Behavior |    |    |    |    |    |    | T  |    |    |    |    |    |   |   |   |   |\n| L27 Hit/Miss        |    |    |    |    | H  |    |    |    |    |    |    |    |   |   |   |   |",
                    "rows": [
                        [
                            "",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "9",
                            "10",
                            "11",
                            "12",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L11 Predictor State",
                            "WT",
                            "ST",
                            "WT",
                            "",
                            "",
                            "WN",
                            "WT",
                            "WN",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L11 Branch Behavior",
                            "T",
                            "N",
                            "N",
                            "T",
                            "N",
                            "N",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L11 Hit/Miss",
                            "H",
                            "M",
                            "M",
                            "M",
                            "M",
                            "H",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L20 Predictor State",
                            "WT",
                            "",
                            "ST",
                            "ST",
                            "ST",
                            "WT",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L20 Branch Behavior",
                            "T",
                            "T",
                            "T",
                            "",
                            "",
                            "",
                            "N",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L20 Hit/Miss",
                            "H",
                            "H",
                            "H",
                            "M",
                            "H",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L27 Predictor State",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "WT",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L27 Branch Behavior",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L27 Hit/Miss",
                            "",
                            "",
                            "",
                            "",
                            "H",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "",
                            "13",
                            "14",
                            "15",
                            "16",
                            "17",
                            "18",
                            "19",
                            "20",
                            "21",
                            "22",
                            "23",
                            "24",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L11 Predictor State",
                            "SN",
                            "",
                            "WN",
                            "",
                            "",
                            "WT",
                            "WN",
                            "WT",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L11 Branch Behavior",
                            "T",
                            "T",
                            "",
                            "N",
                            "T",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L11 Hit/Miss",
                            "M",
                            "M",
                            "",
                            "M",
                            "M",
                            "H",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L20 Predictor State",
                            "",
                            "",
                            "ST",
                            "ST",
                            "ST",
                            "WT",
                            "ST",
                            "ST",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L20 Branch Behavior",
                            "T",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "N",
                            "T",
                            "T",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L20 Hit/Miss",
                            "H",
                            "H",
                            "M",
                            "H",
                            "H",
                            "H",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L27 Predictor State",
                            "",
                            "",
                            "",
                            "",
                            "ST",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L27 Branch Behavior",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "T",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ],
                        [
                            "L27 Hit/Miss",
                            "",
                            "",
                            "",
                            "",
                            "H",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 43.11,
                        "w": 458.07,
                        "h": 751.56
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Final Exam                                                                     Page 40 of 40",
                    "md": "Final Exam                                                                     Page 40 of 40",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 226.62,
                        "w": 453.36,
                        "h": 568.05
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 595.276,
            "height": 841.89,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        }
    ],
    "job_metadata": {
        "job_pages": 41,
        "job_auto_mode_triggered_pages": 0,
        "job_is_cache_hit": false
    },
    "file_name": "data/digitaltechnik_s18_final_en-sol.pdf",
    "job_id": "ad825c2e-ea75-4c6d-9cb2-70582861de70",
    "is_done": false,
    "error": null
}