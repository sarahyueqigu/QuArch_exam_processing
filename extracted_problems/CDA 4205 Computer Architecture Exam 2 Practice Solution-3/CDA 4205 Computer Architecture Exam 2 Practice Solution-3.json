[
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_1/a",
        "context": "We wish to add the instruction jalr (jump and link register) to the single-cycle datapath. The jump and link register instruction is described below:\n\njalr rd, rs # rd = pc + 4 , pc = rs\n\nop6 = 0 rs5 0 rd5 0 Funct6 = 0x9\n",
        "context_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\img_p0_1.png",
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p1_0.png"
        ],
        "question": "Add any necessary datapath and control signals and draw the result datapath. You should only add wires, gates, muxes to the datapath; do not modify the main functional units (the memory, register file, and ALU) themselves. Try to keep your diagram neat!",
        "solution": "The necessary changes to the datapath and control:\n\nFor the datapath, we need a bigger 4\u00adinput multiplexer at the input of the PC. The first input is used to increment the PC. The second input is used for taken branches, where the branch target is PC\u00adrelative. The third input is used to jump register, where the input to the PC comes from a general\u00adpurpose register, and the fourth input is used for jump instructions.\n\nFor the implementation of the JALR instruction: to jump to register 'Rs', we need to add a path from the output of register Rs (first ALU input) back to the PC multiplexer input. PC control unit needs to be updated by adding an input control signal JReg (Jump Register) to select PC according to the value of register Rs. JReg is generated by the ALU control unit, since JALR is a R\u00adtype instruction and JReg depends on the function field only. When JReg is equal to '1', PCSrc (PC control unit output control signal) will be '10' to select the value of register Rs as input to PC.\n\nAlso, we need to store PC+4 in register Rd. To accomplish this, we need another multiplexer to select between the incremented PC, the ALU result and data memory out, to be placed on BusW. Also, we need to add a path from the output of the incremented PC to the input of this new multiplexer. A control signal 'RA' (Return Address) is needed to select between the incremented PC and the ALU result. The MemtoReg multiplexer selects between the output of the 'RA' multiplexer and the Data Memory output to place on BusW.",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_1/b",
        "context": "We wish to add the instruction jalr (jump and link register) to the single-cycle datapath. The jump and link register instruction is described below:\n\njalr rd, rs # rd = pc + 4 , pc = rs\n\nop6 = 0 rs5 0 rd5 0 Funct6 = 0x9\nUse the following table for ALUCtrl.\n\nALU function 4-bit ALU Control\nAND 0001\nOR 0010\nXOR 0011\nADD 0100\nSUB 0101\nSLT 0110",
        "context_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\img_p0_1.png",
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p1_0.png",
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p2_0.png"
        ],
        "question": "Show the values of the control signals to control the execution of the jalr instruction. If you need add a new control signal, please add it along with its value to the table below.",
        "solution": "The main control signals for the JALR instruction are the same for other R\u00adtype instructions, such as ADD and SUB. The ALU Control signals for the JALR instruction require JReg = 1, RA = 0 and ALUCtrl is a don't care. These control signals are shown in the table below:\n\nRegDst RegWrite ExtOp ALUSrc MemRead MemWrite MemtoReg ALUCtrl J Beq Bne RA JReg\nRd = 1 1 X X 0 0 0 XXXX 0 0 0 0 1",
        "solution_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p2_1.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_2/a",
        "context": "Suppose we add the multiply and divide instructions. The operation times are as follows:\n\nInstruction memory access time = 190 ps,      Data memory access time = 190 ps,\nRegister file read access time = 150 ps,  Register file write access = 150 ps\nALU delay for basic instructions = 190 ps,      ALU delay for multiply or divide = 550 ps\nIgnore the other delays in the multiplexers, control unit, sign-extension, etc.\n\nAssume the following instruction mix: 30% ALU, 15% multiply & divide, 20% load, 10%\nstore, 15% branch, and 10% jump.\n",
        "context_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p2_0.png"
        ],
        "question": "What is the total delay for each instruction class and the clock cycle for the single-cycle CPU design?",
        "solution": "Clock cycle = max delay = 1040 ps.",
        "solution_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\img_p2_1.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_2/b",
        "context": "Suppose we add the multiply and divide instructions. The operation times are as follows:\n\nInstruction memory access time = 190 ps,      Data memory access time = 190 ps,\nRegister file read access time = 150 ps,  Register file write access = 150 ps\nALU delay for basic instructions = 190 ps,      ALU delay for multiply or divide = 550 ps\nIgnore the other delays in the multiplexers, control unit, sign-extension, etc.\n\nAssume the following instruction mix: 30% ALU, 15% multiply & divide, 20% load, 10%\nstore, 15% branch, and 10% jump.\n",
        "context_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p2_0.png"
        ],
        "question": "Assume we fix the clock cycle to 200 ps for a multi-cycle CPU, what is the CPI for each instruction class and the speedup over a fixed-length clock cycle?",
        "solution": "Solution:\nCPI for Basic ALU = 4 cycles\nCPI for Multiply & Divide = 6 cycles \nCPI for Load = 5 cycles\nCPI for Store = 4 cycles\nCPI for Branch = 3 cycles\nCPI for Jump = 2 cycles\n\nAverage CPI = 0.3 * 4 + 0.15 * 6 + 0.2* 5 + 0.1 * 4 + 0.15 * 3 +\n0.1 * 2 = 4.15\n\nSpeedup of multi-cycle over single-cycle = (1040 * 1) / (200 *\n4.15) = 1.253",
        "solution_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p2_1.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_3/a",
        "context": "Consider the following MIPS code sequence:\n\na: add $t0, $s0, $s1\n\nb: sub $t1, $s2, $t0\n\nc: xor $t0, $s0, $s1\n\nd: or  $t2, $t1, $t0\n",
        "context_figures": [],
        "question": "Identify all the RAW dependencies between pairs of instructions.",
        "solution": "Instruction b is dependent on instruction a ($t0)\nInstruction d is dependent on instruction b ($t1)\nInstruction d is dependent on instruction c ($t0)",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_3/b",
        "context": "Consider the following MIPS code sequence:\n\na: add $t0, $s0, $s1\n\nb: sub $t1, $s2, $t0\n\nc: xor $t0, $s0, $s1\n\nd: or  $t2, $t1, $t0\n",
        "context_figures": [],
        "question": "Identify all the WAR dependencies between pairs of instructions",
        "solution": "Instruction c is dependent on instruction b ($t0)",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_3/c",
        "context": "Consider the following MIPS code sequence:\n\na: add $t0, $s0, $s1\n\nb: sub $t1, $s2, $t0\n\nc: xor $t0, $s0, $s1\n\nd: or  $t2, $t1, $t0\n",
        "context_figures": [],
        "question": "Identify all the WAW dependencies between pairs of instructions",
        "solution": "Instruction c is dependent on instruction a ($t0)",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_4/a",
        "context": "Use the following MIPS code fragment:\nI1: ADDI $3, $0, 100 # $3 = 100\nI2: ADD  $4, $0, $0 # $4 = 0\n\n\nLoop:\nI3: LW $5, 0($1) # $5 = MEM[$1]\nI4: ADD $4, $4, $5 # $4 = $4 + $5\nI5: LW $6, 0($2) # $6 = MEM[$2]\nI6: SUB $4, $4, $6 # $4 = $4 \u2013 $6\nI7: ADDI $1, $1, 4 # $1 = $1 + 4\nI8: ADDI $2, $2, 4 # $2 = $2 + 4\nI9: ADDI $3, $3, -1 # $3 = $3 \u2013 1\nI10: BNE $3, $0, Loop # if ($3 != 0) goto Loop\n",
        "context_figures": [],
        "question": "Show the timing of one loop iteration on the 5-stage MIPS pipeline without forwarding hardware. Complete the timing table, showing all the stall cycles. Assume that the register write is in the first half of the clock cycle and the register read is in the second half. Also assume that the branch will stall the pipeline for 1 clock cycle only. Ignore the \"startup cost\" of the pipeline.",
        "solution": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\nI1 IF ID EX MEM WB\nI2 IF ID EX MEM WB\nI3 IF ID EX MEM WB\nI4 IF Stall Stall ID EX MEM WB\nI5 IF ID EX MEM WB\nI6 IF Stall Stall ID EX MEM WB\nI7 IF ID EX MEM WB\nI8 IF ID EX MEM WB\nI9 IF ID EX MEM WB\nI10 IF Stall Stall ID EX ME WB\nI3 IF IF ID EX MEM WB\nI4 IF Stall Stall ID EX MEM WB",
        "solution_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p5_0.png",
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p6_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_4/b",
        "context": "Use the following MIPS code fragment:\nI1: ADDI $3, $0, 100 # $3 = 100\nI2: ADD  $4, $0, $0 # $4 = 0\n\n\nLoop:\nI3: LW $5, 0($1) # $5 = MEM[$1]\nI4: ADD $4, $4, $5 # $4 = $4 + $5\nI5: LW $6, 0($2) # $6 = MEM[$2]\nI6: SUB $4, $4, $6 # $4 = $4 \u2013 $6\nI7: ADDI $1, $1, 4 # $1 = $1 + 4\nI8: ADDI $2, $2, 4 # $2 = $2 + 4\nI9: ADDI $3, $3, -1 # $3 = $3 \u2013 1\nI10: BNE $3, $0, Loop # if ($3 != 0) goto Loop\n",
        "context_figures": [],
        "question": "According to the timing diagram of part (a), compute the number of clock cycles and the average CPI to execute ALL the iterations of the above loop.",
        "solution": "There are 100 iterations\nEach iteration requires 15 cycles =\n8 cycles to start the 8 instructions in loop body + 7 stall cycles\nThere are 2 additional cycles to start the first 2 instructions before the loop.\nTherefore, total cycles = 100 * 15 + 2 (can be ignored) = 1502 cycles \u2248 1500 cycles\nTotal instruction executed = 2 + 8 * 100 = 802 instructions (counting first two)\nAverage CPI = 1502 / 802 = 1.87\nIf we ignore first two instructions and the time to terminate last iteration then\nAverage CPI = 1500/800 = 1.88 (almost same answer)",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_4/c",
        "context": "Use the following MIPS code fragment:\nI1: ADDI $3, $0, 100 # $3 = 100\nI2: ADD  $4, $0, $0 # $4 = 0\n\n\nLoop:\nI3: LW $5, 0($1) # $5 = MEM[$1]\nI4: ADD $4, $4, $5 # $4 = $4 + $5\nI5: LW $6, 0($2) # $6 = MEM[$2]\nI6: SUB $4, $4, $6 # $4 = $4 \u2013 $6\nI7: ADDI $1, $1, 4 # $1 = $1 + 4\nI8: ADDI $2, $2, 4 # $2 = $2 + 4\nI9: ADDI $3, $3, -1 # $3 = $3 \u2013 1\nI10: BNE $3, $0, Loop # if ($3 != 0) goto Loop\n",
        "context_figures": [],
        "question": "Redo part (a) to show the timing of one loop iteration with full forwarding hardware. If forwarding happens, please show how the data is forwarded with an arrow.",
        "solution": "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\nI1 IF ID EX MEM WB\nI2 IF ID EX MEM WB\nI3 IF ID EX MEM WB\nI4 IF Stall ID EX MEM WB\nI5 IF ID EX MEM WB\nI6 IF Stall ID EX ME WB\nI7 IF ID EX MEM WB\nI8 IF ID EX MEM WB\nI9 IF ID EX MEM WB\nI10 IF ID EX MEM WB\nI3 IF IF ID EX MEM WB\nI4 IF Stall ID EX MEM WB",
        "solution_figures": [
            "images\\CDA 4205 Computer Architecture Exam 2 Practice Solution-3\\chart_p8_0.png"
        ],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_4/d",
        "context": "Use the following MIPS code fragment:\nI1: ADDI $3, $0, 100 # $3 = 100\nI2: ADD  $4, $0, $0 # $4 = 0\n\n\nLoop:\nI3: LW $5, 0($1) # $5 = MEM[$1]\nI4: ADD $4, $4, $5 # $4 = $4 + $5\nI5: LW $6, 0($2) # $6 = MEM[$2]\nI6: SUB $4, $4, $6 # $4 = $4 \u2013 $6\nI7: ADDI $1, $1, 4 # $1 = $1 + 4\nI8: ADDI $2, $2, 4 # $2 = $2 + 4\nI9: ADDI $3, $3, -1 # $3 = $3 \u2013 1\nI10: BNE $3, $0, Loop # if ($3 != 0) goto Loop\n",
        "context_figures": [],
        "question": "Reorder the instructions of the above loop to fill the load-delay and the branch delay slots, without changing the computation. Write the code of the modified loop.",
        "solution": "ADDI $3, $0, 100 # $3 = 100\nADD $4, $0, $0 # $4 = 0\nLoop:\nLW $5, 0($1) # $5 = MEM[$1]\nLW $6, 0($2) # Moved earlier to avoid load-delay\nADDI $3, $3, -1 # Moved earlier\nADD $4, $4, $5 # $4 = $4 + $5\nADDI $1, $1, 4 # $1 = $1 + 4\nADDI $2, $2, 4 # $2 = $2 + 4\nBNE $3, $0, Loop # if ($3 != 0) goto Loop\nSUB $4, $4, $6 # Fills branch delay slot",
        "solution_figures": [],
        "correctly_parsed": null
    },
    {
        "question_id": "CDA 4205 Computer Architecture Exam 2 Practice Solution-3/Problem_4/e",
        "context": "Use the following MIPS code fragment:\nI1: ADDI $3, $0, 100 # $3 = 100\nI2: ADD  $4, $0, $0 # $4 = 0\n\n\nLoop:\nI3: LW $5, 0($1) # $5 = MEM[$1]\nI4: ADD $4, $4, $5 # $4 = $4 + $5\nI5: LW $6, 0($2) # $6 = MEM[$2]\nI6: SUB $4, $4, $6 # $4 = $4 \u2013 $6\nI7: ADDI $1, $1, 4 # $1 = $1 + 4\nI8: ADDI $2, $2, 4 # $2 = $2 + 4\nI9: ADDI $3, $3, -1 # $3 = $3 \u2013 1\nI10: BNE $3, $0, Loop # if ($3 != 0) goto Loop\n",
        "context_figures": [],
        "question": "Compute the number of cycles and the average CPI to execute ALL the iteration of the modified loop. What is the speedup factor?",
        "solution": "There are 100 iterations\nEach iteration requires 8 cycles =\n8 cycles to start the 8 instructions in loop body + 0 stall cycles\nThere are 2 additional cycles to start the first 2 instructions before the loop\n+ 4 additional cycles to terminate the ADDI instruction in the last iteration.\nTherefore, total cycles = 100 * 8 + 6 (can be ignored) = 806 cycles \u2248 800 cycles\nTotal instruction executed = 2 + 8 * 100 = 802 instructions (counting first two)\nAverage CPI = 806 / 802 = 1.00\nIf we ignore first two instructions and the time to terminate last iteration then\nAverage CPI = 800/800 = 1.00 (almost same answer)\nSpeedup Factor = CPIpart-b/CPIpart-d = 1.88/1.00 = 1.88",
        "solution_figures": [],
        "correctly_parsed": null
    }
]