{
  "exam_name": "Computer Architecture Exam.pdf",
  "problem": "6",
  "problem_context": "In this question you will be asked to write a small subroutine using MIPS assembler. You will then write a second program that calls this subroutine more than once. A copy of Appendix-B of your text book containing all MIPS Instructions has been provided to you.",
  "problem_figures": [],
  "parts": [
    {
      "part": "a",
      "subproblem": [
        {
          "subproblem_question": "Write a subroutine called findmin that will return theminimum value of an array. The location of the array in memory (a0) and the length of the array (a1) will be passed as parameters. The minimum value will be returned in the register v0.",
          "subproblem_figures": []
        }
      ],
      "answer": [
        {
          "solution": "findmin: lw $t4, 0($a0) # t4 is minimum\naddi $t1, $0, 0 # loop counter t1 init 0\n\nloop: addi $t1,$t1,1 # t1 ++\nbeq $t1, $a1, done # loop reaches a1 --> done\nsll $t2,$t1,2 # byte addressing, multiply\nadd $t2,$t2,$a0 # address of $t1 th member\nlw $t3,0($t2) # load value from memory\nslt $t5, $t4,$t3 # compare to $t4\nbeq $t5,$0,updatemin # t3 is smaller\nj loop # repeat\n\nupdatemin: add $t4,$0,$t3 # update $t4\nj loop # continue loop\n\ndone: add $v0,$0,$t4 # move result to $t4\njr $ra # jump to $ra",
          "solution_figures": []
        }
      ]
    },
    {
      "part": "b",
      "subproblem": [
        {
          "subproblem_question": "Now that you have the subroutine findmin, write a small MIPS assembly subroutine that:\n• finds the minimum of a first array of 64 values starting from the address 0x0000 0400\n• finds the minimum of a second array of 64 values starting from the address 0x0000 0824\n• jumps to label (first) if the minimum value of the first array is greater than the minimum value of the second array otherwise execution jumps to label (second)\n• At the end, jump back to the calling program\n• If necessary, save values in stack before calling findmin.",
          "subproblem_figures": []
        }
      ],
      "answer": [
        {
          "solution": "sol: addi $sp, $sp, -4 # make room on stack\nsw $ra, 0($sp) # save ra\n\naddi $a0, $0, 0x0400 # first address\naddi $a1, $0, 64 # number of elements\njal findmin # v0=findmin(a0,a1)\nadd $s1,$0,$v0 # save result to $s1\n\naddi $a0, $0, 0x0824 # second address\naddi $a1, $0, 64 # number of elements\njal findmin # v0=findmin(a0,a1)\n\nslt $t0, $s1, $v0 # is $s1 less than v0\nbeq $t0, $0, first # no : jump to first\n\nsecond: # do something\nj end # jump over first\n\nfirst: # do something\n\nend: lw $ra, 0($sp) # restore ra\naddi $sp, $sp,4 # restore stack\njr $ra # jump to $ra",
          "solution_figures": []
        }
      ]
    }
  ]
}