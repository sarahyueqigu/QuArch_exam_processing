{
  "exam_name": "Computer Architecture Exam.pdf",
  "problem": "Problem 5",
  "problem_context": "Now the wide open design problem. The haunting elegance of the stack architecture has stayed in the back of your mind ever since the debate. Now that you have seen superscalar execution, register renaming, forwarding, Tomasulo and all that, you wonder \"why can't I apply these techniques to stack machines to find instruction level parallelism there too?\" You grab your favorite loop as a test case\n\nfor (i = 0; i < n; i++) A[i] = A[i] + alpha;\n\nwhich, of course, compiles as\n\nfor (ptr = A; ptr < &A[n]; ptr++) *ptr += alpha;\n\nOn entry to this loop there are three values at the Top of Stack:\nTOS-8: Alpha\nTOS-4: ArrayEnd\nTOS: Ptr\n\nThe stack code for the loop is as follows.\n\nvscal:\npush @0 ; push a copy of Ptr\nload ; Load the array value (replacing Ptr)\npush @12 ; push a copy of the scale value, alpha\nfadd ; alpha + *ptr\npush @4 ; push a copy of Ptr\nstore ; *ptr := alpha + *ptr\npushIm 4 ; pointer increment value\nadd ; ptr++ (update on the stack)\npush @4 ; push ArrayEnd\npush @4 ; push ptr\nsub\nblt vscal\n\nThe push @X instruction pushes the value at offset X from the top of stack. pushIM X pushes immediate value X. All other operations pop their operands from the top of stack, remove them, and push a result, if one is generated.\n\nYour starting point for your design is based roughly on the MIPS R10000. It has several function units with a reservation station per function unit and forwarding of results to the function units, as indicated in the diagram below. A large collection of physical registers are provided. They are not in the instruction set architecture. The architected state is the stack and PC. You are to describe how to do the renaming such that you could overlap the execution of multiple iterations of this loop. You will need to invent the mechanism to perform the necessary renaming. You may assume there are enough physical registers to perform one or more iterations of the loop, but not an arbitrary number of overlapping iterations. You may assume there is a mechanism ALLOC that will allocate a free register and provide that register number, if one is available. If none are free, it will indicate a failure. You may, similarly, assume there is an operation FREE(Reg) which frees the specified register.",
  "problem_figures": ["IMAGE"],
  "parts": [
    {
      "subproblem": [
        {
          "subproblem_question": "How much stack space is required to execute this loop? Because of this, you don't need to worry about stack overflow/underflow. You do need to deal with limits on the available physical registers and function units."
        }
      ],
      "answer": []
    },
    {
      "subproblem": [
        {
          "subproblem_question": "Describe the instruction issue and operand fetch process for different kinds of instructions that appear in the example."
        }
      ],
      "answer": []
    },