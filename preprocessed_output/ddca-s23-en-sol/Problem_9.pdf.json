{
    "problem": "9",
    "problem_context": "You are the human compiler for a VLIW processor whose specifications are as follows:\n\nThere are a total of 7 functional units: 3 load units, 1 store unit, 1 addition unit, 1 multiplication unit, and 1 branch unit.\n\nThe VLIW processor can only execute assembly operations listed in Table 1. The table shows the instructions that each functional unit can execute and each instruction's semantics. Note that the load_inc/store_inc instructions automatically increment the address source register rsrc2 by 1, after data is loaded/stored.\n\nAll assembly operations have a 1-cycle latency (including load, load_inc, store, and store_inc).\n\nThis machine has 32 registers (r0, r1, ..., r31).\n\nThe registers are read at the rising edge and written at the falling edge of the clock.\n\nThe memory is word-addressable (1 word = 4 bytes).\n\nThe VLIW processor operates at 1 GHz.\n\nFunctional Unit Type Operation (in assembly notation) Semantics\n\nload\n\nload rdst, [rsrc1, rsrc2, #offset] rdst := MEM[rsrc1 + rsrc2 + #offset]\n\nload_inc rdst, [rsrc1, rsrc2, #offset]\nrdst := MEM[rsrc1 + rsrc2 + #offset]\n\nrsrc2 := rsrc2 + 1\n\nstore\n\nstore [rsrc1, rsrc2, #offset], rsrc3 MEM[rsrc1 + rsrc2 + #offset] := rsrc3\n\nstore_inc [rsrc1, rsrc2, #offset], rsrc3\n\nMEM[rsrc1 + rsrc2 + #offset] := rsrc3\n\nrsrc2 := rsrc2 + 1\n\naddition add rdst, rsrc1, rsrc2 rdst := rsrc1 + rsrc2\n\nmultiplication mult rdst, rsrc1, rsrc2 rdst := rsrc1 \u00d7 rsrc2\n\nbranch bne rsrc1, #offset, TARGET branch to TARGET if rsrc1 is not equal to #offset\n\n(any of the above) NOP Functional unit is idle for one cycle\n\nTable 1: Assembly operations of the target VLIW processor. #offset indicates an immediate value.\n\nFigure 1 shows the C code and its equivalent assembly code for the application that we will execute in this VLIW processor. Assume that N is an even positive integer throughout this question.\n\nIn the assembly code, registers r29, r30, and r31 hold the base addresses of the C-code arrays A, B, and C, respectively. Register r0 is initialized with 0 and register r1 is initialized with 1.\n\nC code Assembly code\n\n// An integer is 4 bytes long\nint A[N+1];\nint B[N+1];\nint C[N+1];\n... // code to initialize A and B\nfor (int i = 1; i <= N; i++)\n\nC[i] = C[i - 1] * A[i] + B[i];\n\nLOOP:\n(v1) load_inc r2, [r31, r0, #0] // r2 := [r31 + r0 + #0]; r0 := r0 + 1\n(v2) load r3, [r29, r1, #0] // r3 := [r29 + r1 + #0]\n(v3) load r4, [r30, r1, #0] // r4 := [r30 + r1 + #0]\n(v4) mult r5, r2, r3 // r5 := r2 * r3\n(v5) add r6, r5, r4 // r6 := r5 + r4\n(v6) store_inc [r31, r1, #0], r6 // [r31 + r1 + #0] := r6; r1 := r1 + 1\n(v7) bne r1, #N, LOOP // branch to LOOP if r1 not equal to #N\n\nFigure 1: C and assembly codes. (v1) .. (v7) are instruction labels.",
    "subproblems": [
        {
            "subproblem": "a",
            "subproblem_question": "Your goal in this question is to statically schedule the instructions in Figure 1 to the VLIW processor specified above. Table 2 (on the next page) represents the occupancy of each functional unit during the execution of the assembly code in Figure 1.\n\nFor the assembly code given in Figure 1, fill in Table 2 with the appropriate VLIW instructions.\n\nIn your solution, minimize the number of VLIW instructions, and ensure that each instruction is scheduled to execute as soon as possible. Table 2 should only contain assembly operations supported by the VLIW processor, as described in Table 1.",
            "subproblem_solution": "Functional Unit\n\nVLIW Instruction Load Load Load Store Mult Add Branch\n\n1 LOOP: load_inc r2, [r31, r0, #0] load r3, [r29, r1, #0] load r4, [r30, r1, #0] NOP NOP NOP NOP\n\n2 NOP NOP NOP NOP mult r5, r2, r3 NOP NOP\n\n3 NOP NOP NOP NOP NOP add r6, r5, r4 NOP\n\n4 NOP NOP NOP store_inc [r31, r1, #0], r6 NOP NOP NOP\n\n5 NOP NOP NOP NOP NOP NOP bne r1, #N, LOOP",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "b",
            "subproblem_question": "What is the ratio between the number of useful operations and the number of VLIW instructions in your code? A useful operation refers to any assembly operation that is not a NOP.",
            "subproblem_solution": "7/5 useful operations per VLIW instruction.\n\nExplanation.\nThere are a total of 7 assembly operations (excluding NOPs) composing 5 VLIW instructions.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "c",
            "subproblem_question": "What is the execution time (in cycles) of the VLIW processor when executing the sequence of instructions in Table 2, as a function of the loop counter N? Show your work.",
            "subproblem_solution": "Execution time = 5\u00d7N.\n\nExplanation.\nA single iteration of the loop takes 5 clock cycles to execute. Since the loop repeats N times, the total execution time is equal to 5\u00d7N.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}