{
    "problem": "8",
    "problem_context": "Assume a vector processor that implements the following ISA:\n\nOpcode Operands Latency (cycles) Description\nSET Vst, #n 1 Vst \u2190 n (Vst = Vector Stride Register)\nSET Vln, #n 1 Vln \u2190 n (Vln = Vector Length Register)\nLDM Vi 1 VMSK \u2190 LSB(Vi) (VMSK = Vector Mask Register)\nVLD Vi, #A 50 row hit, 100 row miss, pipelined Vi \u2190Mem[Address]\nVST Vi, #A 50 row hit, 100 row miss, pipelined Mem[Address]\u2190 Vi\n\nVMUL Vi, Vj , Vk 10, pipelined Vi \u2190 Vj \u2217 Vk\n\nVADD Vi, Vj , Vk 5, pipelined Vi \u2190 Vj + Vk\n\nVSHFR Vi, Vj 10, pipelined Vi \u2190 Vj >> 1\nVNOT Vi 4, pipelined Vi \u2190 BitwiseNOT (Vi)\nVCMPZ Vi, Vj 4, pipelined if(Vj == 0) Vi \u2190 0xFFFF; else Vi \u2190 0x0000\n\nAssume the following:\n\n\u02c6 The processor has an in-order pipeline and issues one instruction per cycle.\n\n\u02c6 There are 8 vector registers (V0,V1,V2,V3,V4,V5,V6,V7), and the size of a vector element is 4 bytes.\n\n\u02c6 Vst and Vln are 10-bit registers.\n\n\u02c6 The processor does not support chaining between vector functional units.\n\n\u02c6 LDM moves the least-significant bit (LSB) of each vector element in a vector register Vi into the corresponding position in VMSK . This instruction is executed in one single cycle.\n\n\u02c6 The main memory is composed of N banks, and each bank has a row buffer of size 64 bits.\n\n\u02c6 All rows in main memory are initially closed (i.e., all banks are precharged).\n\n\u02c6 The memory is byte addressable, and the address space is represented using 32 bits.\n\n\u02c6 Vector elements are stored in memory in a 4-byte-aligned manner. The first element of a vector always starts at the beginning of a memory row.\n\n\u02c6 Vector elements stored in consecutive memory addresses are interleaved between the memory banks. E.g., if a vector element at address A maps to bank B, a vector element at A + 4 maps to bank (B + 1)%N , where % is the modulo operator and N is the number of banks. N is not necessarily a power of two.\n\n\u02c6 The latency of accessing memory is 100 cycles when the memory request misses in the row buffer, and 50 cycles when the memory request hits in the row buffer.\n\n\u02c6 Each memory bank has a single read and a single write port so that a load and a store operation can be performed simultaneously.\n\n\u02c6 There is one functional unit for executing VLD instructions and a separate functional unit for executing VST instructions. This means the load and store operations for different vectors cannot be overlapped.\n\n\u02c6 The operations on a vector do not affect the vector elements corresponding to the locations in the Vector Mask Register (VMSK) that are set to 0.",
    "subproblems": [
        {
            "subproblem": "a",
            "subproblem_question": "What should the minimum number of banks (N) be to avoid stalls while executing a VLD or VST instruction? Calculate the minimum number of banks for every stride from 1 to 10. Explain.",
            "subproblem_solution": "101 banks for even strides, 100 banks for odd strides\nExplanation.\nTo calculate the minimum value, we have to assume the worst case, which is when all memory accesses are row buffer misses (latency = 100). To avoid stalls, we need to ensure that consecutive vector elements access 100 different banks.\n\nWe illustrate the solution for even strides (2 and 4) and odd strides (1 and 3).\n\n101 banks are enough to avoid stalls with even numbers. For example, with a vector stride of 2, consecutive elements of a vector will map to banks 0, 2, 4 ... 96, 98, 100, 1, 3 ... 97, 99. With a vector stride of 4, consecutive elements of a vector will map to banks 0, 4, 8 ... 96, 100, 3, 7 ... 95, 99, 2, etc.\n\n100 banks are enough to avoid stalls with odd numbers. For example, with a vector stride of 1, consecutive elements of a vector will map to banks 0, 1, 2, 3 ... 98, 99. With a vector of stride 3, consecutive elements of a vector will map to banks 0, 3, 6 ... 96, 99, 2, 5 ... 95, 98\n\nSo, the minimum number of banks is 100 for odd strides, and 101 for even strides.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "b",
            "subproblem_question": "Translate the following loop into assembly code that can be executed in the least possible number of cycles in the previously described vector machine:\n\nfor i= 0 to 45:\nif(a[i] == 0):\n\nc[i] = b[i]\nelse:\n\nc[i] = a[i] * b[i] + a[i]/2\n\nAssume:\n\n\u2022 The same machine as in part (a).\n\n\u2022 In the for loop, 45 is inclusive, i.e., [0, 45]\n\n\u2022 The size of the elements of vectors a, b, and c is 4 bytes\n\n\u2022 Vectors a, b, and c do not share parts of the same DRAM row",
            "subproblem_solution": "SET Vst, 1 # Load Vector Stride Register\nSET Vln, 46 # Load Vector Length Register\nVLD V1, a # Read from array a\nVLD V2, b # Read from array b\nVCMPZ V3, V1 # Compare V1 to 0\nLDM V3 # Load Vector Mask Register\nVST c, V2 # Write to array c\nVNOT V3 # BitwiseNOT\nLDM V3 # Load Vector Mask Register\nVSHFR V4, V1 # Shift to divide\nVMUL V5, V1, V2 # Multiply\nVADD V6, V5, V4 # Add\nVST c, V6 # Write to array c",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "c",
            "subproblem_question": "What is the number of cycles the previous code takes to execute in the vector processor described in this question? Assume:\n\n\u2022 Vectors a and b are in different rows\n\n\u2022 A machine that has a memory with 8 banks.\n\n\u2022 The rest of the machine is the same as in part (a).",
            "subproblem_solution": "1822 cycles\nExplanation.\n\nThe memory accesses look like:\nbank0 --MISS-|--HIT--|--MISS--|--HIT--|--MISS--|--HIT--|\nbank1 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|--HIT--|\nbank2 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|--HIT--|\nbank3 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|--HIT--|\nbank4 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|--HIT--|\nbank5 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|--HIT--|\nbank6 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|\nbank7 --MISS--|--HIT--|--MISS--|--HIT--|--MISS--|\n\nTherefore, the latency of the load corresponds to the latency of the bank with the larger latency. In this case, bank 5 (300+150+5 = 455 cycles). The latency of a store is also 455 cycles.\n\nThe general picture is:\n\nSET: |-S-|\nSET: |-S-|\nVLD: |-----VLD-----|\nVLD: |-----VLD-----|\nVCMPZ: |VCMPZ|\nLDM: |L|\nVST: |-----VST-----|\nVNOT: |VNOT|\nLDM: |L|\nVSHFR: |VSHFR|\nVMUL: |VMUL|\nVADD: |VADD|\nVST: |-----VST-----|\n\nS = 1\nVLD_cycles = VST_cycles = 455\nVMUL_cycles = 10 + 45 = 55\nVCMPZ_cycles = 4 + 45 = 49\nVNOT_cycles = 4 + 45 = 49\nL = 1\nVSHFR = 10 + 45 = 55\nVADD = 5 + 45 = 50\n\nConsidering how the latency of some instructions is hidden by the other instructions, the total cycles can be calculated as:\ntotal_cycles = S + S + V LD_cycles + V LD_cycles + V ST_cycles + V ST_cycles = 1822 cycles",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}