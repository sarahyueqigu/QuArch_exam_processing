{
    "problem": "7",
    "problem_context": "Initials: Digital Design and Computer Architecture August 21st, 2023\n\nCode Listing 1 contains a piece of assembly code. Table 1 presents the execution timeline of this code.\n\n1 MOVI R1, X # R1 <- X\n2 MOVI R2, Y # R2 <- Y\n3 L1:\n4 MUL R4, R1, R1 # R4 <- R1 \u00d7 R1\n5 MUL R1, R1, R2 # R1 <- R1 \u00d7 R2\n6 ADD R4, R5, R6 # R4 <- R5 + R6\n7 ADD R5, R2, R4 # R5 <- R2 + R4\n8 SUBI R3, R1, 2048 # R3 <- R1 - 2048, set condition flags\n9 JNZ L1 # Jump to L1 if zero flag is NOT set\n10 MUL R1, R1, R2 # R1 <- R1 \u00d7 R2\n\nCode Listing 1: Assembly Program\n\nCycles\nInstructions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16\n\n1 MOVI R1, X F D E1 E2 E3 M W\n\n2 MOVI R2, Y F D E1 E2 E3 M W\n\n3 MUL R4, R1, R1 F D - E1 E2 E3 M W\n\n4 MUL R1, R1, R2 F - D E1 E2 E3 M W\n\n5 ADD R4, R5, R6 F D E1 E2 E3 M W\n\n6 ADD R5, R2, R4 F D - - E1 E2 E3 M W\n\n7 SUBI R3, R1, 2048 F - - D E1 E2 E3 M W\n\n8 JNZ L1 F D - - E1 ...\n\n9 ... ...\n\nTable 1: Execution timeline (F:Fetch, D:Decode, E:Execute, M:Memory, W:WriteBack)\n\nUse this information to reverse engineer the architecture of this microprocessor to answer the following questions. Answer the questions as precisely as possible. If the provided information is not sufficient to answer a question, answer \u201cUnknown\u201d and explain your reasoning clearly.",
    "subproblems": [
        {
            "subproblem": "a",
            "subproblem_question": "List the data forwarding paths between pipeline stages.",
            "subproblem_solution": "The result of E3 stage is forwarded to E1 stage (e.g., R1's value at clock cycle 6 and R4's value at clock cycle 11). The result of M stage is forwarded to E1 stage (e.g., R1's value at clock cycle 7.)\nThe result of E3 stage is forwarded to the condition registers (e.g., SUBI and JNZ at clock cycle 15).\nThere is no other information for any other data forwarding. Therefore, other data forwardings are unknown.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "b",
            "subproblem_question": "Does this machine use hardware interlocking or software interlocking? Explain.",
            "subproblem_solution": "Hardware interlocking. It detects data dependencies and stalls the pipeline accordingly without needing any software-induced NOPs.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "c",
            "subproblem_question": "Calculate the value of T (the clock cycle of the given snapshot). Show your work.",
            "subproblem_solution": "T = 82.\n\nExplanation.\nThe instruction MUL R4, R1, R1 is fetched for the first time at the clock cycle 3. After the first iteration of the loop, the instruction is fetched for the second time at the clock cycle 12.\n\nThe instruction JNZ L1 stalls at the Decode stage and delays MUL R4, R1, R1. Due to this delay, there are 10 cycles in between the Nth and (N+1)th times the instruction is fetched, after the first iteration of the loop.\n\nIf R1 = 1024, this instruction is fetched and executed 8 times so far.\n\nSince in cycle T the first instruction in the loop (MUL R4, R1, R1) is being fetched, no cycles of the 9th iteration have executed so far.\n\nThen, T = 12 + 7\u00d7 10 = 82",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "d",
            "subproblem_question": "Calculate the value of N (the total number of dynamic instructions fetched by the clock cycle T). Show your work.",
            "subproblem_solution": "N = 51.\n\nExplanation.\nLoop iterates for 8 times before the processor reaches clock cycle T.\n\nThere are two instructions before the loop starts.\n\nThen, N = 2 + 8\u00d7 6 + 1 = 51 (assuming that the instruction indices start from 1).",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "e",
            "subproblem_question": "Calculate the total execution time of the assembly code in Code Listing 1 until the completion in terms of the number of clock cycles. Show your work.",
            "subproblem_solution": "100 cycles.\n\nExplanation.\nUntil the end of the second iteration, the loop takes 19 cycles as shown above.\nThe steady-state throughput of an iteration after the first iteration is 6 instructions in 10 cycles.\n\nLoop will iterate until R1 becomes 2048, which means 9 iterations in total.\n\nThere is only one instruction after the loop, which takes 1 cycle to complete.\n\nThen, T = 19 + 8\u00d7 10 + 1 = 100",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}