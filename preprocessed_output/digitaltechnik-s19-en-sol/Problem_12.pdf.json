{
    "problem": "12",
    "problem_context": "Assume a machine with a two-bit global history register (GHR) shared by all branches, which starts with Not Taken, Not Taken (2'b00). Each pattern history table entry (PHTE) contains a 2-bit saturating counter. The saturating counter values are as follows: 2'b00 - Strongly Not Taken, 2'b01 - Weakly Not Taken, 2'b10 - Weakly Taken, 2'b11 - Strongly Taken. Assume the following piece of code runs on this machine. The code has two branches (labeled B1 and B2). When we say that a branch is taken, we mean that the code inside the curly brackets is executed. For the following questions, assume that this is the only block of code that will ever be run, and the loop-condition branch (B1) is resolved first in the iteration before the if-condition branch (B2). for (int i = 0; i < 1000000; i++) { /* B1 */ /* TAKEN PATH for B1 */ if (i % 3 == 0) { /* B2 */ j[i] = k[i] -1; /* TAKEN PATH for B2 */ } }",
    "subproblems": [
        {
            "subproblem": "a",
            "subproblem_question": "Is it possible to observe that the branch predictor mispredicts 100% of the times in the first 5 iterations of the loop? If yes, fill in the table below with all possible initial values each entry can take. We represent Not Taken with N, and Taken with T.",
            "subproblem_solution": "Yes, it is possible. The pattern after 5 iterations: TTTNTNTTTN. In order to be more clear, we add indices to each branch outcome in the pattern above, to represent their positions in the pattern: T1 T2 T3 N4 T5 N6 T7 T8 T9 N10 \u2022 For GHR=NN, the only observed branch is T1. Therefore, the PHTE for NN has to be either 00 or 01 so that the branch predictor mispredicts the taken branch. \u2022 For GHR=TT, the observed branches are T3 N4 T9 N10. The PHTE for TT has to be initialized to 01 in order to cause the predictor to always mispredict. This way, each N and T moves the saturating counter to their respective direction. This will cause misprediction for the next branch which is always in the opposite direction. \u2022 For GHR=TN, the observed branches are T5 T7. Thus, the initial PHTE value for TN has to be 00 to mispredict both taken branches. \u2022 For GHR=NT, the observed branches are T2 N6 T8. Similar to the TT entry, NT's PHTE has to be initialized 01.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "b",
            "subproblem_context": "At steady-state, we observe the following pattern which repeats over time: TTTNTN, with T representing Taken, and N representing Not Taken. When GHR pattern equals to NT or TT, the predictor will observe that the branch outcome will be either T or N. Therefore, no matter what the initial values for these two entries are in the pattern history table (PHT), only one of the branches can be predicted correctly. Thus prediction accuracy will never reach 100%.",
            "subproblem_question": "Explain how using local history registers instead of the global history register will help bring the prediction accuracy up to 100% during the steady state, by showing what each PHTE will saturate to.",
            "subproblem_solution": "For the outer loop, we will keep observing all Ts, and the counters will be set to 2'b11 for TT and lead to 100% accuracy for this branch. The second branch will keep observing this repeated pattern: TNN. So entry TN will be saturated to 2'b00, entry NN will saturate to 2'b11, and entry NT will saturate to 2'b00.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}