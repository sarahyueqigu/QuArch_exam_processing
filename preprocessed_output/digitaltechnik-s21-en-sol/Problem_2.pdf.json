{
    "problem": "2",
    "problem_context": "Verilog [60 points]",
    "subproblems": [
        {
            "subproblem": "2.1",
            "subproblem_context": "Complete the Verilog code [30 points]\n\nFor each numbered blank 1 - 5 in the following Verilog code, mark the choice below (i.e., one of options A, B, C, D) that makes the Verilog module operate as described in the comments. The resulting code must have correct syntax.",
            "subproblem_question": "1 module my_module (input clk, input rst,\n\n2 input[15:0] idata, input[1:0] op, 1 [31:0] odata);\n3\n\n4 2 nval = 32'd0; // defining a 32-bit signal with an initial value of 0\n5\n\n6 always@* begin\n7 case (op)\n8 2'b00:\n9 nval = odata + idata; // when 'op' is decimal 0, add 'idata' to\n10 // 'odata' and assign the result to 'nval'\n11 2'b01:\n12 nval = odata - idata; // when 'op' is decimal 1, subtract 'idata'\n13 // from 'odata' and assign the result to 'nval'\n14 2'b10:\n15 nval = idata; // when 'op' is decimal 2, assign 'idata' to 'nval'\n\n16 3 :\n\n17 nval = 0; // when 'op' is decimal 3, assign 0 to 'nval'\n18 endcase\n19 end\n20\n\n21 // executing the following always block on the rising edge of 'clk'\n22 always@ (posedge clk) begin\n23 if (rst)\n\n24 4 // resetting 'odata' to 0 for the next cycle\n25 else\n\n26 5 // assigning 'nval' to 'odata' for the next cycle\n\n27 end\n28 endmodule\n\n\nProvide your choice for each blank 1 - 5 below:\n\n1 : A. output B. output reg C. output wire D. input reg\n\n2 : A. reg[31:0] B. input[31:0] C. wire[31:0] D. int[31:0]\n\n3 : A. 2'b3 B. 3'b3 C. 2'h11 D. default\n\n4 : A. assign odata <= 0; B. assign odata = 0; C. odata == 0; D. odata <= 0;\n\n5 : A. assign odata <= nval; B. assign odata = nval; C. odata == nval; D. odata <= nval;",
            "subproblem_solution": "Explanation.\n\n1 : odata must be declared as an output signal since values are assigned to it in the second always block. It cannot be an input signal since inputs are read-only signals and no assignments are allowed to them. odata must be also declared as reg since the assignments are made inside an always block.\n\n2 : nval must be declared as reg[31:0] since values are assigned to it inside the first always block.\n3 : default is a correct choice since all other cases for a 2-bit values (i.e., 2'b00, 2'b01, and 2'b10) are defined in the case statement. The other choices are not correct since they do not properly specify the value of 3. For example, in 2'b3, the problem is that 3 is not a valid binary digit but 2'b must be followed by a 2-bit binary value.\n\n4 : Choices with assign are not valid since the assign keyword cannot be used in an always block. Choice C does not specify an assignment operator but an equality comparison, hence it is not a valid choice either. The correct choice is D, which assigns 0 to odata using non-blocking assignment operator.\n\n5 : The correct choice is D due to the same reasons as in 4 .",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "2.2",
            "subproblem_context": "What Does This Code Do? [30 points]\n\nYou are given a Verilog code that you are asked to analyze and find out what it does.",
            "subproblem_question": "1 module my_module2 (input clk, output[1:0] out);\n2\n\n3 reg state = 1'b0;\n4 reg[1:0] my_reg = 0;\n5\n\n6 always@(posedge clk) begin\n7 state <= &out ? ~state : state;\n8 end\n9\n\n10 always@(posedge clk) begin\n11 case(state)\n12 1'b0: begin\n13 my_reg <= my_reg + 1;\n14 end\n15 1'b1: begin\n16 my_reg <= my_reg - 1;\n17 end\n18 endcase\n19 end\n20\n\n21 assign out = my_reg;\n22 endmodule\n\n\nShow the values (as unsigned decimal numbers) that the out signal takes, starting from the initial state of the module, for 16 consecutive clock (i.e., clk) cycles. Explain your answer briefly.",
            "subproblem_solution": "out is equal to 0, 1, 2, 3, 0, 3, 2, 3, 0, 3, 2, 3, 0, 3, 2, 3 in the first 16 clock cycles.\n\nExplanation.\nThe module either increments or decrements my_reg depending on the state. When state is equal to 0, my_reg is incremented by 1 and otherwise decremented by 1. The value of my_reg is directly assigned to the out signal, and both signals are 2-bit wide.\nmy_reg and state are both initially 0. Therefore, in subsequent cycles, my_reg gets incremented until it reaches 3. During the next cycle, a new value for state is being computed (i.e., the inverse of state as \u223cstate). However, since the new value of the state is not updated until the next positive edge of the clk, the second always block reads state as 0, and thus my_reg gets incremented again to become 0 (the maximum value a 2-bit register can represent is 3 and incrementing my_reg one more time makes it 0).\nDuring the next cycle, state is 1 and my_reg is decremented back to 3. Since my_reg (and thus out) being 3 inverts state, state becomes 0 in the subsequent cycle and my_reg becomes 2 during the positive edge of clk when state is inverted. Then, my_reg gets incremented to 3 and 0 in the next consecutive cycles. Because state remains as 0 or 1 for two consecutive cycles and then gets inverted, the values of my_reg forever repeat the sequence of (0, 3, 2, 3, 0, 3, 2, 3, . . .).",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}