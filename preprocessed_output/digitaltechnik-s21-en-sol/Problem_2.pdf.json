{
    "problem": "2",
    "problem_context": "Verilog [60 points]",
    "subproblems": [
        {
            "subproblem": "2.1",
            "subproblem_context": "Complete the Verilog code",
            "subproblem_question": "For each numbered blank 1 - 5 in the following Verilog code, mark the choice below (i.e., one of options A, B, C, D) that makes the Verilog module operate as described in the comments. The resulting code must have correct syntax.\n\n1 module my_module (input clk, input rst, input[15:0] idata, input[1:0] op, 1 [31:0] odata);\n2  nval = 32\u2019d0; // defining a 32-bit signal with an initial value of 0\n3 always@* begin\n4 case (op)\n5 2\u2019b00:\n6 nval = odata + idata; // when \u2019op\u2019 is decimal 0, add \u2019idata\u2019 to \u2019odata\u2019 and assign the result to \u2019nval\u2019\n7 2\u2019b01:\n8 nval = odata - idata; // when \u2019op\u2019 is decimal 1, subtract \u2019idata\u2019 from \u2019odata\u2019 and assign the result to \u2019nval\u2019\n9 2\u2019b10:\n10 nval = idata; // when \u2019op\u2019 is decimal 2, assign \u2019idata\u2019 to \u2019nval\u2019\n11 3 :\n12 nval = 0; // when \u2019op\u2019 is decimal 3, assign 0 to \u2019nval\u2019\n13 endcase\n14 end\n15 // executing the following always block on the rising edge of \u2019clk\u2019\n16 always@ (posedge clk) begin\n17 if (rst)\n18 4 // resetting \u2019odata\u2019 to 0 for the next cycle\n19 else\n20 5 // assigning \u2019nval\u2019 to \u2019odata\u2019 for the next cycle\n21 end\n22 endmodule\n\nProvide your choice for each blank 1 - 5 below:\n\n1 : A. output B. output reg C. output wire D. input reg\n\n2 : A. reg[31:0] B. input[31:0] C. wire[31:0] D. int[31:0]\n\n3 : A. 2'b3 B. 3'b3 C. 2'h11 D. default\n\n4 : A. assign odata <= 0; B. assign odata = 0; C. odata == 0; D. odata <= 0;\n\n5 : A. assign odata <= nval; B. assign odata = nval; C. odata == nval; D. odata <= nval;",
            "subproblem_solution": "1 : odata must be declared as an output signal since values are assigned to it in the second always block. It cannot be an input signal since inputs are read-only signals and no assignments are allowed to them. odata must be also declared as reg since the assignments are made inside an always block.\n\n2 : nval must be declared as reg[31:0] since values are assigned to it inside the first always block.\n\n3 : default is a correct choice since all other cases for a 2-bit values (i.e., 2\u2019b00, 2\u2019b01, and 2\u2019b10) are defined in the case statement. The other choices are not correct since they do not properly specify the value of 3. For example, in 2\u2019b3, the problem is that 3 is not a valid binary digit but 2\u2019b must be followed by a 2-bit binary value.\n\n4 : Choices with assign are not valid since the assign keyword cannot be used in an always block. Choice C does not specify an assignment operator but an equality comparison, hence it is not a valid choice either. The correct choice is D, which assigns 0 to odata using non-blocking assignment operator.\n\n5 : The correct choice is D due to the same reasons as in 4.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "2.2",
            "subproblem_context": "What Does This Code Do?",
            "subproblem_question": "You are given a Verilog code that you are asked to analyze and find out what it does.\n\n1 module my_module2 (input clk, output[1:0] out);\n2 reg state = 1\u2019b0;\n3 reg[1:0] my_reg = 0;\n4 always@(posedge clk) begin\n5 state <= ~out ? ~state : state;\n6 end\n7 always@(posedge clk) begin\n8 case(state)\n9 1\u2019b0: begin\n10 my_reg <= my_reg + 1;\n11 end\n12 1\u2019b1: begin\n13 my_reg <= my_reg - 1;\n14 end\n15 endcase\n16 end\n17 assign out = my_reg;\n18 endmodule\n\nShow the values (as unsigned decimal numbers) that the out signal takes, starting from the initial state of the module, for 16 consecutive clock (i.e., clk) cycles. Explain your answer briefly.",
            "subproblem_solution": "out is equal to 0, 1, 2, 3, 0, 3, 2, 3, 0, 3, 2, 3, 0, 3, 2, 3 in the first 16 clock cycles.\n\nExplanation.\nThe module either increments or decrements my_reg depending on the state. When state is equal to 0, my_reg is incremented by 1 and otherwise decremented by 1. The value of my_reg is directly assigned to the out signal, and both signals are 2-bit wide.\nmy_reg and state are both initially 0. Therefore, in subsequent cycles, my_reg gets incremented until it reaches 3. During the next cycle, a new value for state is being computed (i.e., the inverse of state as ~state). However, since the new value of the state is not updated until the next positive edge of the clk, the second always block reads state as 0, and thus my_reg gets incremented again to become 0 (the maximum value a 2-bit register can represent is 3 and incrementing my_reg one more time makes it 0).\nDuring the next cycle, state is 1 and my_reg is decremented back to 3. Since my_reg (and thus out) being 3 inverts state, state becomes 0 in the subsequent cycle and my_reg becomes 2 during the positive edge of clk when state is inverted. Then, my_reg gets incremented to 3 and 0 in the next consecutive cycles. Because state remains as 0 or 1 for two consecutive cycles and then gets inverted, the values of my_reg forever repeat the sequence of (0, 3, 2, 3, 0, 3, 2, 3, ...).",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}