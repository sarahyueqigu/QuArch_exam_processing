{
    "problem": "8",
    "problem_context": "We define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are kept busy with active threads during the run of a program.\n\nThe following code segments are run on a GPU. We assume that (1) A resides in memory and is shared by all threads, (2) s resides in a register and is private to each thread, and (3) the code segments are correct (i.e., do not think about any correctness issues when answering this question).\n\nA warp in the GPU consists of 32 threads, and there are 32 SIMD lanes in the GPU. Each thread executes a single iteration of the outermost loop (with index i). Assume that the data values of the array A are already in vector registers so there are no memory loads and stores in this program. (Hint: Notice that there are 4 instructions in each iteration of the outermost loop of both code segments.)",
    "subproblems": [
        {
            "subproblem": "a",
            "subproblem_question": "How many warps does it take to execute these code segments?",
            "subproblem_solution": "32 warps.\n\nExplanation:\nThe number of warps is calculated as:\n#Warps = #Total_threads / #Warp_size\n\nwhere\n#Total_threads = 1024 = 2^10 (i.e., one thread per loop iteration),\nand\n#Warp_size = 32 = 2^5 (given).\n\nThus, the number of warps needed to run this program is:\n\n#Warps = 2^10 / 2^5 = 2^5 = 32.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "b",
            "subproblem_question": "What is the SIMD utilization of the first iteration of the inner loop (j = 0) for Code Segment 1? Show your work. (Hint: The warp scheduler does not issue instructions when no thread is active)",
            "subproblem_solution": "The utilization of the first iteration (j = 0) of Code Segment 1 is 7/8.\n\nExplanation:\nInstructions 1, 2, and 4 are executed by all threads in Code Segment 1.\n\nIn Code Segment 1, s = 1 during the first iteration. Thus, only even-numbered threads fulfill the predicate of the if statement, and only half of the threads of each warp execute Instruction 3.\nCode Segment 1, j = 0: SIMD_utilization = (1024+1024+512+1024) / (1024+1024+1024+1024) = 7/8.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "c",
            "subproblem_question": "What is the SIMD utilization of the first iteration of the inner loop (j = 0) for Code Segment 2? Show your work. (Hint: The warp scheduler does not issue instructions when no thread is active)",
            "subproblem_solution": "The utilization of the first iteration (j = 0) of Code Segment 2 is 100%.\n\nExplanation:\nInstructions 1, 2, and 4 are executed by all threads in Code Segment 2.\n\nIn Code Segment 2, s = 512 during the first iteration. Thus, only threads with i < 512 fulfill the predicate of the if statement, and all threads of only half of the warps execute Instruction 3.\nCode Segment 2, j = 0: SIMD_utilization = (1024+1024+512+1024) / (1024+1024+512+1024) = 7/7 = 100%.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "d",
            "subproblem_question": "What is the SIMD utilization of any iteration of the inner loop (0 <= j < 10) for Code Segment 1? Show your work. (Hint: Derive an analytical expression, which may be piecewise)",
            "subproblem_solution": "As mentioned in part (b), Instructions 1, 2, and 4 are executed by all threads.\n\nIn Code Segment 1, with 0 <= j < 5, all 32 warps are active, but the number of active threads per warp divides by half in each iteration. With 5 <= j < 10, only one thread per warp is active, and the number of active warps divides by half in each iteration. As a result:\n\nCode Segment 1, iteration j:\n\nSIMD_utilization = {\n    (3072+2*(9-j)) / 4096, if 0 <= j < 5\n    (3072+2*(9-j)) / (3072+32*2*(9-j)), if 5 <= j < 10\n}",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "e",
            "subproblem_question": "What is the SIMD utilization of any iteration of the inner loop (0 <= j < 10) for Code Segment 2? Show your work. (Hint: Derive an analytical expression, which may be piecewise)",
            "subproblem_solution": "As mentioned in part (b), Instructions 1, 2, and 4 are executed by all threads.\n\nIn Code Segment 2, with 0 <= j < 5, all 32 threads per warp are active, but the number of active warps divides by half in each iteration. With 5 <= j < 10, only one warp is active, and the number of active threads divides by half in each iteration. As a result:\n\nCode Segment 2, iteration j:\n\nSIMD_utilization = {\n    (3072+32*2*(4-j)) / 3072+32*2*(4-j) = 100%, if 0 <= j < 5\n    (3072+2*(9-j)) / 3072+32, if 5 <= j < 10\n}",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "f",
            "subproblem_question": "Is there any iteration (0 <= j < 10) where both code segments have the same utilization? Explain your reasoning.",
            "subproblem_solution": "Yes, with j = 9 only one thread of only one warp is active, since only one thread (out of 1024) is needed to perform the last addition.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "g",
            "subproblem_question": "Which code is expected to run faster on a GPU? Explain your reasoning.",
            "subproblem_solution": "Code Segment 2 is faster because it has less intra-warp divergence, and thus higher SIMD utilization. In each iteration (except the last one), the number of warps that Code Segment 2 schedules is smaller than the number of warps that Code Segment 1 schedules. This results in fewer execution cycles.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}