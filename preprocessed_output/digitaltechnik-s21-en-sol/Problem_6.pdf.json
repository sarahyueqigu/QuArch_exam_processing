{
    "problem": "6",
    "problem_context": "Pipelining [65 points]\n\nConsider two pipelined machines implementing the MIPS ISA, Machine A and Machine B. Both machines have one ALU and the following five pipeline stages, very similar to the basic 5-stage pipelined MIPS processor we discussed in lectures:\n\n1. Fetch (one clock cycle)\n\n2. Decode (one clock cycle)\n\n3. Execute (one clock cycle)\n\n4. Memory (one clock cycle)\n\n5. Write-back (one clock cycle).\n\nMachines A and B have the following specifications:\n\nMachine A Machine B\n\nData Forward-ing/Inter-locking: Does NOT implement interlocking in hardware. Relies on the compiler to order instructions or insert nop instructions such that dependent instructions are correctly executed. | Implements data dependence detection and data forwarding in hardware. On detection of instruction dependence, it forwards an operand from the memory stage or from the write-back stage to the execute stage. The result of a load instruction (lw) can only be forwarded from the write-back stage.\n\nInternal register file forwarding: Implemented (i.e., an instruction writes into a register in the first half of a cycle and another instruction can correctly access the same register in the second half of the cycle). | Same as Machine A\n\nBranch Prediction: Predicts all branches as always-taken, and the next program counter is available after the decode stage. | Same as Machine A\n\nConsider the following code segment:\n\nLoop: lw $1, 0($4)\nlw $2, 400($4)\nadd $3, $1, $2\nsw $3, 0($4)\nsub $4, $4, #4\nbnez $4, Loop\n\nInitially, $1 = 0, $2 = 0, $3 = 0, and $4 = 400.",
    "subproblems": [
        {
            "subproblem": "a",
            "subproblem_question": "Re-write the code segment above with minimal changes so that it gets correctly executed in Machine A with minimal latency. You can either insert nop instructions or reorder instructions as needed.",
            "subproblem_solution": "Loop: lw $1, 0($4)\nlw $2, 400($4)\nnop\nnop\nadd $3, $1, $2\nnop\nnop\nsw $3, 0($4)\nsub $4, $4, #4\nnop\nnop\nbnez $4, Loop",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "b",
            "subproblem_question": "Fill the table below with the timeline of the first loop iteration of the code segment in Machine A.",
            "subproblem_solution": "Instruction | Clock cycle number\n           | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\nlw $1, 0($4) | F D E M W\nlw $2, 400($4) |   F D E M W\nnop |     F D E M W\nnop |       F D E M W\nadd $3, $1, $2 |         F D E M W\nnop |           F D E M W\nnop |             F D E M W\nsw $3, 0($4) |               F D E M W\nsub $4, $4, #4 |                 F D E M W\nnop |                   F D E M W\nnop |                     F D E M W\nbnez $4, Loop |                       F D E M W",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "c",
            "subproblem_question": "Calculate the number of cycles it takes to execute the code segment on Machine A. Show your work in the box.",
            "subproblem_solution": "Total number of cycles: 1303.\n\nExplanation:\nThe compiler reorders instructions and places six nop-s.\nThis is the execution timeline of the first iteration:\n\nEach iteration consists of 12 instructions. Since the next program counter is available\nafter the decode stage of bnez, the next iteration starts with an additional delay of 1\ncycle.\nThe last iteration takes 16 cycles, to drain the pipeline.\nThus the entire program runs for 99 * 13 + 16 = 1303 cycles.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "d",
            "subproblem_question": "Fill the table below with the timeline of the first loop iteration of the code segment in Machine B.",
            "subproblem_solution": "Instruction | Clock cycle number\n           | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19\nlw $1, 0($4) | F D E M W\nlw $2, 400($4) |   F D E M W\nadd $3, $1, $2 |     F D * E M W\nsw $3, 0($4) |       F * D E M W\nsub $4, $4, #4 |         F D E M W\nbnez $4, Loop |           F D E M W\nlw $1, 0($4) |             * F D E M W",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "e",
            "subproblem_question": "Calculate the number of cycles it takes to execute the code segment on Machine B. Show your work in the box.",
            "subproblem_solution": "Total number of cycles: 803.\n\nExplanation:\n1 - Foward $2 from W to E in cycle 6.\n2 - Foward $3 from M to E in cycle 7.\n3 - Foward $4 from M to E in cycle 9.\n\nEach iteration takes 8 cycles, including one cycle delay after bnez, because to the next\nprogram counter is available only after the decode stage of bnez.\nThe last iteration takes 11 cycles, to drain the pipeline.\nThus total number of cycles is 99*8 + 11 = 803 cycles.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}