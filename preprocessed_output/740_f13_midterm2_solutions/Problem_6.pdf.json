{
    "problem": "6",
    "problem_context": "As described in class, Hyperblock scheduling uses predication support to replace unbiased branches with predicates, which enables larger code blocks.\n\nOne optimization that can be applied to Hyperblock is Instruction Promotion. Instruction Promotion hoists the operation from a predicated instruction and replaces the original predicated instruction with a conditional move. With Instruction Promotion, operations can be scheduled and issued before their corresponding predicates are determined. Below shows an example of Instruction Promotion.\nBefore:\n\ncmplt B6,B7-> B0\n[B0] ld MEM1-> A5\n[!B0] ld MEM2-> A5\n\nnop 4\naddi A5,8 -> A8\n\nAfter Instruction Promotion:\n\nld MEM1-> A5\nld MEM2-> A6\ncmplt B6,B7-> B0\n\n[!B0] mv A6-> A5\nnop 4\naddi A5,8 -> A8\n\nAssume we run this code on a processor that supports predication but can only issue a predicated instruction after its corresponding predicate has been resolved.",
    "subproblems": [
        {
            "subproblem": "A",
            "subproblem_question": "In one sentence, in terms of code optimizations, explain what benefit does larger scheduling code blocks provide?",
            "subproblem_solution": "Larger scheduling code blocks enable greater flexibility for instruction scheduling.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "B",
            "subproblem_question": "For the example above, can Instruction Promotion ever improve system performance? Why or why not?",
            "subproblem_solution": "Yes it can. With Instruction Promotion, the program can hide some of the load latency.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "C",
            "subproblem_question": "For the example above, can Instruction Promotion ever degrade system performance? Why or why not?",
            "subproblem_solution": "Yes it can. Instruction Promotion: (1) introduces extra instructions and (2) can increase register pressure. [Note that extra instructions may not always increase register pressure]",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        },
        {
            "subproblem": "D",
            "subproblem_context": "The graph above shows the performance comparison of a program optimized using Hyperblock and Superblock respectively with different issue widths. With all other factors being equal, as the figure shows, when the issue width is low, Superblock provides higher speedup than Hyperblock. However, when the issue width is high, Hyperblock provides higher speedup than Superblock.",
            "subproblem_question": "Explain why this can happen?",
            "subproblem_solution": "A wider issue width can tolerate the wasted instructions in a hyperblock, but does not benefit the superblock (all else being equal).\n\nA more detailed explanation: Hyperblock uses predication which increases the total number of instructions to execute. When the issue width is low, executing extra predicated instructions requires extra work, which slows down the processor as all resources of the processor has already been fully utilized. When the issue width is high, however, Hyperblock provides a greater number of independent instructions from the multiple paths of control to fill the available processor resources. As Hyperblock also enables larger code blocks for better optimization for unbiased branches, Hyperblock provides better speedup.",
            "subproblem_context_figures": [],
            "subproblem_solution_figures": []
        }
    ],
    "problem_context_figures": []
}