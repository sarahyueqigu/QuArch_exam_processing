{
    "pages": [
        {
            "page": 1,
            "text": "Name:\nFirst Name:\nStudent ID:\n                               1st session examination\n                          Design of Digital Circuits SS2013\n                                    (252-0014-00S)\n                      Markus P\u00a8\n                                 uschel, Frank K. G\u00a8\n                                                       urkaynak\nExamination Rules:\n  1. Written exam, 90 minutes total.\n  2. No books, no calculators, no computers or communication devices.     Five pages of\n     handwritten notes are allowed.\n  3. Write all your answers on this document, space is reserved for your answers after each\n     question. Blank pages are available at the end of the exam.\n  4. Put your Student ID card visible on the desk during the exam.\n  5. If you feel disturbed, immediately call an assistant.\n  6. Answers will only be evaluated if they are readable\n  7. Write with a black or blue pen (no pencil, no green or red color).\n  8. Show all your work.  For some questions, you may get partial credit even if the end\n     result is wrong due to a calculation mistake.\n        Question:    1      2     3      4      5      6     7      8    Total\n        Points:      5      10    15     10     12     5     12     6      75\n        Score:",
            "md": "# 1st session examination\n\n# Design of Digital Circuits SS2013\n\n# (252-0014-00S)\n\n# Markus P\u00a8uschel, Frank K. G\u00a8urkaynak\n\n# Examination Rules:\n\n1. Written exam, 90 minutes total.\n2. No books, no calculators, no computers or communication devices. Five pages of handwritten notes are allowed.\n3. Write all your answers on this document, space is reserved for your answers after each question. Blank pages are available at the end of the exam.\n4. Put your Student ID card visible on the desk during the exam.\n5. If you feel disturbed, immediately call an assistant.\n6. Answers will only be evaluated if they are readable.\n7. Write with a black or blue pen (no pencil, no green or red color).\n8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due to a calculation mistake.\n\n| Question: | 1 | 2  | 3  | 4  | 5  | 6 | 7  | 8 | Total |\n| --------- | - | -- | -- | -- | -- | - | -- | - | ----- |\n| Points:   | 5 | 10 | 15 | 10 | 12 | 5 | 12 | 6 | 75    |\n| Score:    |   |    |    |    |    |   |    |   |       |\n",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "1st session examination",
                    "md": "# 1st session examination",
                    "rows": null,
                    "bBox": {
                        "x": 188.82,
                        "y": 195.12,
                        "w": 217.1,
                        "h": 446.54
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits SS2013",
                    "md": "# Design of Digital Circuits SS2013",
                    "rows": null,
                    "bBox": {
                        "x": 135.79,
                        "y": 220.52,
                        "w": 340.11,
                        "h": 421.14
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(252-0014-00S)",
                    "md": "# (252-0014-00S)",
                    "rows": null,
                    "bBox": {
                        "x": 188.82,
                        "y": 256.29,
                        "w": 184.83,
                        "h": 407.44
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Markus P\u00a8uschel, Frank K. G\u00a8urkaynak",
                    "md": "# Markus P\u00a8uschel, Frank K. G\u00a8urkaynak",
                    "rows": null,
                    "bBox": {
                        "x": 189.41,
                        "y": 288.01,
                        "w": 232.99,
                        "h": 14.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Examination Rules:",
                    "md": "# Examination Rules:",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 350.96,
                        "w": 100.42,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1. Written exam, 90 minutes total.\n2. No books, no calculators, no computers or communication devices. Five pages of handwritten notes are allowed.\n3. Write all your answers on this document, space is reserved for your answers after each question. Blank pages are available at the end of the exam.\n4. Put your Student ID card visible on the desk during the exam.\n5. If you feel disturbed, immediately call an assistant.\n6. Answers will only be evaluated if they are readable.\n7. Write with a black or blue pen (no pencil, no green or red color).\n8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due to a calculation mistake.",
                    "md": "1. Written exam, 90 minutes total.\n2. No books, no calculators, no computers or communication devices. Five pages of handwritten notes are allowed.\n3. Write all your answers on this document, space is reserved for your answers after each question. Blank pages are available at the end of the exam.\n4. Put your Student ID card visible on the desk during the exam.\n5. If you feel disturbed, immediately call an assistant.\n6. Answers will only be evaluated if they are readable.\n7. Write with a black or blue pen (no pencil, no green or red color).\n8. Show all your work. For some questions, you may get partial credit even if the end result is wrong due to a calculation mistake.",
                    "rows": null,
                    "bBox": {
                        "x": 86.31,
                        "y": 375.37,
                        "w": 453.48,
                        "h": 288.36
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Question: | 1 | 2  | 3  | 4  | 5  | 6 | 7  | 8 | Total |\n| --------- | - | -- | -- | -- | -- | - | -- | - | ----- |\n| Points:   | 5 | 10 | 15 | 10 | 12 | 5 | 12 | 6 | 75    |\n| Score:    |   |    |    |    |    |   |    |   |       |",
                    "rows": [
                        [
                            "Question:",
                            "1",
                            "2",
                            "3",
                            "4",
                            "5",
                            "6",
                            "7",
                            "8",
                            "Total"
                        ],
                        [
                            "Points:",
                            "5",
                            "10",
                            "15",
                            "10",
                            "12",
                            "5",
                            "12",
                            "6",
                            "75"
                        ],
                        [
                            "Score:",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 86.45,
                        "w": 467.79,
                        "h": 599.35
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 2,
            "text": "Design of Digital Circuits                                            23rd of August 2013\n                             This page intentionally left blank\nFirst Session Exam                                                            Page 1 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\nThis page intentionally left blank\n\n# First Session Exam\n\nPage 1 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013\n\nThis page intentionally left blank",
                    "md": "23rd of August 2013\n\nThis page intentionally left blank",
                    "rows": null,
                    "bBox": {
                        "x": 221.37,
                        "y": 40.37,
                        "w": 318.22,
                        "h": 43.63
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "First Session Exam",
                    "md": "# First Session Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 734.23,
                        "w": 98.97,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 1 of 18",
                    "md": "Page 1 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 476.76,
                        "y": 734.23,
                        "w": 63.53,
                        "h": 12.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 3,
            "text": "Design of Digital Circuits                                           23rd of August 2013\n 1. (a) (3 points) You receive the following 12-bit binary sequence:\n                                     0000 0111 1100\n        Which decimal numbers are encoded in this sequence, if you were told that the\n        sequence contained:\n        Two 6-bit numbers using two\u2019s complement:                    1, \u22124\n        A single 12-bit unsigned number:                              124\n        Three 4-bit numbers using sign/magnitude:                   0, 7, \u22124\n    (b) (2 points) In the lecture, it was explained that the two\u2019s complement was the better\n        alternative to represent negative numbers. Name two main advantages of the two\u2019s\n        complement representation over a sign/magnitude representation:\n          Solution:\n             1. Zero is represented only once\n             2. Standard binary addition works with two\u2019s complement numbers without\n                additional effort\n             3. Associativity law holds\nFirst Session Exam                                                           Page 2 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# 1.\n\n# (a) (3 points)\n\nYou receive the following 12-bit binary sequence:\n\n0000 0111 1100\n\nWhich decimal numbers are encoded in this sequence, if you were told that the sequence contained:\n\n- Two 6-bit numbers using two\u2019s complement: 1, \u22124\n- A single 12-bit unsigned number: 124\n- Three 4-bit numbers using sign/magnitude: 0, 7, \u22124\n\n# (b) (2 points)\n\nIn the lecture, it was explained that the two\u2019s complement was the better alternative to represent negative numbers. Name two main advantages of the two\u2019s complement representation over a sign/magnitude representation:\n\nSolution:\n\n1. Zero is represented only once\n2. Standard binary addition works with two\u2019s complement numbers without additional effort\n3. Associativity law holds\n\n# First Session Exam\n\nPage 2 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "1.",
                    "md": "# 1.",
                    "rows": null,
                    "bBox": {
                        "x": 77.85,
                        "y": 72.0,
                        "w": 9.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) (3 points)",
                    "md": "# (a) (3 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "You receive the following 12-bit binary sequence:\n\n0000 0111 1100\n\nWhich decimal numbers are encoded in this sequence, if you were told that the sequence contained:\n\n- Two 6-bit numbers using two\u2019s complement: 1, \u22124\n- A single 12-bit unsigned number: 124\n- Three 4-bit numbers using sign/magnitude: 0, 7, \u22124",
                    "md": "You receive the following 12-bit binary sequence:\n\n0000 0111 1100\n\nWhich decimal numbers are encoded in this sequence, if you were told that the sequence contained:\n\n- Two 6-bit numbers using two\u2019s complement: 1, \u22124\n- A single 12-bit unsigned number: 124\n- Three 4-bit numbers using sign/magnitude: 0, 7, \u22124",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 92.21,
                        "w": 422.22,
                        "h": 128.04
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) (2 points)",
                    "md": "# (b) (2 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "In the lecture, it was explained that the two\u2019s complement was the better alternative to represent negative numbers. Name two main advantages of the two\u2019s complement representation over a sign/magnitude representation:\n\nSolution:\n\n1. Zero is represented only once\n2. Standard binary addition works with two\u2019s complement numbers without additional effort\n3. Associativity law holds",
                    "md": "In the lecture, it was explained that the two\u2019s complement was the better alternative to represent negative numbers. Name two main advantages of the two\u2019s complement representation over a sign/magnitude representation:\n\nSolution:\n\n1. Zero is represented only once\n2. Standard binary addition works with two\u2019s complement numbers without additional effort\n3. Associativity law holds",
                    "rows": null,
                    "bBox": {
                        "x": 77.85,
                        "y": 72.0,
                        "w": 462.07,
                        "h": 323.86
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "First Session Exam",
                    "md": "# First Session Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 734.23,
                        "w": 98.97,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 2 of 18",
                    "md": "Page 2 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 476.76,
                        "y": 734.23,
                        "w": 63.53,
                        "h": 12.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 4,
            "text": "Design of Digital Circuits                                          23rd of August 2013\n 2. The following Verilog code defines a combinational circuit. We are interested in finding\n    out the timing properties of this circuit.\n 1  module  gandalf ( input [3:0] a,       input e,   output  z);\n 2\n 3    wire  b,c,d;\n 4    reg f;\n 5\n 6    assign  d = \u02dc(a[3] & (a[2] | b));\n 7\n 8    always  @ (*)\n 9      f <= a[3] & b;\n10\n11    assign  z = (\u02dce) ? d : f;\n12    assign  b = a[0] & a[1];\n13\n14  endmodule\n    The circuit is implemented using only the following basic logic building blocks: 2-input\n    AND, 2-input OR, 2:1 Multiplexer, Inverter. The delay from any input to the output\n    for each basic building block is given in the table below:\n                              Description         Delay  [ps]\n                              2-input AND gate           100\n                              2-input OR gate            120\n                              Inverter                    50\n                              2:1 Multiplexer            180\n    Continue to the next page.\nFirst Session Exam                                                         Page 3 of 18",
            "md": "# Design of Digital Circuits\n\n# 23rd of August 2013\n\n# 2.\n\nThe following Verilog code defines a combinational circuit. We are interested in finding out the timing properties of this circuit.\n\nmodule  gandalf ( input [3:0] a,       input e,   output  z);\n\nwire  b,c,d;\nreg f;\n\nassign  d = \u02dc(a[3] & (a[2] | b));\n\nalways  @ (*)\nf <= a[3] & b;\n\nassign  z = (\u02dce) ? d : f;\nassign  b = a[0] & a[1];\n\nendmodule\n\nThe circuit is implemented using only the following basic logic building blocks: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. The delay from any input to the output for each basic building block is given in the table below:\n\n| Description      | Delay \\[ps] |\n| ---------------- | ----------- |\n| 2-input AND gate | 100         |\n| 2-input OR gate  | 120         |\n| Inverter         | 50          |\n| 2:1 Multiplexer  | 180         |\n\nContinue to the next page.\n\nFirst Session Exam                                                         Page 3 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "23rd of August 2013",
                    "md": "# 23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 75.54,
                        "y": 40.37,
                        "w": 464.05,
                        "h": 240.49
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "2.",
                    "md": "# 2.",
                    "rows": null,
                    "bBox": {
                        "x": 79.19,
                        "y": 125.82,
                        "w": 4.0,
                        "h": 6.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "The following Verilog code defines a combinational circuit. We are interested in finding out the timing properties of this circuit.\n\nmodule  gandalf ( input [3:0] a,       input e,   output  z);\n\nwire  b,c,d;\nreg f;\n\nassign  d = \u02dc(a[3] & (a[2] | b));\n\nalways  @ (*)\nf <= a[3] & b;\n\nassign  z = (\u02dce) ? d : f;\nassign  b = a[0] & a[1];\n\nendmodule\n\nThe circuit is implemented using only the following basic logic building blocks: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. The delay from any input to the output for each basic building block is given in the table below:",
                    "md": "The following Verilog code defines a combinational circuit. We are interested in finding out the timing properties of this circuit.\n\nmodule  gandalf ( input [3:0] a,       input e,   output  z);\n\nwire  b,c,d;\nreg f;\n\nassign  d = \u02dc(a[3] & (a[2] | b));\n\nalways  @ (*)\nf <= a[3] & b;\n\nassign  z = (\u02dce) ? d : f;\nassign  b = a[0] & a[1];\n\nendmodule\n\nThe circuit is implemented using only the following basic logic building blocks: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. The delay from any input to the output for each basic building block is given in the table below:",
                    "rows": null,
                    "bBox": {
                        "x": 79.19,
                        "y": 86.45,
                        "w": 460.74,
                        "h": 362.78
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Description      | Delay \\[ps] |\n| ---------------- | ----------- |\n| 2-input AND gate | 100         |\n| 2-input OR gate  | 120         |\n| Inverter         | 50          |\n| 2:1 Multiplexer  | 180         |",
                    "rows": [
                        [
                            "Description",
                            "Delay [ps]"
                        ],
                        [
                            "2-input AND gate",
                            "100"
                        ],
                        [
                            "2-input OR gate",
                            "120"
                        ],
                        [
                            "Inverter",
                            "50"
                        ],
                        [
                            "2:1 Multiplexer",
                            "180"
                        ]
                    ],
                    "bBox": {
                        "x": 92.81,
                        "y": 326.35,
                        "w": 446.72,
                        "h": 122.88
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Continue to the next page.\n\nFirst Session Exam                                                         Page 3 of 18",
                    "md": "Continue to the next page.\n\nFirst Session Exam                                                         Page 3 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 112.27,
                        "w": 468.29,
                        "h": 633.96
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 5,
            "text": "Design of Digital Circuits                                            23rd of August 2013\n     (a) (4 points) Draw a gate-level circuit diagram of the circuit using only the following\n         basic logic gates: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. Note: there\n         is no need for optimizations.\n           Solution:\n           a[0]\n           a[1]                           Propagation Delay\n           a[2]                                                            1\n                                                                                      z\n                                                                           0\n           a[3]\n            e\n                                         Contamination Delay\n     (b) (3 points) Determine the propagation delay of the circuit. Draw it on your schematic,\n         and calculate the propagation delay using the delay values from the table.\n           Solution:\n                    tpd =         tpd,AN D + tpd,OR + tpd,AN D + tpd,IN V + tpd,M U X\n                        =                   100 ps + 120 ps + 100 ps + 50 ps + 180 ps\n                        =                                                      550 ps\n     (c) (3 points) Determine the contamination delay of the circuit.    Draw it on your\n         schematic, and calculate the contamination delay using the delay values from the\n         table.\n           Solution:\n                             tpd =                   tpd,IN V + tpd,M U X\n                                 =                         50 ps + 180 ps\n                                 =                                 230 ps\nFirst Session Exam                                                            Page 4 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# (a) (4 points)\n\nDraw a gate-level circuit diagram of the circuit using only the following basic logic gates: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. Note: there is no need for optimizations.\n\nSolution:\n\na[0]\na[1]                           Propagation Delay\na[2]                                                            1\nz\n0\na[3]\ne\nContamination Delay\n\n# (b) (3 points)\n\nDetermine the propagation delay of the circuit. Draw it on your schematic, and calculate the propagation delay using the delay values from the table.\n\nSolution:\n\ntpd =         tpd,AND + tpd,OR + tpd,AND + tpd,INV + tpd,MUX\n=                   100 ps + 120 ps + 100 ps + 50 ps + 180 ps\n=                                                      550 ps\n\n# (c) (3 points)\n\nDetermine the contamination delay of the circuit. Draw it on your schematic, and calculate the contamination delay using the delay values from the table.\n\nSolution:\n\ntpd =                   tpd,INV + tpd,MUX\n=                         50 ps + 180 ps\n=                                 230 ps\n\nFirst Session Exam\n\nPage 4 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 225.62
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 177.7
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) (4 points)",
                    "md": "# (a) (4 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Draw a gate-level circuit diagram of the circuit using only the following basic logic gates: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. Note: there is no need for optimizations.\n\nSolution:\n\na[0]\na[1]                           Propagation Delay\na[2]                                                            1\nz\n0\na[3]\ne\nContamination Delay",
                    "md": "Draw a gate-level circuit diagram of the circuit using only the following basic logic gates: 2-input AND, 2-input OR, 2:1 Multiplexer, Inverter. Note: there is no need for optimizations.\n\nSolution:\n\na[0]\na[1]                           Propagation Delay\na[2]                                                            1\nz\n0\na[3]\ne\nContamination Delay",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 86.45,
                        "w": 422.52,
                        "h": 433.54
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) (3 points)",
                    "md": "# (b) (3 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Determine the propagation delay of the circuit. Draw it on your schematic, and calculate the propagation delay using the delay values from the table.\n\nSolution:\n\ntpd =         tpd,AND + tpd,OR + tpd,AND + tpd,INV + tpd,MUX\n=                   100 ps + 120 ps + 100 ps + 50 ps + 180 ps\n=                                                      550 ps",
                    "md": "Determine the propagation delay of the circuit. Draw it on your schematic, and calculate the propagation delay using the delay values from the table.\n\nSolution:\n\ntpd =         tpd,AND + tpd,OR + tpd,AND + tpd,INV + tpd,MUX\n=                   100 ps + 120 ps + 100 ps + 50 ps + 180 ps\n=                                                      550 ps",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 129.52,
                        "w": 422.72,
                        "h": 451.74
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) (3 points)",
                    "md": "# (c) (3 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Determine the contamination delay of the circuit. Draw it on your schematic, and calculate the contamination delay using the delay values from the table.\n\nSolution:\n\ntpd =                   tpd,INV + tpd,MUX\n=                         50 ps + 180 ps\n=                                 230 ps\n\nFirst Session Exam\n\nPage 4 of 18",
                    "md": "Determine the contamination delay of the circuit. Draw it on your schematic, and calculate the contamination delay using the delay values from the table.\n\nSolution:\n\ntpd =                   tpd,INV + tpd,MUX\n=                         50 ps + 180 ps\n=                                 230 ps\n\nFirst Session Exam\n\nPage 4 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 129.52,
                        "w": 468.29,
                        "h": 616.71
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 6,
            "text": "Design of Digital Circuits                              23rd of August 2013\n 3. The following Verilog code defines a Finite State Machine (FSM).\n  1  module fsm ( input a , input b , output [1:0] z,\n  2             input clk, input reset);\n  3\n  4  reg [2:0] state, nextstate;\n  5\n  6  parameter INIT  = 3\u2019b000;\n  7  parameter DECODE = 3\u2019b001;\n  8  parameter LOOP  = 3\u2019b100;\n  9  parameter JUMP  = 3\u2019b111;\n 10  parameter NEXT  = 3\u2019b010;\n 11  //      DEF1    = 3\u2019b011;\n 12  //      DEF2    = 3\u2019b101;\n 13  //      DEF3    = 3\u2019b110;\n 14\n 15  // next state calculation\n 16  always @( * )\n 17   case (state)\n 18    INIT:    if ((a==1\u2019b0) & (b==1\u2019b0) ) nextstate = DECODE;\n 19             else                         nextstate = INIT;\n 20    DECODE:  if (a) nextstate = NEXT;\n 21             else   nextstate = LOOP;\n 22    LOOP:    nextstate = JUMP;\n 23    JUMP:    if (b) nextstate = INIT;\n 24             else   nextstate = DECODE;\n 25    NEXT:    nextstate = INIT;\n 26    default: nextstate = INIT;\n 27   endcase\n 28\n 29  // state register\n 30  always @ (posedge clk, negedge reset)\n 31    if   (reset == 1\u2019b0) state <= INIT;\n 32    else                 state <= nextstate;\n 33\n 34  // output logic\n 35   assign z = state[1:0];\n 36\n 37  endmodule\n     (a) (1 point) Is this a Moore or a Mealy FSM? Briefly explain.\n         Solution: Moore, outputs depend only on the present state and nothing else.\nFirst Session Exam                                            Page 5 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# 3. The following Verilog code defines a Finite State Machine (FSM).\n\nmodule fsm ( input a , input b , output [1:0] z,\ninput clk, input reset);\n\nreg [2:0] state, nextstate;\n\nparameter INIT  = 3\u2019b000;\nparameter DECODE = 3\u2019b001;\nparameter LOOP  = 3\u2019b100;\nparameter JUMP  = 3\u2019b111;\nparameter NEXT  = 3\u2019b010;\n//      DEF1    = 3\u2019b011;\n//      DEF2    = 3\u2019b101;\n//      DEF3    = 3\u2019b110;\n\n// next state calculation\nalways @( * )\ncase (state)\nINIT:    if ((a==1\u2019b0) & (b==1\u2019b0) ) nextstate = DECODE;\nelse                         nextstate = INIT;\nDECODE:  if (a) nextstate = NEXT;\nelse   nextstate = LOOP;\nLOOP:    nextstate = JUMP;\nJUMP:    if (b) nextstate = INIT;\nelse   nextstate = DECODE;\nNEXT:    nextstate = INIT;\ndefault: nextstate = INIT;\nendcase\n\n// state register\nalways @ (posedge clk, negedge reset)\nif   (reset == 1\u2019b0) state <= INIT;\nelse                 state <= nextstate;\n\n// output logic\nassign z = state[1:0];\n\nendmodule\n\n# (a) (1 point) Is this a Moore or a Mealy FSM? Briefly explain.\n\nSolution: Moore, outputs depend only on the present state and nothing else.\n\n# First Session Exam\n\nPage 5 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 75.54,
                        "y": 40.37,
                        "w": 464.05,
                        "h": 361.54
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "3. The following Verilog code defines a Finite State Machine (FSM).",
                    "md": "# 3. The following Verilog code defines a Finite State Machine (FSM).",
                    "rows": null,
                    "bBox": {
                        "x": 77.85,
                        "y": 72.0,
                        "w": 351.97,
                        "h": 58.92
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "module fsm ( input a , input b , output [1:0] z,\ninput clk, input reset);\n\nreg [2:0] state, nextstate;\n\nparameter INIT  = 3\u2019b000;\nparameter DECODE = 3\u2019b001;\nparameter LOOP  = 3\u2019b100;\nparameter JUMP  = 3\u2019b111;\nparameter NEXT  = 3\u2019b010;\n//      DEF1    = 3\u2019b011;\n//      DEF2    = 3\u2019b101;\n//      DEF3    = 3\u2019b110;\n\n// next state calculation\nalways @( * )\ncase (state)\nINIT:    if ((a==1\u2019b0) & (b==1\u2019b0) ) nextstate = DECODE;\nelse                         nextstate = INIT;\nDECODE:  if (a) nextstate = NEXT;\nelse   nextstate = LOOP;\nLOOP:    nextstate = JUMP;\nJUMP:    if (b) nextstate = INIT;\nelse   nextstate = DECODE;\nNEXT:    nextstate = INIT;\ndefault: nextstate = INIT;\nendcase\n\n// state register\nalways @ (posedge clk, negedge reset)\nif   (reset == 1\u2019b0) state <= INIT;\nelse                 state <= nextstate;\n\n// output logic\nassign z = state[1:0];\n\nendmodule",
                    "md": "module fsm ( input a , input b , output [1:0] z,\ninput clk, input reset);\n\nreg [2:0] state, nextstate;\n\nparameter INIT  = 3\u2019b000;\nparameter DECODE = 3\u2019b001;\nparameter LOOP  = 3\u2019b100;\nparameter JUMP  = 3\u2019b111;\nparameter NEXT  = 3\u2019b010;\n//      DEF1    = 3\u2019b011;\n//      DEF2    = 3\u2019b101;\n//      DEF3    = 3\u2019b110;\n\n// next state calculation\nalways @( * )\ncase (state)\nINIT:    if ((a==1\u2019b0) & (b==1\u2019b0) ) nextstate = DECODE;\nelse                         nextstate = INIT;\nDECODE:  if (a) nextstate = NEXT;\nelse   nextstate = LOOP;\nLOOP:    nextstate = JUMP;\nJUMP:    if (b) nextstate = INIT;\nelse   nextstate = DECODE;\nNEXT:    nextstate = INIT;\ndefault: nextstate = INIT;\nendcase\n\n// state register\nalways @ (posedge clk, negedge reset)\nif   (reset == 1\u2019b0) state <= INIT;\nelse                 state <= nextstate;\n\n// output logic\nassign z = state[1:0];\n\nendmodule",
                    "rows": null,
                    "bBox": {
                        "x": 75.54,
                        "y": 92.89,
                        "w": 410.18,
                        "h": 498.77
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) (1 point) Is this a Moore or a Mealy FSM? Briefly explain.",
                    "md": "# (a) (1 point) Is this a Moore or a Mealy FSM? Briefly explain.",
                    "rows": null,
                    "bBox": {
                        "x": 79.19,
                        "y": 97.82,
                        "w": 342.8,
                        "h": 523.26
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Solution: Moore, outputs depend only on the present state and nothing else.",
                    "md": "Solution: Moore, outputs depend only on the present state and nothing else.",
                    "rows": null,
                    "bBox": {
                        "x": 118.99,
                        "y": 336.78,
                        "w": 408.53,
                        "h": 312.93
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "First Session Exam",
                    "md": "# First Session Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 734.23,
                        "w": 98.97,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 5 of 18",
                    "md": "Page 5 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 75.54,
                        "y": 97.82,
                        "w": 464.75,
                        "h": 648.4
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 7,
            "text": "Design of Digital Circuits                                       23rd of August 2013\n    (b) (4 points) Draw the State Transition Diagram corresponding to the Verilog code\n        given above.\n          Solution:\n                 reset\n                                   a=0&b=0\n                                                             a=0\n                        \u0399\u039d\u0399\u03a4                  D\u0395COD\u0395\n                       z=00     a=1|b=1        z=01\n                                         a=1                         LOOP\n                                                                      z=00\n                                               b=0\n                              b=1\n                       \u039d\u0395\u03a7\u03a4                    JU\u039cP\n                       z=10                    z=11\nFirst Session Exam                                                      Page 6 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# (b) (4 points) Draw the State Transition Diagram corresponding to the Verilog code given above.\n\n# Solution:\n\nreset\n\n|      | a=0\\&b=0 |          | |\n| ---- | -------- | -------- |---|\n| \u0399\u039d\u0399\u03a4 | z=00     | a=1\\|b=1 |\n|      | a=1      |          | |\n| LOOP | z=00     |          | |\n|      | b=0      |          | |\n|      | b=1      |          | |\n| \u039d\u0395\u03a7\u03a4 | z=10     | JU\u039cP     | |\n|      | z=11     |          | |\n\nFirst Session Exam\n\nPage 6 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) (4 points) Draw the State Transition Diagram corresponding to the Verilog code given above.",
                    "md": "# (b) (4 points) Draw the State Transition Diagram corresponding to the Verilog code given above.",
                    "rows": null,
                    "bBox": {
                        "x": 96.06,
                        "y": 72.0,
                        "w": 443.85,
                        "h": 26.45
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Solution:",
                    "md": "# Solution:",
                    "rows": null,
                    "bBox": {
                        "x": 126.89,
                        "y": 115.07,
                        "w": 52.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "reset",
                    "md": "reset",
                    "rows": null,
                    "bBox": {
                        "x": 168.79,
                        "y": 131.45,
                        "w": 28.0,
                        "h": 9.0
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "|      | a=0\\&b=0 |          |   |\n| ---- | -------- | -------- | - |\n| \u0399\u039d\u0399\u03a4 | z=00     | a=1\\|b=1 |   |\n|      | a=1      |          |   |\n| LOOP | z=00     |          |   |\n|      | b=0      |          |   |\n|      | b=1      |          |   |\n| \u039d\u0395\u03a7\u03a4 | z=10     | JU\u039cP     |   |\n|      | z=11     |          |   |",
                    "rows": [
                        [
                            "",
                            "a=0&b=0",
                            "",
                            ""
                        ],
                        [
                            "\u0399\u039d\u0399\u03a4",
                            "z=00",
                            "a=1|b=1",
                            ""
                        ],
                        [
                            "",
                            "a=1",
                            "",
                            ""
                        ],
                        [
                            "LOOP",
                            "z=00",
                            "",
                            ""
                        ],
                        [
                            "",
                            "b=0",
                            "",
                            ""
                        ],
                        [
                            "",
                            "b=1",
                            "",
                            ""
                        ],
                        [
                            "\u039d\u0395\u03a7\u03a4",
                            "z=10",
                            "JU\u039cP",
                            ""
                        ],
                        [
                            "",
                            "z=11",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 468.29,
                        "h": 705.86
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "First Session Exam\n\nPage 6 of 18",
                    "md": "First Session Exam\n\nPage 6 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 734.23,
                        "w": 468.29,
                        "h": 12.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 8,
            "text": "Design of Digital Circuits                                   23rd of August 2013\n    (c) (5 points) Complete the following state transition table for the FSM described by\n        the Verilog code. To make writing easier, denote the state bits by S\u2082, S\u2081, S\u2080\n        and the nextstate bits by N\u2082, N\u2081, N\u2080. Note that the default behavior for the\n        nextstate  is to move to the INIT state. Since only five states have been de-\n        fined, there are three additional states which we named DEF1, DEF2, DEF3. As an\n        example, entries for these three default states and the NEXT state have been entered.\n                  State             Inputs           Next State\n         name       S\u2082   S\u2081    S\u2080   A    B     name      N\u2082    N\u2081    N\u2080\n         INIT       0     0    0    0    0     DECODE    0      0    1\n         INIT       0     0    0    0    1     INIT      0      0    0\n         INIT       0     0    0    1    0     INIT      0      0    0\n         INIT       0     0    0    1    1     INIT      0      0    0\n         DECODE     0     0    1    0    X     LOOP      1      0    0\n         DECODE     0     0    1    1    X     NEXT      0      1    0\n         LOOP       1     0    0    X    X     JUMP      1      1    1\n         JUMP       1     1    1    X    0     DECODE    0      0    1\n         JUMP       1     1    1    X    1     INIT      0      0    0\n         NEXT       0     1    0    X    X     INIT      0      0    0\n         DEF1       0     1    1    X    X     INIT      0      0    0\n         DEF2       1     0    1    X    X     INIT      0      0    0\n         DEF3       1     1    0    X    X     INIT      0      0    0\n        Note that there are different ways of writing this table to represent the same result.\nFirst Session Exam                                                 Page 7 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n(c) (5 points) Complete the following state transition table for the FSM described by the Verilog code. To make writing easier, denote the state bits by S\u2082, S\u2081, S\u2080 and the nextstate bits by N\u2082, N\u2081, N\u2080. Note that the default behavior for the nextstate is to move to the INIT state. Since only five states have been defined, there are three additional states which we named DEF1, DEF2, DEF3. As an example, entries for these three default states and the NEXT state have been entered.\n\n| State name | S\u2082 | S\u2081 | S\u2080 | A | B | Next State name | N\u2082 | N\u2081 | N\u2080 |\n| ---------- | -- | -- | -- | - | - | --------------- | -- | -- | -- |\n| INIT       | 0  | 0  | 0  | 0 | 0 | DECODE          | 0  | 0  | 1  |\n| INIT       | 0  | 0  | 0  | 0 | 1 | INIT            | 0  | 0  | 0  |\n| INIT       | 0  | 0  | 0  | 1 | 0 | INIT            | 0  | 0  | 0  |\n| INIT       | 0  | 0  | 0  | 1 | 1 | INIT            | 0  | 0  | 0  |\n| DECODE     | 0  | 0  | 1  | 0 | X | LOOP            | 1  | 0  | 0  |\n| DECODE     | 0  | 0  | 1  | 1 | X | NEXT            | 0  | 1  | 0  |\n| LOOP       | 1  | 0  | 0  | X | X | JUMP            | 1  | 1  | 1  |\n| JUMP       | 1  | 1  | 1  | X | 0 | DECODE          | 0  | 0  | 1  |\n| JUMP       | 1  | 1  | 1  | X | 1 | INIT            | 0  | 0  | 0  |\n| NEXT       | 0  | 1  | 0  | X | X | INIT            | 0  | 0  | 0  |\n| DEF1       | 0  | 1  | 1  | X | X | INIT            | 0  | 0  | 0  |\n| DEF2       | 1  | 0  | 1  | X | X | INIT            | 0  | 0  | 0  |\n| DEF3       | 1  | 1  | 0  | X | X | INIT            | 0  | 0  | 0  |\n\nNote that there are different ways of writing this table to represent the same result.\n\nFirst Session Exam\n\nPage 7 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 227.4,
                        "h": 186.13
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013\n\n(c) (5 points) Complete the following state transition table for the FSM described by the Verilog code. To make writing easier, denote the state bits by S\u2082, S\u2081, S\u2080 and the nextstate bits by N\u2082, N\u2081, N\u2080. Note that the default behavior for the nextstate is to move to the INIT state. Since only five states have been defined, there are three additional states which we named DEF1, DEF2, DEF3. As an example, entries for these three default states and the NEXT state have been entered.",
                    "md": "23rd of August 2013\n\n(c) (5 points) Complete the following state transition table for the FSM described by the Verilog code. To make writing easier, denote the state bits by S\u2082, S\u2081, S\u2080 and the nextstate bits by N\u2082, N\u2081, N\u2080. Note that the default behavior for the nextstate is to move to the INIT state. Since only five states have been defined, there are three additional states which we named DEF1, DEF2, DEF3. As an example, entries for these three default states and the NEXT state have been entered.",
                    "rows": null,
                    "bBox": {
                        "x": 97.36,
                        "y": 40.37,
                        "w": 442.99,
                        "h": 606.85
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| State name | S\u2082 | S\u2081 | S\u2080 | A | B | Next State name | N\u2082 | N\u2081 | N\u2080 |\n| ---------- | -- | -- | -- | - | - | --------------- | -- | -- | -- |\n| INIT       | 0  | 0  | 0  | 0 | 0 | DECODE          | 0  | 0  | 1  |\n| INIT       | 0  | 0  | 0  | 0 | 1 | INIT            | 0  | 0  | 0  |\n| INIT       | 0  | 0  | 0  | 1 | 0 | INIT            | 0  | 0  | 0  |\n| INIT       | 0  | 0  | 0  | 1 | 1 | INIT            | 0  | 0  | 0  |\n| DECODE     | 0  | 0  | 1  | 0 | X | LOOP            | 1  | 0  | 0  |\n| DECODE     | 0  | 0  | 1  | 1 | X | NEXT            | 0  | 1  | 0  |\n| LOOP       | 1  | 0  | 0  | X | X | JUMP            | 1  | 1  | 1  |\n| JUMP       | 1  | 1  | 1  | X | 0 | DECODE          | 0  | 0  | 1  |\n| JUMP       | 1  | 1  | 1  | X | 1 | INIT            | 0  | 0  | 0  |\n| NEXT       | 0  | 1  | 0  | X | X | INIT            | 0  | 0  | 0  |\n| DEF1       | 0  | 1  | 1  | X | X | INIT            | 0  | 0  | 0  |\n| DEF2       | 1  | 0  | 1  | X | X | INIT            | 0  | 0  | 0  |\n| DEF3       | 1  | 1  | 0  | X | X | INIT            | 0  | 0  | 0  |",
                    "rows": [
                        [
                            "State name",
                            "S\u2082",
                            "S\u2081",
                            "S\u2080",
                            "A",
                            "B",
                            "Next State name",
                            "N\u2082",
                            "N\u2081",
                            "N\u2080"
                        ],
                        [
                            "INIT",
                            "0",
                            "0",
                            "0",
                            "0",
                            "0",
                            "DECODE",
                            "0",
                            "0",
                            "1"
                        ],
                        [
                            "INIT",
                            "0",
                            "0",
                            "0",
                            "0",
                            "1",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "INIT",
                            "0",
                            "0",
                            "0",
                            "1",
                            "0",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "INIT",
                            "0",
                            "0",
                            "0",
                            "1",
                            "1",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "DECODE",
                            "0",
                            "0",
                            "1",
                            "0",
                            "X",
                            "LOOP",
                            "1",
                            "0",
                            "0"
                        ],
                        [
                            "DECODE",
                            "0",
                            "0",
                            "1",
                            "1",
                            "X",
                            "NEXT",
                            "0",
                            "1",
                            "0"
                        ],
                        [
                            "LOOP",
                            "1",
                            "0",
                            "0",
                            "X",
                            "X",
                            "JUMP",
                            "1",
                            "1",
                            "1"
                        ],
                        [
                            "JUMP",
                            "1",
                            "1",
                            "1",
                            "X",
                            "0",
                            "DECODE",
                            "0",
                            "0",
                            "1"
                        ],
                        [
                            "JUMP",
                            "1",
                            "1",
                            "1",
                            "X",
                            "1",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "NEXT",
                            "0",
                            "1",
                            "0",
                            "X",
                            "X",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "DEF1",
                            "0",
                            "1",
                            "1",
                            "X",
                            "X",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "DEF2",
                            "1",
                            "0",
                            "1",
                            "X",
                            "X",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ],
                        [
                            "DEF3",
                            "1",
                            "1",
                            "0",
                            "X",
                            "X",
                            "INIT",
                            "0",
                            "0",
                            "0"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 468.4,
                        "h": 705.86
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Note that there are different ways of writing this table to represent the same result.\n\nFirst Session Exam\n\nPage 7 of 18",
                    "md": "Note that there are different ways of writing this table to represent the same result.\n\nFirst Session Exam\n\nPage 7 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 214.5,
                        "w": 468.29,
                        "h": 531.73
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 9,
            "text": "Design of Digital Circuits                                            23rd of August 2013\n    (d) (1 point) For describing the nextstate is it better to use Products-of-Sums (POS)\n         or Sums-of-Products (SOP)? Briefly explain.\n          Solution:   Sums-of-Products, there are fewer entries with a 1 in them, and SOP\n          requires one entry for each\n     (e) (3 points) Write down the Boolean Equations for the nextstate bits N\u2082, N\u2081, N\u2080,\n         in either POS or SOP.\n         You don\u2019t need to minimize the equations.\n          Solution:\n          N\u2080 = S\u2082 S\u2081 S\u2080 A  ~~B</s> + S\u2082 S\u2081 S\u2080 + S\u2082 S\u2081 S\u2080  <s>B~~  \n          N\u2081 = S\u2082 S\u2081 S\u2080 A + S\u2082 S\u2081 S\u2080\n          N\u2082 = S\u2082 S\u2081 S\u2080  ~~A~~   + S\u2082 S\u2081 S\u2080\n     (f) (1 point) Briefly explain how the output z could be obtained in an actual circuit\n         implementation, what kind of logic circuit would be needed?\n          Solution: The output is directly obtained from the 2 least significant bits of\n          the state, or S\u2081 S\u2080.\nFirst Session Exam                                                            Page 8 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# (d) (1 point)\n\nFor describing the nextstate is it better to use Products-of-Sums (POS) or Sums-of-Products (SOP)? Briefly explain.\n\nSolution: Sums-of-Products, there are fewer entries with a 1 in them, and SOP requires one entry for each.\n\n# (e) (3 points)\n\nWrite down the Boolean Equations for the nextstate bits N\u2082, N\u2081, N\u2080, in either POS or SOP. You don\u2019t need to minimize the equations.\n\nSolution:\n\n- N\u2080 = S\u2082 S\u2081 S\u2080 A ~~B + S\u2082 S\u2081 S\u2080 + S\u2082 S\u2081 S\u2080 B~~\n- N\u2081 = S\u2082 S\u2081 S\u2080 A + S\u2082 S\u2081 S\u2080\n- N\u2082 = S\u2082 S\u2081 S\u2080 ~~A~~ + S\u2082 S\u2081 S\u2080\n\n# (f) (1 point)\n\nBriefly explain how the output z could be obtained in an actual circuit implementation, what kind of logic circuit would be needed?\n\nSolution: The output is directly obtained from the 2 least significant bits of the state, or S\u2081 S\u2080.\n\nFirst Session Exam\n\nPage 8 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) (1 point)",
                    "md": "# (d) (1 point)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "For describing the nextstate is it better to use Products-of-Sums (POS) or Sums-of-Products (SOP)? Briefly explain.\n\nSolution: Sums-of-Products, there are fewer entries with a 1 in them, and SOP requires one entry for each.",
                    "md": "For describing the nextstate is it better to use Products-of-Sums (POS) or Sums-of-Products (SOP)? Briefly explain.\n\nSolution: Sums-of-Products, there are fewer entries with a 1 in them, and SOP requires one entry for each.",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 86.45,
                        "w": 413.54,
                        "h": 143.71
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(e) (3 points)",
                    "md": "# (e) (3 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Write down the Boolean Equations for the nextstate bits N\u2082, N\u2081, N\u2080, in either POS or SOP. You don\u2019t need to minimize the equations.\n\nSolution:\n\n- N\u2080 = S\u2082 S\u2081 S\u2080 A ~~B + S\u2082 S\u2081 S\u2080 + S\u2082 S\u2081 S\u2080 B~~\n- N\u2081 = S\u2082 S\u2081 S\u2080 A + S\u2082 S\u2081 S\u2080\n- N\u2082 = S\u2082 S\u2081 S\u2080 ~~A~~ + S\u2082 S\u2081 S\u2080",
                    "md": "Write down the Boolean Equations for the nextstate bits N\u2082, N\u2081, N\u2080, in either POS or SOP. You don\u2019t need to minimize the equations.\n\nSolution:\n\n- N\u2080 = S\u2082 S\u2081 S\u2080 A ~~B + S\u2082 S\u2081 S\u2080 + S\u2082 S\u2081 S\u2080 B~~\n- N\u2081 = S\u2082 S\u2081 S\u2080 A + S\u2082 S\u2081 S\u2080\n- N\u2082 = S\u2082 S\u2081 S\u2080 ~~A~~ + S\u2082 S\u2081 S\u2080",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 115.07,
                        "w": 218.48,
                        "h": 187.31
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(f) (1 point)",
                    "md": "# (f) (1 point)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Briefly explain how the output z could be obtained in an actual circuit implementation, what kind of logic circuit would be needed?\n\nSolution: The output is directly obtained from the 2 least significant bits of the state, or S\u2081 S\u2080.\n\nFirst Session Exam\n\nPage 8 of 18",
                    "md": "Briefly explain how the output z could be obtained in an actual circuit implementation, what kind of logic circuit would be needed?\n\nSolution: The output is directly obtained from the 2 least significant bits of the state, or S\u2081 S\u2080.\n\nFirst Session Exam\n\nPage 8 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 115.07,
                        "w": 468.29,
                        "h": 631.15
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 10,
            "text": "Design of Digital Circuits                                          23rd of August 2013\n 4. (10 points) There are four Verilog code snippets in this section. Only one of these codes\n     is syntactically correct. All others have a problem with the syntax. For each code, first\n     state whether or not there is a mistake. If there is a mistake explain how to correct it.\n     Note: Assume that the behavior as described, is correct\n     (a)\n  1  module  one (input [1:0] sel,     input [3:0] data, output       z);\n  2\n  3    assign  z = sel[1] ? (sel[0] ? data[0] : data[3])\n  4                         : (sel[0] ? data[2] : data[1]);\n  5  endmodule\n      Solution:  This code is correct. The distribution of the data bits may seem strange,\n      but we are not checking for behviour.\n     (b)\n  1  module  mux2 ( input [1:0] i,     input sel,    output  z);\n  2\n  3    assign  z= (sel) ? i[1]:i[0];\n  4\n  5  endmodule\n  6\n  7  module  two ( input [3:0] data, input sel1, input sel2, output            z);\n  8\n  9    mux2 i0 (.i(data[1:0]), .sel(sel1), .z(m[0]) );\n 10    mux2 i1 (.i(data[3:2]), .sel(sel1), .z(m[1]) );\n 11    mux2 i2 (.i(m), .sel(sel2), .z(z) );\n 12\n 13  endmodule\n      Solution:  This code has mistakes. In module two there is an additional signal m\n      used. This has not been declared, it should be declared as wire [1:0] m;.\nFirst Session Exam                                                         Page 9 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# 4. (10 points)\n\nThere are four Verilog code snippets in this section. Only one of these codes is syntactically correct. All others have a problem with the syntax. For each code, first state whether or not there is a mistake. If there is a mistake explain how to correct it. Note: Assume that the behavior as described, is correct\n\n# (a)\n\n1  module  one (input [1:0] sel,     input [3:0] data, output       z);\n2\n3    assign  z = sel[1] ? (sel[0] ? data[0] : data[3])\n4                         : (sel[0] ? data[2] : data[1]);\n5  endmodule\n\nSolution:  This code is correct. The distribution of the data bits may seem strange, but we are not checking for behavior.\n\n# (b)\n\n1  module  mux2 ( input [1:0] i,     input sel,    output  z);\n2\n3    assign  z= (sel) ? i[1]:i[0];\n4\n5  endmodule\n6\n7  module  two ( input [3:0] data, input sel1, input sel2, output            z);\n8\n9    mux2 i0 (.i(data[1:0]), .sel(sel1), .z(m[0]) );\n10    mux2 i1 (.i(data[3:2]), .sel(sel1), .z(m[1]) );\n11    mux2 i2 (.i(m), .sel(sel2), .z(z) );\n12\n13  endmodule\n\nSolution:  This code has mistakes. In module two there is an additional signal m used. This has not been declared, it should be declared as wire [1:0] m;.\n\nFirst Session Exam                                                         Page 9 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 75.54,
                        "y": 40.37,
                        "w": 464.05,
                        "h": 469.5
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "4. (10 points)",
                    "md": "# 4. (10 points)",
                    "rows": null,
                    "bBox": {
                        "x": 75.54,
                        "y": 160.59,
                        "w": 7.65,
                        "h": 308.63
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "There are four Verilog code snippets in this section. Only one of these codes is syntactically correct. All others have a problem with the syntax. For each code, first state whether or not there is a mistake. If there is a mistake explain how to correct it. Note: Assume that the behavior as described, is correct",
                    "md": "There are four Verilog code snippets in this section. Only one of these codes is syntactically correct. All others have a problem with the syntax. For each code, first state whether or not there is a mistake. If there is a mistake explain how to correct it. Note: Assume that the behavior as described, is correct",
                    "rows": null,
                    "bBox": {
                        "x": 92.81,
                        "y": 86.45,
                        "w": 446.97,
                        "h": 40.89
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a)",
                    "md": "# (a)",
                    "rows": null,
                    "bBox": {
                        "x": 92.81,
                        "y": 134.76,
                        "w": 15.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1  module  one (input [1:0] sel,     input [3:0] data, output       z);\n2\n3    assign  z = sel[1] ? (sel[0] ? data[0] : data[3])\n4                         : (sel[0] ? data[2] : data[1]);\n5  endmodule\n\nSolution:  This code is correct. The distribution of the data bits may seem strange, but we are not checking for behavior.",
                    "md": "1  module  one (input [1:0] sel,     input [3:0] data, output       z);\n2\n3    assign  z = sel[1] ? (sel[0] ? data[0] : data[3])\n4                         : (sel[0] ? data[2] : data[1]);\n5  endmodule\n\nSolution:  This code is correct. The distribution of the data bits may seem strange, but we are not checking for behavior.",
                    "rows": null,
                    "bBox": {
                        "x": 79.19,
                        "y": 155.66,
                        "w": 451.06,
                        "h": 405.35
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b)",
                    "md": "# (b)",
                    "rows": null,
                    "bBox": {
                        "x": 92.81,
                        "y": 315.45,
                        "w": 16.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "1  module  mux2 ( input [1:0] i,     input sel,    output  z);\n2\n3    assign  z= (sel) ? i[1]:i[0];\n4\n5  endmodule\n6\n7  module  two ( input [3:0] data, input sel1, input sel2, output            z);\n8\n9    mux2 i0 (.i(data[1:0]), .sel(sel1), .z(m[0]) );\n10    mux2 i1 (.i(data[3:2]), .sel(sel1), .z(m[1]) );\n11    mux2 i2 (.i(m), .sel(sel2), .z(z) );\n12\n13  endmodule\n\nSolution:  This code has mistakes. In module two there is an additional signal m used. This has not been declared, it should be declared as wire [1:0] m;.\n\nFirst Session Exam                                                         Page 9 of 18",
                    "md": "1  module  mux2 ( input [1:0] i,     input sel,    output  z);\n2\n3    assign  z= (sel) ? i[1]:i[0];\n4\n5  endmodule\n6\n7  module  two ( input [3:0] data, input sel1, input sel2, output            z);\n8\n9    mux2 i0 (.i(data[1:0]), .sel(sel1), .z(m[0]) );\n10    mux2 i1 (.i(data[3:2]), .sel(sel1), .z(m[1]) );\n11    mux2 i2 (.i(m), .sel(sel2), .z(z) );\n12\n13  endmodule\n\nSolution:  This code has mistakes. In module two there is an additional signal m used. This has not been declared, it should be declared as wire [1:0] m;.\n\nFirst Session Exam                                                         Page 9 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 155.66,
                        "w": 468.29,
                        "h": 590.57
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 11,
            "text": "Design of Digital Circuits                                     23rd of August 2013\n    (c)\n 1  module three (input [1:0] sel,    output reg [7:0] z);\n 2\n 3   always   @ (sel)\n 4      if       (sel = 2\u2019b01) z=8\u2019b01010101;\n 5      else if  (sel = 2\u2019b10) z=8\u2019b10101010;\n 6      else                     z=8\u2019b00000000;\n 7\n 8  endmodule\n     Solution: This code has mistakes. The condition checking for sel has been written\n     as = which is an assignment. It should be == in both instances.\n    (d)\n 1  module four (input [1:0] sel,    input neg,   output reg [3:0] z);\n 2\n 3   always   @ (neg, sel)\n 4        if  (neg)     z = 4\u2019b1111;\n 5        else          z = 4\u2019b0000;\n 6        if  (sel[1]) z = 4\u2019b0001;\n 7        if  (sel[0]) z = 4\u2019b0010;\n 8\n 9  endmodule\n     Solution: This code has mistakes. There are 3 seperate if statements following\n     always. These should be within a begin ...    end block. Note that, it would\n     not be correct to have three separate always statements as this would mean driving\n     the signal z from three different processes.\nFirst Session Exam                                                   Page 10 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n1  module three (input [1:0] sel,    output reg [7:0] z);\n2\n3   always   @ (sel)\n4      if       (sel = 2\u2019b01) z=8\u2019b01010101;\n5      else if  (sel = 2\u2019b10) z=8\u2019b10101010;\n6      else                     z=8\u2019b00000000;\n7\n8  endmodule\n\nSolution: This code has mistakes. The condition checking for sel has been written as = which is an assignment. It should be == in both instances.\n\n(d)\n1  module four (input [1:0] sel,    input neg,   output reg [3:0] z);\n2\n3   always   @ (neg, sel)\n4        if  (neg)     z = 4\u2019b1111;\n5        else          z = 4\u2019b0000;\n6        if  (sel[1]) z = 4\u2019b0001;\n7        if  (sel[0]) z = 4\u2019b0010;\n8\n9  endmodule\n\nSolution: This code has mistakes. There are 3 separate if statements following always. These should be within a begin ... end block. Note that, it would not be correct to have three separate always statements as this would mean driving the signal z from three different processes.\n\n# First Session Exam\n\nPage 10 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013\n\n1  module three (input [1:0] sel,    output reg [7:0] z);\n2\n3   always   @ (sel)\n4      if       (sel = 2\u2019b01) z=8\u2019b01010101;\n5      else if  (sel = 2\u2019b10) z=8\u2019b10101010;\n6      else                     z=8\u2019b00000000;\n7\n8  endmodule\n\nSolution: This code has mistakes. The condition checking for sel has been written as = which is an assignment. It should be == in both instances.\n\n(d)\n1  module four (input [1:0] sel,    input neg,   output reg [3:0] z);\n2\n3   always   @ (neg, sel)\n4        if  (neg)     z = 4\u2019b1111;\n5        else          z = 4\u2019b0000;\n6        if  (sel[1]) z = 4\u2019b0001;\n7        if  (sel[0]) z = 4\u2019b0010;\n8\n9  endmodule\n\nSolution: This code has mistakes. There are 3 separate if statements following always. These should be within a begin ... end block. Note that, it would not be correct to have three separate always statements as this would mean driving the signal z from three different processes.",
                    "md": "23rd of August 2013\n\n1  module three (input [1:0] sel,    output reg [7:0] z);\n2\n3   always   @ (sel)\n4      if       (sel = 2\u2019b01) z=8\u2019b01010101;\n5      else if  (sel = 2\u2019b10) z=8\u2019b10101010;\n6      else                     z=8\u2019b00000000;\n7\n8  endmodule\n\nSolution: This code has mistakes. The condition checking for sel has been written as = which is an assignment. It should be == in both instances.\n\n(d)\n1  module four (input [1:0] sel,    input neg,   output reg [3:0] z);\n2\n3   always   @ (neg, sel)\n4        if  (neg)     z = 4\u2019b1111;\n5        else          z = 4\u2019b0000;\n6        if  (sel[1]) z = 4\u2019b0001;\n7        if  (sel[0]) z = 4\u2019b0010;\n8\n9  endmodule\n\nSolution: This code has mistakes. There are 3 separate if statements following always. These should be within a begin ... end block. Note that, it would not be correct to have three separate always statements as this would mean driving the signal z from three different processes.",
                    "rows": null,
                    "bBox": {
                        "x": 79.19,
                        "y": 40.37,
                        "w": 460.39,
                        "h": 487.67
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "First Session Exam",
                    "md": "# First Session Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 734.23,
                        "w": 98.97,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 10 of 18",
                    "md": "Page 10 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 79.19,
                        "y": 97.82,
                        "w": 461.1,
                        "h": 648.4
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 12,
            "text": "Design of Digital Circuits                                           23rd of August 2013\n 5. In this section, you will compare three structures to add 32-bit binary numbers in terms of\n    Latency, Throughput, Area and Maximum Operating Frequency. Assume the following\n    performance numbers for the components in the question.    Note that the registers are\n    considered ideal for timing: no propagation delay and no setup delay\n                  Description                     Delay  [ns]  Area    [\u03bcm\u00b2]\n                  32-bit Ripple Carry Adder              4.0           4\u2019000\n                  16-bit Ripple Carry Adder              2.0           2\u2019000\n                  32-bit Carry Lookahead Adder           2.5           6\u2019000\n                  64-bit register                        0.0           670\n                  49-bit register                        0.0           500\n                  32-bit register                        0.0           330\n    (a) (4 points) Consider the following 32-bit ripple carry adder pipeline stage and an-\n        swer the following questions:\n                      \u0391   32         32       32-bit\n                                              Ripple      32        32    \u0396\n                                              Carry\n                      B   32         32       \u0391dder\n          \u2022 What is the area occupied by the entire pipeline?\n          \u2022 How long does it take to compute one addition?\n          \u2022 What is the maximum operating frequency (in GHz) of this pipeline?\n          \u2022 How many additions can be completed in 1000 ns?\n          Solution:\n                                 Area =            AF F,64 + ARCA,\u2083\u2082 + AF F,32\n                                      =                    670 + 4000 + 330\n                                      =                                5000\n                              Latency =                                   4 ns\n                       M axF requency =                                 1/4 ns\n                                      =                          0.250 GHz\n                          T hroughput =                              1000/4 ns\n                                      =              250 additions per 1000 ns\n        Hint:  1 1 = 1 GHz, a clock with 1 GHz has a period of 1 ns.\n                ns\nFirst Session Exam                                                          Page 11 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n5. In this section, you will compare three structures to add 32-bit binary numbers in terms of Latency, Throughput, Area and Maximum Operating Frequency. Assume the following performance numbers for the components in the question. Note that the registers are considered ideal for timing: no propagation delay and no setup delay.\n\n| Description                  | Delay \\[ns] | Area \\[\u03bcm\u00b2] |\n| ---------------------------- | ----------- | ----------- |\n| 32-bit Ripple Carry Adder    | 4.0         | 4\u2019000       |\n| 16-bit Ripple Carry Adder    | 2.0         | 2\u2019000       |\n| 32-bit Carry Lookahead Adder | 2.5         | 6\u2019000       |\n| 64-bit register              | 0.0         | 670         |\n| 49-bit register              | 0.0         | 500         |\n| 32-bit register              | 0.0         | 330         |\n\n# (a) (4 points)\n\nConsider the following 32-bit ripple carry adder pipeline stage and answer the following questions:\n\n\u2022 What is the area occupied by the entire pipeline?\n\n\u2022 How long does it take to compute one addition?\n\n\u2022 What is the maximum operating frequency (in GHz) of this pipeline?\n\n\u2022 How many additions can be completed in 1000 ns?\n\n# Solution:\n\nArea = AF F,64 + ARCA,\u2083\u2082 + AF F,32\n\n= 670 + 4000 + 330\n\n= 5000\n\nLatency = 4 ns\n\nMax Frequency = 1/4 ns\n\n= 0.250 GHz\n\nThroughput = 1000/4 ns\n\n= 250 additions per 1000 ns\n\nHint: 1 GHz = 1 ns\n\nFirst Session Exam\n\nPage 11 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013\n\n5. In this section, you will compare three structures to add 32-bit binary numbers in terms of Latency, Throughput, Area and Maximum Operating Frequency. Assume the following performance numbers for the components in the question. Note that the registers are considered ideal for timing: no propagation delay and no setup delay.",
                    "md": "23rd of August 2013\n\n5. In this section, you will compare three structures to add 32-bit binary numbers in terms of Latency, Throughput, Area and Maximum Operating Frequency. Assume the following performance numbers for the components in the question. Note that the registers are considered ideal for timing: no propagation delay and no setup delay.",
                    "rows": null,
                    "bBox": {
                        "x": 77.85,
                        "y": 40.37,
                        "w": 462.62,
                        "h": 665.26
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Description                  | Delay \\[ns] | Area \\[\u03bcm\u00b2] |\n| ---------------------------- | ----------- | ----------- |\n| 32-bit Ripple Carry Adder    | 4.0         | 4\u2019000       |\n| 16-bit Ripple Carry Adder    | 2.0         | 2\u2019000       |\n| 32-bit Carry Lookahead Adder | 2.5         | 6\u2019000       |\n| 64-bit register              | 0.0         | 670         |\n| 49-bit register              | 0.0         | 500         |\n| 32-bit register              | 0.0         | 330         |",
                    "rows": [
                        [
                            "Description",
                            "Delay [ns]",
                            "Area [\u03bcm\u00b2]"
                        ],
                        [
                            "32-bit Ripple Carry Adder",
                            "4.0",
                            "4\u2019000"
                        ],
                        [
                            "16-bit Ripple Carry Adder",
                            "2.0",
                            "2\u2019000"
                        ],
                        [
                            "32-bit Carry Lookahead Adder",
                            "2.5",
                            "6\u2019000"
                        ],
                        [
                            "64-bit register",
                            "0.0",
                            "670"
                        ],
                        [
                            "49-bit register",
                            "0.0",
                            "500"
                        ],
                        [
                            "32-bit register",
                            "0.0",
                            "330"
                        ]
                    ],
                    "bBox": {
                        "x": 96.71,
                        "y": 146.82,
                        "w": 443.03,
                        "h": 425.11
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) (4 points)",
                    "md": "# (a) (4 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Consider the following 32-bit ripple carry adder pipeline stage and answer the following questions:\n\n\u2022 What is the area occupied by the entire pipeline?\n\n\u2022 How long does it take to compute one addition?\n\n\u2022 What is the maximum operating frequency (in GHz) of this pipeline?\n\n\u2022 How many additions can be completed in 1000 ns?",
                    "md": "Consider the following 32-bit ripple carry adder pipeline stage and answer the following questions:\n\n\u2022 What is the area occupied by the entire pipeline?\n\n\u2022 How long does it take to compute one addition?\n\n\u2022 What is the maximum operating frequency (in GHz) of this pipeline?\n\n\u2022 How many additions can be completed in 1000 ns?",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 146.82,
                        "w": 378.63,
                        "h": 558.81
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Solution:",
                    "md": "# Solution:",
                    "rows": null,
                    "bBox": {
                        "x": 126.89,
                        "y": 498.66,
                        "w": 52.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Area = AF F,64 + ARCA,\u2083\u2082 + AF F,32\n\n= 670 + 4000 + 330\n\n= 5000\n\nLatency = 4 ns\n\nMax Frequency = 1/4 ns\n\n= 0.250 GHz\n\nThroughput = 1000/4 ns\n\n= 250 additions per 1000 ns\n\nHint: 1 GHz = 1 ns\n\nFirst Session Exam\n\nPage 11 of 18",
                    "md": "Area = AF F,64 + ARCA,\u2083\u2082 + AF F,32\n\n= 670 + 4000 + 330\n\n= 5000\n\nLatency = 4 ns\n\nMax Frequency = 1/4 ns\n\n= 0.250 GHz\n\nThroughput = 1000/4 ns\n\n= 250 additions per 1000 ns\n\nHint: 1 GHz = 1 ns\n\nFirst Session Exam\n\nPage 11 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 146.82,
                        "w": 468.3,
                        "h": 599.41
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 13,
            "text": "Design of Digital Circuits                                         23rd of August 2013\n     (b) (2 points) Consider the following 32-bit carry lookahead pipeline stage and answer\n         the following questions:\n                      \u0391   32        32       32-bit\n                                             Carry       32        32   \u0396\n                                           Lookahead\n                      B   32        32       \u0391dder\n          \u2022 What is the area occupied by the entire pipeline?\n          \u2022 How long does it take to compute one addition?\n          \u2022 What is the maximum operating frequency (in GHz) of this pipeline?\n          \u2022 How many additions can be completed in 1000 ns?\n          Solution:\n                                Area =            AF F,64 + ACLA,32 + AF F,32\n                                     =                    670 + 6000 + 330\n                                     =                                7000\n                             Latency =                                 2.5 ns\n                      M axF requency =                               1/2.5 ns\n                                     =                          0.400 GHz\n                         T hroughput =                            1000/2.5 ns\n                                     =              400 additions per 1000 ns\nFirst Session Exam                                                        Page 12 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# (b) (2 points) Consider the following 32-bit carry lookahead pipeline stage and answer the following questions:\n\n| \u0391 | 32 | 32 | 32-bit | Carry | 32 | 32 | \u0396 |\n| - | -- | -- | ------ | ----- | -- | -- | - |\n| B | 32 | 32 | \u0391dder  |       |    |    |   |\n\n- What is the area occupied by the entire pipeline?\n- How long does it take to compute one addition?\n- What is the maximum operating frequency (in GHz) of this pipeline?\n- How many additions can be completed in 1000 ns?\n\n# Solution:\n\nArea = AF F,64 + ACLA,32 + AF F,32\n\n= 670 + 6000 + 330\n\n= 7000\n\nLatency = 2.5 ns\n\nMax Frequency = 1/2.5 ns\n\n= 0.400 GHz\n\nThroughput = 1000/2.5 ns\n\n= 400 additions per 1000 ns\n\nFirst Session Exam\n\nPage 12 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) (2 points) Consider the following 32-bit carry lookahead pipeline stage and answer the following questions:",
                    "md": "# (b) (2 points) Consider the following 32-bit carry lookahead pipeline stage and answer the following questions:",
                    "rows": null,
                    "bBox": {
                        "x": 96.06,
                        "y": 72.0,
                        "w": 444.08,
                        "h": 109.12
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| \u0391 | 32 | 32 | 32-bit | Carry | 32 | 32 | \u0396 |\n| - | -- | -- | ------ | ----- | -- | -- | - |\n| B | 32 | 32 | \u0391dder  |       |    |    |   |",
                    "rows": [
                        [
                            "\u0391",
                            "32",
                            "32",
                            "32-bit",
                            "Carry",
                            "32",
                            "32",
                            "\u0396"
                        ],
                        [
                            "B",
                            "32",
                            "32",
                            "\u0391dder",
                            "",
                            "",
                            "",
                            ""
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 468.3,
                        "h": 705.86
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "- What is the area occupied by the entire pipeline?\n- How long does it take to compute one addition?\n- What is the maximum operating frequency (in GHz) of this pipeline?\n- How many additions can be completed in 1000 ns?",
                    "md": "- What is the area occupied by the entire pipeline?\n- How long does it take to compute one addition?\n- What is the maximum operating frequency (in GHz) of this pipeline?\n- How many additions can be completed in 1000 ns?",
                    "rows": null,
                    "bBox": {
                        "x": 190.7,
                        "y": 170.12,
                        "w": 8.0,
                        "h": 11.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Solution:",
                    "md": "# Solution:",
                    "rows": null,
                    "bBox": {
                        "x": 126.89,
                        "y": 306.6,
                        "w": 52.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Area = AF F,64 + ACLA,32 + AF F,32\n\n= 670 + 6000 + 330\n\n= 7000\n\nLatency = 2.5 ns\n\nMax Frequency = 1/2.5 ns\n\n= 0.400 GHz\n\nThroughput = 1000/2.5 ns\n\n= 400 additions per 1000 ns\n\nFirst Session Exam\n\nPage 12 of 18",
                    "md": "Area = AF F,64 + ACLA,32 + AF F,32\n\n= 670 + 6000 + 330\n\n= 7000\n\nLatency = 2.5 ns\n\nMax Frequency = 1/2.5 ns\n\n= 0.400 GHz\n\nThroughput = 1000/2.5 ns\n\n= 400 additions per 1000 ns\n\nFirst Session Exam\n\nPage 12 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 128.49,
                        "w": 468.3,
                        "h": 617.73
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 14,
            "text": "Design of Digital Circuits                                           23rd of August 2013\n     (c) (2 points) Consider the following 32-bit adder with a 2 stage pipeline built out of\n        two 16-bit ripple carry adders and answer the following questions:\n                       16       16-bit      16                   16\n             32        16       Ripple\n         \u0391                      Carry      Carry          Carry\n                                \u0391dder                          16-bit                 32   \u0396\n         B   32                   16                  16       Ripple      16\n                                  16                  16       Carry\n                                                               \u0391dder\n           \u2022 What is the area occupied by the entire pipeline?\n           \u2022 How long does it take to compute one addition?\n           \u2022 What is the maximum operating frequency (in GHz) of this pipeline?\n           \u2022 How many additions can be completed in 1000 ns?\n          Solution:\n                           Area =     AF F,64 + ARCA,\u2081\u2086 + AF F,49 + ARCA,\u2081\u2086 + AF F,32\n                                =                   670 + 2000 + 500 + 2000 + 330\n                                =                                             5500\n                        Latency =                                                4 ns\n                 M axF requency =                                              1/2 ns\n                                =                                       0.500 GHz\n                    T hroughput =                                           1000/2 ns\n                                =                           500 additions per 1000 ns\n    (d) (4 points) The Latency  is the time it takes to calculate one addition, whereas the\n        Throughput   is the number of additions that can be calculated per unit time.  It\n        is obvious that the throughput will increase if you can reduce the latency.  Is it\n        possible to increase the throughput, even if you cannot reduce the latency? Briefly\n        explain.\n          Solution:  Yes. One solution is to introduce pipelining it is possible to improve\n          the throughput as seen in the section c) of this question. Pipelining does not\n          reduce latency, the computation of one data item still takes the same amount\n          of time, however, the operation is broken down into smaller pieces, and as soon\n          as the first part is completed, a new data item can be accepted, this improves\n          the throughput.   Another solution is to increase parallelism by, for example,\n          duplicating the hardware.\nFirst Session Exam                                                          Page 13 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# (c) (2 points)\n\nConsider the following 32-bit adder with a 2 stage pipeline built out of two 16-bit ripple carry adders and answer the following questions:\n\n| 32 | 16 | Ripple | Carry  | Carry | 16 |\n| -- | -- | ------ | ------ | ----- | -- |\n| A  | 16 | 16     | Ripple | 16    | 16 |\n| B  | 32 |        |        |       | Z  |\n\n- What is the area occupied by the entire pipeline?\n- How long does it take to compute one addition?\n- What is the maximum operating frequency (in GHz) of this pipeline?\n- How many additions can be completed in 1000 ns?\n\n# Solution:\n\nArea = AF F,64 + ARCA,\u2081\u2086 + AF F,49 + ARCA,\u2081\u2086 + AF F,32\n\n= 670 + 2000 + 500 + 2000 + 330\n\n= 5500\n\nLatency = 4 ns\n\nMax Frequency = 1/2 ns\n\n= 0.500 GHz\n\nThroughput = 1000/2 ns\n\n= 500 additions per 1000 ns\n\n# (d) (4 points)\n\nThe Latency is the time it takes to calculate one addition, whereas the Throughput is the number of additions that can be calculated per unit time. It is obvious that the throughput will increase if you can reduce the latency. Is it possible to increase the throughput, even if you cannot reduce the latency? Briefly explain.\n\n# Solution:\n\nYes. One solution is to introduce pipelining; it is possible to improve the throughput as seen in the section c) of this question. Pipelining does not reduce latency, the computation of one data item still takes the same amount of time, however, the operation is broken down into smaller pieces, and as soon as the first part is completed, a new data item can be accepted, this improves the throughput. Another solution is to increase parallelism by, for example, duplicating the hardware.\n\nFirst Session Exam\n\nPage 13 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 468.23,
                        "h": 495.21
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(c) (2 points)",
                    "md": "# (c) (2 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Consider the following 32-bit adder with a 2 stage pipeline built out of two 16-bit ripple carry adders and answer the following questions:",
                    "md": "Consider the following 32-bit adder with a 2 stage pipeline built out of two 16-bit ripple carry adders and answer the following questions:",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 86.45,
                        "w": 422.7,
                        "h": 449.13
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| 32 | 16 | Ripple | Carry  | Carry | 16 |\n| -- | -- | ------ | ------ | ----- | -- |\n| A  | 16 | 16     | Ripple | 16    | 16 |\n| B  | 32 |        |        |       | Z  |",
                    "rows": [
                        [
                            "32",
                            "16",
                            "Ripple",
                            "Carry",
                            "Carry",
                            "16"
                        ],
                        [
                            "A",
                            "16",
                            "16",
                            "Ripple",
                            "16",
                            "16"
                        ],
                        [
                            "B",
                            "32",
                            "",
                            "",
                            "",
                            "Z"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 487.09,
                        "h": 705.86
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "- What is the area occupied by the entire pipeline?\n- How long does it take to compute one addition?\n- What is the maximum operating frequency (in GHz) of this pipeline?\n- How many additions can be completed in 1000 ns?",
                    "md": "- What is the area occupied by the entire pipeline?\n- How long does it take to compute one addition?\n- What is the maximum operating frequency (in GHz) of this pipeline?\n- How many additions can be completed in 1000 ns?",
                    "rows": null,
                    "bBox": {
                        "x": 119.46,
                        "y": 181.98,
                        "w": 420.76,
                        "h": 353.6
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Solution:",
                    "md": "# Solution:",
                    "rows": null,
                    "bBox": {
                        "x": 126.89,
                        "y": 316.13,
                        "w": 52.0,
                        "h": 291.15
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Area = AF F,64 + ARCA,\u2081\u2086 + AF F,49 + ARCA,\u2081\u2086 + AF F,32\n\n= 670 + 2000 + 500 + 2000 + 330\n\n= 5500\n\nLatency = 4 ns\n\nMax Frequency = 1/2 ns\n\n= 0.500 GHz\n\nThroughput = 1000/2 ns\n\n= 500 additions per 1000 ns",
                    "md": "Area = AF F,64 + ARCA,\u2081\u2086 + AF F,49 + ARCA,\u2081\u2086 + AF F,32\n\n= 670 + 2000 + 500 + 2000 + 330\n\n= 5500\n\nLatency = 4 ns\n\nMax Frequency = 1/2 ns\n\n= 0.500 GHz\n\nThroughput = 1000/2 ns\n\n= 500 additions per 1000 ns",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 140.35,
                        "w": 422.7,
                        "h": 395.22
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(d) (4 points)",
                    "md": "# (d) (4 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "The Latency is the time it takes to calculate one addition, whereas the Throughput is the number of additions that can be calculated per unit time. It is obvious that the throughput will increase if you can reduce the latency. Is it possible to increase the throughput, even if you cannot reduce the latency? Briefly explain.",
                    "md": "The Latency is the time it takes to calculate one addition, whereas the Throughput is the number of additions that can be calculated per unit time. It is obvious that the throughput will increase if you can reduce the latency. Is it possible to increase the throughput, even if you cannot reduce the latency? Briefly explain.",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 181.98,
                        "w": 422.7,
                        "h": 396.93
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Solution:",
                    "md": "# Solution:",
                    "rows": null,
                    "bBox": {
                        "x": 126.89,
                        "y": 316.13,
                        "w": 52.0,
                        "h": 291.15
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Yes. One solution is to introduce pipelining; it is possible to improve the throughput as seen in the section c) of this question. Pipelining does not reduce latency, the computation of one data item still takes the same amount of time, however, the operation is broken down into smaller pieces, and as soon as the first part is completed, a new data item can be accepted, this improves the throughput. Another solution is to increase parallelism by, for example, duplicating the hardware.\n\nFirst Session Exam\n\nPage 13 of 18",
                    "md": "Yes. One solution is to introduce pipelining; it is possible to improve the throughput as seen in the section c) of this question. Pipelining does not reduce latency, the computation of one data item still takes the same amount of time, however, the operation is broken down into smaller pieces, and as soon as the first part is completed, a new data item can be accepted, this improves the throughput. Another solution is to increase parallelism by, for example, duplicating the hardware.\n\nFirst Session Exam\n\nPage 13 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 181.98,
                        "w": 468.3,
                        "h": 564.25
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 15,
            "text": "Design of Digital Circuits                                           23rd of August 2013\n 6. (5 points) As covered in class, the execution speed of a program on a processor can be\n    given as:\n                             Execution T ime = N \u00d7 CP I \u00d7 1/f\n    Where N  is the number of instructions, CP I is clocks per instruction and f is the clock\n    frequency. Execution T ime will improve by either reducing N and CP I , or increasing\n    f (or a combination thereof). List at least five improvements that can be made in order\n    to improve the Execution T ime.\n     Solution:   Any five of the following could be accepted:\n         \u2022 Reduce number of instructions\n             \u2013  adopt CISC, that uses instructions that can do more\n             \u2013 improve the compiler so that it produces more optimized code\n         \u2022 Reduce clocks per instruction\n             \u2013  adopt RISC, simpler instructions can be executed faster\n             \u2013 add parallel execution units, do more per clock cycle\n         \u2022 Increase clock frequency\n             \u2013  migrate to a more modern manufacturing technology\n             \u2013  adopt pipelining\n             \u2013  redesign and improve timing critical components in the circuit (adders,\n                alu etc)\n             \u2013 Could also be accepted: overclock the system (use higher voltage, clock\n                frequency)\nFirst Session Exam                                                          Page 14 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# 6. (5 points)\n\nAs covered in class, the execution speed of a program on a processor can be given as:\n\nExecution Time = N \u00d7 CPI \u00d7 1/f\n\nWhere N is the number of instructions, CPI is clocks per instruction and f is the clock frequency. Execution Time will improve by either reducing N and CPI, or increasing f (or a combination thereof). List at least five improvements that can be made in order to improve the Execution Time.\n\n# Solution:\n\nAny five of the following could be accepted:\n\n- Reduce number of instructions\n- adopt CISC, that uses instructions that can do more\n- improve the compiler so that it produces more optimized code\n- Reduce clocks per instruction\n- adopt RISC, simpler instructions can be executed faster\n- add parallel execution units, do more per clock cycle\n- Increase clock frequency\n- migrate to a more modern manufacturing technology\n- adopt pipelining\n- redesign and improve timing critical components in the circuit (adders, alu etc)\n- Could also be accepted: overclock the system (use higher voltage, clock frequency)\n\nFirst Session Exam\n\nPage 14 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "6. (5 points)",
                    "md": "# 6. (5 points)",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "As covered in class, the execution speed of a program on a processor can be given as:\n\nExecution Time = N \u00d7 CPI \u00d7 1/f\n\nWhere N is the number of instructions, CPI is clocks per instruction and f is the clock frequency. Execution Time will improve by either reducing N and CPI, or increasing f (or a combination thereof). List at least five improvements that can be made in order to improve the Execution Time.",
                    "md": "As covered in class, the execution speed of a program on a processor can be given as:\n\nExecution Time = N \u00d7 CPI \u00d7 1/f\n\nWhere N is the number of instructions, CPI is clocks per instruction and f is the clock frequency. Execution Time will improve by either reducing N and CPI, or increasing f (or a combination thereof). List at least five improvements that can be made in order to improve the Execution Time.",
                    "rows": null,
                    "bBox": {
                        "x": 92.81,
                        "y": 86.45,
                        "w": 447.52,
                        "h": 95.69
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Solution:",
                    "md": "# Solution:",
                    "rows": null,
                    "bBox": {
                        "x": 102.18,
                        "y": 211.21,
                        "w": 52.0,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Any five of the following could be accepted:\n\n- Reduce number of instructions\n- adopt CISC, that uses instructions that can do more\n- improve the compiler so that it produces more optimized code\n- Reduce clocks per instruction\n- adopt RISC, simpler instructions can be executed faster\n- add parallel execution units, do more per clock cycle\n- Increase clock frequency\n- migrate to a more modern manufacturing technology\n- adopt pipelining\n- redesign and improve timing critical components in the circuit (adders, alu etc)\n- Could also be accepted: overclock the system (use higher voltage, clock frequency)\n\nFirst Session Exam\n\nPage 14 of 18",
                    "md": "Any five of the following could be accepted:\n\n- Reduce number of instructions\n- adopt CISC, that uses instructions that can do more\n- improve the compiler so that it produces more optimized code\n- Reduce clocks per instruction\n- adopt RISC, simpler instructions can be executed faster\n- add parallel execution units, do more per clock cycle\n- Increase clock frequency\n- migrate to a more modern manufacturing technology\n- adopt pipelining\n- redesign and improve timing critical components in the circuit (adders, alu etc)\n- Could also be accepted: overclock the system (use higher voltage, clock frequency)\n\nFirst Session Exam\n\nPage 14 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 211.21,
                        "w": 468.3,
                        "h": 535.02
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 16,
            "text": "Design of Digital Circuits                 23rd of August 2013\n 7. (12 points) Consider the following MIPS program. For clarity the addresses have been\n   written using only 4 hexadecimal digits. Leading hexadecimal digits are all zeroes (the\n   real start address is 0x00003000).\n   0x3000  start:     addi  $s0, $0,   4\n   0x3004             xor   $s1, $s1,  $s1\n   0x3008             addi  $s2, $0,   10\n   0x300C             sw    $s2, 0($s1)\n   0x3010             addi  $s2, $s2,  6\n   0x3014             add   $s1, $s1,  $s0\n   0x3018             sw    $s2, 0($s1)\n   0x301C             addi  $a0, $0,   11\n   0x3020             sll   $t1, $a0,  1\n   0x3024             and   $a1, $a0,  $t1\n   0x3028             jal   absdiff\n   0x302C             sw    $v0, 4($s1)\n   0x3030             lw    $a0, 0($0)\n   0x3034             lw    $a1, 0($s0)\n   0x3038             jal   absdiff\n   0x303C             lw    $t3, 8($0)\n   0x3040             sub   $t2, $t3,  $v0\n   0x3044  done:      j     done\n   0x3048  absdiff:   sub   $t1, $a0,  $a1\n   0x304C             slt   $t2, $t1,  $0\n   0x3050             beq   $t2, $0,   pos\n   0x3054             sub   $t1, $a1,  $a0\n   0x3058  pos:       add   $v0, $0,   $t1\n   0x305C             jr    $ra\nFirst Session Exam                             Page 15 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# 7. (12 points) Consider the following MIPS program. For clarity the addresses have been written using only 4 hexadecimal digits. Leading hexadecimal digits are all zeroes (the real start address is 0x00003000).\n\n| 0x3000 | start:   | addi | $s0, $0, 4    |\n| ------ | -------- | ---- | ------------- |\n| 0x3004 |          | xor  | $s1, $s1, $s1 |\n| 0x3008 |          | addi | $s2, $0, 10   |\n| 0x300C |          | sw   | $s2, 0($s1)   |\n| 0x3010 |          | addi | $s2, $s2, 6   |\n| 0x3014 |          | add  | $s1, $s1, $s0 |\n| 0x3018 |          | sw   | $s2, 0($s1)   |\n| 0x301C |          | addi | $a0, $0, 11   |\n| 0x3020 |          | sll  | $t1, $a0, 1   |\n| 0x3024 |          | and  | $a1, $a0, $t1 |\n| 0x3028 |          | jal  | absdiff       |\n| 0x302C |          | sw   | $v0, 4($s1)   |\n| 0x3030 |          | lw   | $a0, 0($0)    |\n| 0x3034 |          | lw   | $a1, 0($s0)   |\n| 0x3038 |          | jal  | absdiff       |\n| 0x303C |          | lw   | $t3, 8($0)    |\n| 0x3040 |          | sub  | $t2, $t3, $v0 |\n| 0x3044 | done:    | j    | done          |\n| 0x3048 | absdiff: | sub  | $t1, $a0, $a1 |\n| 0x304C |          | slt  | $t2, $t1, $0  |\n| 0x3050 |          | beq  | $t2, $0, pos  |\n| 0x3054 |          | sub  | $t1, $a1, $a0 |\n| 0x3058 | pos:     | add  | $v0, $0, $t1  |\n| 0x305C |          | jr   | $ra           |\n\nFirst Session Exam\n\nPage 15 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 402.69,
                        "y": 40.37,
                        "w": 136.9,
                        "h": 285.33
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "7. (12 points) Consider the following MIPS program. For clarity the addresses have been written using only 4 hexadecimal digits. Leading hexadecimal digits are all zeroes (the real start address is 0x00003000).",
                    "md": "# 7. (12 points) Consider the following MIPS program. For clarity the addresses have been written using only 4 hexadecimal digits. Leading hexadecimal digits are all zeroes (the real start address is 0x00003000).",
                    "rows": null,
                    "bBox": {
                        "x": 77.85,
                        "y": 72.0,
                        "w": 462.41,
                        "h": 558.56
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| 0x3000 | start:   | addi | $s0, $0, 4    |\n| ------ | -------- | ---- | ------------- |\n| 0x3004 |          | xor  | $s1, $s1, $s1 |\n| 0x3008 |          | addi | $s2, $0, 10   |\n| 0x300C |          | sw   | $s2, 0($s1)   |\n| 0x3010 |          | addi | $s2, $s2, 6   |\n| 0x3014 |          | add  | $s1, $s1, $s0 |\n| 0x3018 |          | sw   | $s2, 0($s1)   |\n| 0x301C |          | addi | $a0, $0, 11   |\n| 0x3020 |          | sll  | $t1, $a0, 1   |\n| 0x3024 |          | and  | $a1, $a0, $t1 |\n| 0x3028 |          | jal  | absdiff       |\n| 0x302C |          | sw   | $v0, 4($s1)   |\n| 0x3030 |          | lw   | $a0, 0($0)    |\n| 0x3034 |          | lw   | $a1, 0($s0)   |\n| 0x3038 |          | jal  | absdiff       |\n| 0x303C |          | lw   | $t3, 8($0)    |\n| 0x3040 |          | sub  | $t2, $t3, $v0 |\n| 0x3044 | done:    | j    | done          |\n| 0x3048 | absdiff: | sub  | $t1, $a0, $a1 |\n| 0x304C |          | slt  | $t2, $t1, $0  |\n| 0x3050 |          | beq  | $t2, $0, pos  |\n| 0x3054 |          | sub  | $t1, $a1, $a0 |\n| 0x3058 | pos:     | add  | $v0, $0, $t1  |\n| 0x305C |          | jr   | $ra           |",
                    "rows": [
                        [
                            "0x3000",
                            "start:",
                            "addi",
                            "$s0, $0, 4"
                        ],
                        [
                            "0x3004",
                            "",
                            "xor",
                            "$s1, $s1, $s1"
                        ],
                        [
                            "0x3008",
                            "",
                            "addi",
                            "$s2, $0, 10"
                        ],
                        [
                            "0x300C",
                            "",
                            "sw",
                            "$s2, 0($s1)"
                        ],
                        [
                            "0x3010",
                            "",
                            "addi",
                            "$s2, $s2, 6"
                        ],
                        [
                            "0x3014",
                            "",
                            "add",
                            "$s1, $s1, $s0"
                        ],
                        [
                            "0x3018",
                            "",
                            "sw",
                            "$s2, 0($s1)"
                        ],
                        [
                            "0x301C",
                            "",
                            "addi",
                            "$a0, $0, 11"
                        ],
                        [
                            "0x3020",
                            "",
                            "sll",
                            "$t1, $a0, 1"
                        ],
                        [
                            "0x3024",
                            "",
                            "and",
                            "$a1, $a0, $t1"
                        ],
                        [
                            "0x3028",
                            "",
                            "jal",
                            "absdiff"
                        ],
                        [
                            "0x302C",
                            "",
                            "sw",
                            "$v0, 4($s1)"
                        ],
                        [
                            "0x3030",
                            "",
                            "lw",
                            "$a0, 0($0)"
                        ],
                        [
                            "0x3034",
                            "",
                            "lw",
                            "$a1, 0($s0)"
                        ],
                        [
                            "0x3038",
                            "",
                            "jal",
                            "absdiff"
                        ],
                        [
                            "0x303C",
                            "",
                            "lw",
                            "$t3, 8($0)"
                        ],
                        [
                            "0x3040",
                            "",
                            "sub",
                            "$t2, $t3, $v0"
                        ],
                        [
                            "0x3044",
                            "done:",
                            "j",
                            "done"
                        ],
                        [
                            "0x3048",
                            "absdiff:",
                            "sub",
                            "$t1, $a0, $a1"
                        ],
                        [
                            "0x304C",
                            "",
                            "slt",
                            "$t2, $t1, $0"
                        ],
                        [
                            "0x3050",
                            "",
                            "beq",
                            "$t2, $0, pos"
                        ],
                        [
                            "0x3054",
                            "",
                            "sub",
                            "$t1, $a1, $a0"
                        ],
                        [
                            "0x3058",
                            "pos:",
                            "add",
                            "$v0, $0, $t1"
                        ],
                        [
                            "0x305C",
                            "",
                            "jr",
                            "$ra"
                        ]
                    ],
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 468.3,
                        "h": 705.86
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "First Session Exam\n\nPage 15 of 18",
                    "md": "First Session Exam\n\nPage 15 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 311.7,
                        "w": 468.3,
                        "h": 434.53
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 17,
            "text": "Design of Digital Circuits                                           23rd of August 2013\n    We are interested in determining the value of some registers at the end of the program\n    execution when the program reaches line 0x3044.    Fill in the following table, writing\n    the value of the indicated registers at the end of the program, and at which line these\n    values have been written into these registers.\n    As an example: at the end of execution the register $s0 will have the value 4.   This\n    value has been written into the register while executing line 0x3000.\n            Register                  Value               Assigned on line\n            $s0                             4                         0x3000\n            $s2                           16                          0x3010\n            $t1                             6                         0x3054\n            $t2                             3                         0x3040\n            $t3                             9                         0x303C\n            $ra                     0x303c                            0x3038\nFirst Session Exam                                                          Page 16 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\nWe are interested in determining the value of some registers at the end of the program execution when the program reaches line 0x3044. Fill in the following table, writing the value of the indicated registers at the end of the program, and at which line these values have been written into these registers. As an example: at the end of execution the register $s0 will have the value 4. This value has been written into the register while executing line 0x3000.\n\n| Register | Value  | Assigned on line |\n| -------- | ------ | ---------------- |\n| $s0      | 4      | 0x3000           |\n| $s2      | 16     | 0x3010           |\n| $t1      | 6      | 0x3054           |\n| $t2      | 3      | 0x3040           |\n| $t3      | 9      | 0x303C           |\n| $ra      | 0x303c | 0x3038           |\n\nFirst Session Exam\n\nPage 16 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013\n\nWe are interested in determining the value of some registers at the end of the program execution when the program reaches line 0x3044. Fill in the following table, writing the value of the indicated registers at the end of the program, and at which line these values have been written into these registers. As an example: at the end of execution the register $s0 will have the value 4. This value has been written into the register while executing line 0x3000.",
                    "md": "23rd of August 2013\n\nWe are interested in determining the value of some registers at the end of the program execution when the program reaches line 0x3044. Fill in the following table, writing the value of the indicated registers at the end of the program, and at which line these values have been written into these registers. As an example: at the end of execution the register $s0 will have the value 4. This value has been written into the register while executing line 0x3000.",
                    "rows": null,
                    "bBox": {
                        "x": 92.81,
                        "y": 40.37,
                        "w": 447.36,
                        "h": 349.96
                    }
                },
                {
                    "type": "table",
                    "lvl": null,
                    "value": null,
                    "md": "| Register | Value  | Assigned on line |\n| -------- | ------ | ---------------- |\n| $s0      | 4      | 0x3000           |\n| $s2      | 16     | 0x3010           |\n| $t1      | 6      | 0x3054           |\n| $t2      | 3      | 0x3040           |\n| $t3      | 9      | 0x303C           |\n| $ra      | 0x303c | 0x3038           |",
                    "rows": [
                        [
                            "Register",
                            "Value",
                            "Assigned on line"
                        ],
                        [
                            "$s0",
                            "4",
                            "0x3000"
                        ],
                        [
                            "$s2",
                            "16",
                            "0x3010"
                        ],
                        [
                            "$t1",
                            "6",
                            "0x3054"
                        ],
                        [
                            "$t2",
                            "3",
                            "0x3040"
                        ],
                        [
                            "$t3",
                            "9",
                            "0x303C"
                        ],
                        [
                            "$ra",
                            "0x303c",
                            "0x3038"
                        ]
                    ],
                    "bBox": {
                        "x": 92.81,
                        "y": 40.37,
                        "w": 447.49,
                        "h": 705.86
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "First Session Exam\n\nPage 16 of 18",
                    "md": "First Session Exam\n\nPage 16 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 289.46,
                        "w": 468.3,
                        "h": 456.77
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 18,
            "text": "Design of Digital Circuits                                            23rd of August 2013\n 8. You are involved in designing a computing system using a cache (256 kbyte, 4-way set\n    associative cache using 1 kbyte blocks). Your first design has some cache performance\n    problems.  Your colleagues made the following suggestions.   For each suggestion, first\n    state whether or not the idea will work, and then briefly explain why. If the idea works\n    explain under what conditions.\n     (a) (2 points) Alain: \u201dWe have too many cache misses due to    conflicts. We need to\n         reduce the degree of associativity, so that we reduce conflict misses in the cache\u201d:\n          Solution:\n          This idea will not work. Just the opposite: increasing set associativity gives\n          data more possibilities to be stored in the cache without replacing other data.\n          This reduces conflict misses.\n    (b) (2 points) Beatrice: \u201dThere are many compulsory    cache misses.  To combat this,\n         we should increase our block size\u201d\n          Solution:   This idea could work.   A larger block size will take advantage of\n          spatial locality and assume that nearby data items will also be accessed by the\n          program. If the program has such accesses, the first data access will result in a\n          compulsory miss, but the subsequent accesses will find data in the cache.\nFirst Session Exam                                                           Page 17 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n# 8.\n\nYou are involved in designing a computing system using a cache (256 kbyte, 4-way set associative cache using 1 kbyte blocks). Your first design has some cache performance problems. Your colleagues made the following suggestions. For each suggestion, first state whether or not the idea will work, and then briefly explain why. If the idea works explain under what conditions.\n\n# (a) (2 points) Alain:\n\n\u201dWe have too many cache misses due to conflicts. We need to reduce the degree of associativity, so that we reduce conflict misses in the cache\u201d:\n\nSolution: This idea will not work. Just the opposite: increasing set associativity gives data more possibilities to be stored in the cache without replacing other data. This reduces conflict misses.\n\n# (b) (2 points) Beatrice:\n\n\u201dThere are many compulsory cache misses. To combat this, we should increase our block size\u201d\n\nSolution: This idea could work. A larger block size will take advantage of spatial locality and assume that nearby data items will also be accessed by the program. If the program has such accesses, the first data access will result in a compulsory miss, but the subsequent accesses will find data in the cache.\n\nFirst Session Exam\n\nPage 17 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013",
                    "md": "23rd of August 2013",
                    "rows": null,
                    "bBox": {
                        "x": 435.89,
                        "y": 40.37,
                        "w": 103.7,
                        "h": 12.0
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "8.",
                    "md": "# 8.",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "You are involved in designing a computing system using a cache (256 kbyte, 4-way set associative cache using 1 kbyte blocks). Your first design has some cache performance problems. Your colleagues made the following suggestions. For each suggestion, first state whether or not the idea will work, and then briefly explain why. If the idea works explain under what conditions.",
                    "md": "You are involved in designing a computing system using a cache (256 kbyte, 4-way set associative cache using 1 kbyte blocks). Your first design has some cache performance problems. Your colleagues made the following suggestions. For each suggestion, first state whether or not the idea will work, and then briefly explain why. If the idea works explain under what conditions.",
                    "rows": null,
                    "bBox": {
                        "x": 92.81,
                        "y": 86.45,
                        "w": 447.11,
                        "h": 55.34
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(a) (2 points) Alain:",
                    "md": "# (a) (2 points) Alain:",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "\u201dWe have too many cache misses due to conflicts. We need to reduce the degree of associativity, so that we reduce conflict misses in the cache\u201d:\n\nSolution: This idea will not work. Just the opposite: increasing set associativity gives data more possibilities to be stored in the cache without replacing other data. This reduces conflict misses.",
                    "md": "\u201dWe have too many cache misses due to conflicts. We need to reduce the degree of associativity, so that we reduce conflict misses in the cache\u201d:\n\nSolution: This idea will not work. Just the opposite: increasing set associativity gives data more possibilities to be stored in the cache without replacing other data. This reduces conflict misses.",
                    "rows": null,
                    "bBox": {
                        "x": 117.52,
                        "y": 163.66,
                        "w": 422.07,
                        "h": 172.76
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "(b) (2 points) Beatrice:",
                    "md": "# (b) (2 points) Beatrice:",
                    "rows": null,
                    "bBox": {
                        "x": 0.0,
                        "y": 0.0,
                        "w": 612.0,
                        "h": 792.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "\u201dThere are many compulsory cache misses. To combat this, we should increase our block size\u201d\n\nSolution: This idea could work. A larger block size will take advantage of spatial locality and assume that nearby data items will also be accessed by the program. If the program has such accesses, the first data access will result in a compulsory miss, but the subsequent accesses will find data in the cache.\n\nFirst Session Exam\n\nPage 17 of 18",
                    "md": "\u201dThere are many compulsory cache misses. To combat this, we should increase our block size\u201d\n\nSolution: This idea could work. A larger block size will take advantage of spatial locality and assume that nearby data items will also be accessed by the program. If the program has such accesses, the first data access will result in a compulsory miss, but the subsequent accesses will find data in the cache.\n\nFirst Session Exam\n\nPage 17 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 206.73,
                        "w": 468.3,
                        "h": 539.5
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        },
        {
            "page": 19,
            "text": "Design of Digital Circuits                                            23rd of August 2013\n     (c) (2 points) Cathy: \u201dOur cache has many capacity    misses.  Instead of using a set\n         associative cache, we should convert it to a direct mapped cache of the same size.\n         This will allow more sets to be stored in the cache, hence reducing capacity misses\u201d\n          Solution:   This idea will not work. The organization of the cache does not\n          change its capacity. The capacity miss occurs because data that is needed can\n          not fit into the cache.\nFirst Session Exam                                                           Page 18 of 18",
            "md": "# Design of Digital Circuits\n\n23rd of August 2013\n\n(c) (2 points) Cathy: \u201dOur cache has many capacity misses. Instead of using a set associative cache, we should convert it to a direct mapped cache of the same size. This will allow more sets to be stored in the cache, hence reducing capacity misses\u201d\n\nSolution: This idea will not work. The organization of the cache does not change its capacity. The capacity miss occurs because data that is needed cannot fit into the cache.\n\n# First Session Exam\n\nPage 18 of 18",
            "images": [],
            "charts": [],
            "tables": [],
            "layout": [],
            "items": [
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "Design of Digital Circuits",
                    "md": "# Design of Digital Circuits",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 40.37,
                        "w": 130.46,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "23rd of August 2013\n\n(c) (2 points) Cathy: \u201dOur cache has many capacity misses. Instead of using a set associative cache, we should convert it to a direct mapped cache of the same size. This will allow more sets to be stored in the cache, hence reducing capacity misses\u201d\n\nSolution: This idea will not work. The organization of the cache does not change its capacity. The capacity miss occurs because data that is needed cannot fit into the cache.",
                    "md": "23rd of August 2013\n\n(c) (2 points) Cathy: \u201dOur cache has many capacity misses. Instead of using a set associative cache, we should convert it to a direct mapped cache of the same size. This will allow more sets to be stored in the cache, hence reducing capacity misses\u201d\n\nSolution: This idea will not work. The organization of the cache does not change its capacity. The capacity miss occurs because data that is needed cannot fit into the cache.",
                    "rows": null,
                    "bBox": {
                        "x": 97.36,
                        "y": 40.37,
                        "w": 443.11,
                        "h": 144.49
                    }
                },
                {
                    "type": "heading",
                    "lvl": 1,
                    "value": "First Session Exam",
                    "md": "# First Session Exam",
                    "rows": null,
                    "bBox": {
                        "x": 72.0,
                        "y": 734.23,
                        "w": 98.97,
                        "h": 12.0
                    }
                },
                {
                    "type": "text",
                    "lvl": null,
                    "value": "Page 18 of 18",
                    "md": "Page 18 of 18",
                    "rows": null,
                    "bBox": {
                        "x": 470.9,
                        "y": 734.23,
                        "w": 69.39,
                        "h": 12.0
                    }
                }
            ],
            "status": "OK",
            "links": [],
            "width": 612.0,
            "height": 792.0,
            "triggeredAutoMode": false,
            "parsingMode": "accurate",
            "structuredData": null,
            "noStructuredContent": false,
            "noTextContent": false
        }
    ],
    "job_metadata": {
        "job_pages": 0,
        "job_auto_mode_triggered_pages": 0,
        "job_is_cache_hit": true
    },
    "file_name": "OnurETHZ_exams/exam_ss2013_solutions.pdf",
    "job_id": "128d4111-cda6-4e61-aa7d-6c16b1eb0dbd",
    "is_done": false,
    "error": null
}