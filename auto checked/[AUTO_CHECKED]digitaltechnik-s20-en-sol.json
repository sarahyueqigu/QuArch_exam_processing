[
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_1/a",
        "context": "Boolean Circuit Minimization\n",
        "context_figures": [],
        "question": "Convert the following Boolean equation so that it only contains NAND operations. Show your work step-by-step. F = (A \u00b7B + C) +A \u00b7 C",
        "solution": "F = (A \u00b7B) \u00b7 (A \u00b7B) \u00b7 (A \u00b7 C)\n\nExplanation:\n\nF = (A \u00b7B + C) \u00b7 (A \u00b7 C)\n\nF = ((A \u00b7B) \u00b7 C) \u00b7 (A \u00b7 C)\n\nF = (A \u00b7B) \u00b7 (C \u00b7 (A \u00b7 C))\n\nF = (A \u00b7B)(A \u00b7 C)\n\nF = (A \u00b7B) \u00b7 (A \u00b7B) \u00b7 (A \u00b7 C)",
        "solution_figures": [
            "chart_p3_0.png"
        ],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_1/b",
        "context": "Boolean Circuit Minimization\n",
        "context_figures": [],
        "question": "Using Boolean algebra, find the simplest Boolean algebra equation for the following min-terms. Show your work step-by-step. You may label the order of variables as ABCD (e.g., A \u00b7B \u00b7 C \u00b7D denotes 0100).\u2211(0000, 0100, 0101, 1000, 1100, 1101)",
        "solution": "F = C \u00b7 (B +D)\n\nExplanation:\nF = (A\u00b7B \u00b7C \u00b7D)+(A\u00b7B \u00b7C \u00b7D)+(A\u00b7B \u00b7C \u00b7D)+(A\u00b7B \u00b7C \u00b7D)+(A\u00b7B \u00b7C \u00b7D)+(A\u00b7B \u00b7C \u00b7D)\nF = (B \u00b7C \u00b7((A\u00b7D)+(A\u00b7D)+(A\u00b7D)+(A\u00b7D)))+(C \u00b7D \u00b7((A\u00b7B)+(A\u00b7B)+(A\u00b7B)+(A\u00b7B)))\nF = B \u00b7 C + C \u00b7D\nF = C \u00b7 (B +D)",
        "solution_figures": [
            "chart_p3_1.png",
            "chart_p3_2.png"
        ],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_10/a",
        "context": "Branch Prediction [60 points]\n\nA processor implements an in-order pipeline with 15 stages. Each stage completes in a single cycle.\nThe pipeline stalls on a conditional branch instruction until the condition of the branch is evaluated.\nHowever, you do not know at which stage the branch condition is evaluated. Please answer the following\nquestions.\n",
        "context_figures": [],
        "question": "A program with 2500 dynamic instructions completes in 4514 cycles. If 500 of those\ninstructions are conditional branches, at the end of which pipeline stage are the branch instructions\nresolved? (Assume that the pipeline does not stall for any other reason than conditional branches,\ne.g., data dependencies, during the execution of that program.)",
        "solution": "At the end of the 5th stage.\n\nExplanation: Total cycles = 15 + 2500 + 500 \u2217X \u2212 1\n4514 = 2514 + 500 \u2217X\n2000 = 500 \u2217X\nX = 4\nEach branch causes 4 idle cycles (bubbles), thus branches are resolved at the end of 5th\nstage.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_10/b",
        "context": "Branch Prediction [60 points]\n\nA processor implements an in-order pipeline with 15 stages. Each stage completes in a single cycle.\nThe pipeline stalls on a conditional branch instruction until the condition of the branch is evaluated.\nHowever, you do not know at which stage the branch condition is evaluated. Please answer the following\nquestions.\nIn a new, higher-performance version of the previous processor, the architects im-\nplement a mysterious branch prediction mechanism to improve the performance of the processor.\nThey keep the rest of the design exactly the same as before. The new design with the mysterious\nbranch predictor completes the execution of the following piece of code in 136 cycles.\n\nPlease note that the number of pipeline stages and the stage at which the branch condition is\nevaluated are same as the previous question. Also, assume that the pipeline never stalls due to any\nother reasons than conditional branches.\n\nMOV R1, #0 // R1 = 0\n\nLOOP_1:\nBEQ R1, #5, LAST // Branch to LAST if R1 == 5\nADD R1, R1, #1 // R1 = R1 + 1\nMOV R2, #0 // R2 = 0\n\nLOOP_2:\nBEQ R2, #5, LOOP_1 // Branch to LOOP_1 if R2 == 5.\nADD R2, R2, #1 // R2 = R2 + 1\nB LOOP_2 // Unconditional branch to LOOP_2\n\nLAST:\nMOV R1, #1 // R1 = 0",
        "context_figures": [],
        "question": "How many instructions will be executed when running this piece of code? Show your work.\n\nHow many of them are CONDITIONAL branch instructions? Show your work.",
        "solution": "Total instructions executed = 98;\n\nConditional branch instructions = 36;",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution is incomplete. In the original PDF, there should be work shown for how the answers were derived, but the parsed solution only contains the final answers without any explanation or work shown.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_10/c",
        "context": "Branch Prediction [60 points]\n\nA processor implements an in-order pipeline with 15 stages. Each stage completes in a single cycle.\nThe pipeline stalls on a conditional branch instruction until the condition of the branch is evaluated.\nHowever, you do not know at which stage the branch condition is evaluated. Please answer the following\nquestions.\nBased on the given information, determine which of the following branch prediction mechanisms\ncould be the mysterious branch predictor implemented in the new version of the processor. For each\nbranch prediction mechanism below, you should circle the configuration parameters that makes it\nmatch the performance of the mysterious branch predictor.",
        "context_figures": [],
        "question": "(I) Static Branch Predictor\n\nCould this be the mysterious branch predictor?\n\nYES NO\n\nIf YES, for which configuration below is the answer YES? Pick an option for each configuration\nparameter.\n\ni. Static Prediction Direction\n\nAlways taken Always not taken\n\n(II) Last Time Branch Predictor\n\nCould this be the mysterious branch predictor?\n\nYES NO\n\nIf YES, for which configuration is the answer YES? Pick an option for each configuration\nparameter.\n\ni. Initial Prediction Direction\n\nTaken Not taken\n\nii. Local for each branch instruction (i.e., PC-based) or global (i.e., shared among all branches)\nhistory?\n\nLocal Global\n\n(III) Backward taken, Forward not taken (BTFN)\n\nPlease recollect, a conditional branch is said to be backward if its target address is lower than\nthe branch PC, and vice-versa.\n\nCould this be the mysterious branch predictor?\n\nYES NO\n\n(IV) Two-bit Counter Based Prediction (using saturating arithmetic)\n\nCould this be the mysterious branch predictor?\n\nYES NO\n\nIf YES, for which configuration is the answer YES? Pick an option for each configuration\nparameter.\n\ni. Initial Prediction Direction\n\n00 (Strongly not taken) 01 (Weakly not taken)\n10 (Weakly taken) 11 (Strongly taken)\n\nii. Local for each branch instruction (i.e., PC-based, without any interference between dif-\nferent branches) or global (i.e., a single counter shared among all branches) history?\n\nLocal Global",
        "solution": "YES, if the static prediction direction is always not taken.\n\nExplanation: 98 instructions (36 of them are conditional branches) finishes execu-\ntion in 136 cycles. This means there are 6 branch mispredictions. So, any predictor\nthat produces 6 mispredictions can be our mysterious predictor.\nA static predictor with always not taken predicton generates 6 mispredictions. Hence,\nYES.\n\nNO.\n\nExplanation: There is no configuration for this branch predictor that results in 6\nmispredictions for the above program.\n\nLocal-taken: 12 mispredictions, Local-NotTaken: 10 mispredictions,\nGlobal-taken: 10 mispredictions, Global-NotTaken: 9 mispredictions.\n\nNO.\n\nExplanation: BTFN predictor makes 26 mispredictions. Hence it cannot be\nour mysterious branch predictor.\n\nYES, if local or global history registers with 00 or 01 initial values are used.\n\nExplanation: Such a configuration yields exactly 6 mispredictions, which results\nin 136 cycles execution time for the above program.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_11/a",
        "context": "Consider a VLIW (very long instruction word) CPU that uses the long instruction format shown in Table 4. Each long instruction is composed of four short instructions, but there are restrictions on which type of instruction may go in which of the four slots.\n\nMEMORY INTEGER CONTROL FLOAT\n\nTable 4: VLIW instruction format.\n\nTable 5 provides a detailed description of the available short instructions and the total execution latency of each type of short instruction. Each short instruction execution unit is fully pipelined, and its result is available on the cycle given by the latency, e.g., a CONTROL instruction's results (if any) are available for other instructions to use in the next cycle.\n\nCategory\nLatency\n(cycles) Instruction(s) Description Functionality\n\nCONTROL 1\nBEQ LABEL, Rs1, Rs2 Branch IF equal IF Rs1 == Rs2:\nPC = LABEL\nNOP No operation PC = Next PC\n\nMEMORY 3 LD Rd, [Rs] Memory load Rd = MEM[Rs]\nINTEGER 2 IADD Rd, Rs1, Rs2 Integer add Rd = Rs1 + Rs2\nFLOAT 4 FADD Rd, Rs1, Rs2 Floating-point add Rd = Rs1 + Rs2\n\nTable 5: Instruction latencies and descriptions.\n\nConsider the piece of code given in Table 6. Unfortunately, it is written in terms of short instructions that cannot be directly input to the VLIW CPU.\n\nInstruction Notes\n< Initialize R0-R2 > R0-R2 point to valid memory\nLOOP:\n1 LD R0, [R0] R0 <- MEM[R0]\n2 LD R1, [R1] R1 <- MEM[R1]\n3 IADD R4, R0, R1 R4 <- R0 + R1\n4 FADD R5, R0, R4 R5 <- R0 + R4\n5 LD R6, [R2] R6 <- MEM[R2]\n6 LD R2, [R0] R2 <- MEM[R0]\n7 FADD R3, R1, R6 R3 <- R1 + R6\n8 IADD R4, R2, R4 R4 <- R2 + R4\n9 IADD R5, R5, R4 R5 <- R5 + R4\n10 IADD R0, R6, R2 R0 <- R6 + R2\n11 IADD R0, R0, R3 R0 <- R0 + R3\n12 BEQ LOOP, R0, R5 GOTO LOOP if R0 == R5\n\nTable 6: Proposed code for calculating the results of the next Swiss referendum.\n",
        "context_figures": [
            "chart_p26_0.png",
            "chart_p26_1.png"
        ],
        "question": "Warm-up: which of the following are goals of VLIW CPU design (circle all that apply)?\n\n(i) Simplify code compilation.\n\n(ii) Simplify application development.\n\n(iii) Reduce overall hardware complexity.\n\n(iv) Simplify hardware inter-instruction dependence checking.\n\n(v) Reduce processor fetch width.",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty, which violates condition (b) that requires both question and solution fields to be populated.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_11/b",
        "context": "Consider a VLIW (very long instruction word) CPU that uses the long instruction format shown in Table 4. Each long instruction is composed of four short instructions, but there are restrictions on which type of instruction may go in which of the four slots.\n\nMEMORY INTEGER CONTROL FLOAT\n\nTable 4: VLIW instruction format.\n\nTable 5 provides a detailed description of the available short instructions and the total execution latency of each type of short instruction. Each short instruction execution unit is fully pipelined, and its result is available on the cycle given by the latency, e.g., a CONTROL instruction's results (if any) are available for other instructions to use in the next cycle.\n\nCategory\nLatency\n(cycles) Instruction(s) Description Functionality\n\nCONTROL 1\nBEQ LABEL, Rs1, Rs2 Branch IF equal IF Rs1 == Rs2:\nPC = LABEL\nNOP No operation PC = Next PC\n\nMEMORY 3 LD Rd, [Rs] Memory load Rd = MEM[Rs]\nINTEGER 2 IADD Rd, Rs1, Rs2 Integer add Rd = Rs1 + Rs2\nFLOAT 4 FADD Rd, Rs1, Rs2 Floating-point add Rd = Rs1 + Rs2\n\nTable 5: Instruction latencies and descriptions.\n\nConsider the piece of code given in Table 6. Unfortunately, it is written in terms of short instructions that cannot be directly input to the VLIW CPU.\n\nInstruction Notes\n< Initialize R0-R2 > R0-R2 point to valid memory\nLOOP:\n1 LD R0, [R0] R0 <- MEM[R0]\n2 LD R1, [R1] R1 <- MEM[R1]\n3 IADD R4, R0, R1 R4 <- R0 + R1\n4 FADD R5, R0, R4 R5 <- R0 + R4\n5 LD R6, [R2] R6 <- MEM[R2]\n6 LD R2, [R0] R2 <- MEM[R0]\n7 FADD R3, R1, R6 R3 <- R1 + R6\n8 IADD R4, R2, R4 R4 <- R2 + R4\n9 IADD R5, R5, R4 R5 <- R5 + R4\n10 IADD R0, R6, R2 R0 <- R6 + R2\n11 IADD R0, R0, R3 R0 <- R0 + R3\n12 BEQ LOOP, R0, R5 GOTO LOOP if R0 == R5\n\nTable 6: Proposed code for calculating the results of the next Swiss referendum.\n",
        "context_figures": [
            "chart_p26_0.png",
            "chart_p26_1.png"
        ],
        "question": "Your task is to determine the optimal VLIW scheduling of the short instructions by hand. Fill in the following table with the highest performance (i.e., fewest number of execution cycles) instruction sequence that may be directly input into the VLIW CPU and have the same functionality as the code in Table 6. Where possible, you may write instruction IDs corresponding to the numbers given in Table 6 and leave any NOP instructions as blank slots.\n\nConsider only one loop iteration (including the BEQ instruction), ignore initialization and any cross-iteration optimizations (e.g., loop unrolling), and do not optimize the code by removing or changing existing instructions.",
        "solution": "Cycle MEMORY INTEGER CONTROL FLOAT\n\n1 1 (LD R0, [R0])\n\n2 2 (LD R1, [R1])\n\n3 5 (LD R6, [R2])\n\n4 6 (LD R2, [R0])\n\n5 3 (IADD R4, R0, R1)\n\n6 7 (FADD R3, R1, R6)\n\n7 8 (IADD R4, R2, R4) 4 (FADD R5, R0, R4)\n\n8 10 (IADD R0, R6, R2)\n\n9 8 (IADD R4, R2, R4)\n\n10 11 (IADD R0, R0, R3)\n\n11 9 (IADD R5, R5, R4)\n\n12\n\n13 12 (BEQ LOOP, R0, R5)\n\nNote: Instruction 8 may go in EITHER of the red slots.",
        "solution_figures": [
            "chart_p27_0.png"
        ],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_11/c",
        "context": "Consider a VLIW (very long instruction word) CPU that uses the long instruction format shown in Table 4. Each long instruction is composed of four short instructions, but there are restrictions on which type of instruction may go in which of the four slots.\n\nMEMORY INTEGER CONTROL FLOAT\n\nTable 4: VLIW instruction format.\n\nTable 5 provides a detailed description of the available short instructions and the total execution latency of each type of short instruction. Each short instruction execution unit is fully pipelined, and its result is available on the cycle given by the latency, e.g., a CONTROL instruction's results (if any) are available for other instructions to use in the next cycle.\n\nCategory\nLatency\n(cycles) Instruction(s) Description Functionality\n\nCONTROL 1\nBEQ LABEL, Rs1, Rs2 Branch IF equal IF Rs1 == Rs2:\nPC = LABEL\nNOP No operation PC = Next PC\n\nMEMORY 3 LD Rd, [Rs] Memory load Rd = MEM[Rs]\nINTEGER 2 IADD Rd, Rs1, Rs2 Integer add Rd = Rs1 + Rs2\nFLOAT 4 FADD Rd, Rs1, Rs2 Floating-point add Rd = Rs1 + Rs2\n\nTable 5: Instruction latencies and descriptions.\n\nConsider the piece of code given in Table 6. Unfortunately, it is written in terms of short instructions that cannot be directly input to the VLIW CPU.\n\nInstruction Notes\n< Initialize R0-R2 > R0-R2 point to valid memory\nLOOP:\n1 LD R0, [R0] R0 <- MEM[R0]\n2 LD R1, [R1] R1 <- MEM[R1]\n3 IADD R4, R0, R1 R4 <- R0 + R1\n4 FADD R5, R0, R4 R5 <- R0 + R4\n5 LD R6, [R2] R6 <- MEM[R2]\n6 LD R2, [R0] R2 <- MEM[R0]\n7 FADD R3, R1, R6 R3 <- R1 + R6\n8 IADD R4, R2, R4 R4 <- R2 + R4\n9 IADD R5, R5, R4 R5 <- R5 + R4\n10 IADD R0, R6, R2 R0 <- R6 + R2\n11 IADD R0, R0, R3 R0 <- R0 + R3\n12 BEQ LOOP, R0, R5 GOTO LOOP if R0 == R5\n\nTable 6: Proposed code for calculating the results of the next Swiss referendum.\n",
        "context_figures": [
            "chart_p26_0.png",
            "chart_p26_1.png"
        ],
        "question": "How many total cycles are required to complete execution of all instructions in the previous question? Ignore pipeline fill overheads and assume the instruction latencies given in Table 5.",
        "solution": "13",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_11/d",
        "context": "Consider a VLIW (very long instruction word) CPU that uses the long instruction format shown in Table 4. Each long instruction is composed of four short instructions, but there are restrictions on which type of instruction may go in which of the four slots.\n\nMEMORY INTEGER CONTROL FLOAT\n\nTable 4: VLIW instruction format.\n\nTable 5 provides a detailed description of the available short instructions and the total execution latency of each type of short instruction. Each short instruction execution unit is fully pipelined, and its result is available on the cycle given by the latency, e.g., a CONTROL instruction's results (if any) are available for other instructions to use in the next cycle.\n\nCategory\nLatency\n(cycles) Instruction(s) Description Functionality\n\nCONTROL 1\nBEQ LABEL, Rs1, Rs2 Branch IF equal IF Rs1 == Rs2:\nPC = LABEL\nNOP No operation PC = Next PC\n\nMEMORY 3 LD Rd, [Rs] Memory load Rd = MEM[Rs]\nINTEGER 2 IADD Rd, Rs1, Rs2 Integer add Rd = Rs1 + Rs2\nFLOAT 4 FADD Rd, Rs1, Rs2 Floating-point add Rd = Rs1 + Rs2\n\nTable 5: Instruction latencies and descriptions.\n\nConsider the piece of code given in Table 6. Unfortunately, it is written in terms of short instructions that cannot be directly input to the VLIW CPU.\n\nInstruction Notes\n< Initialize R0-R2 > R0-R2 point to valid memory\nLOOP:\n1 LD R0, [R0] R0 <- MEM[R0]\n2 LD R1, [R1] R1 <- MEM[R1]\n3 IADD R4, R0, R1 R4 <- R0 + R1\n4 FADD R5, R0, R4 R5 <- R0 + R4\n5 LD R6, [R2] R6 <- MEM[R2]\n6 LD R2, [R0] R2 <- MEM[R0]\n7 FADD R3, R1, R6 R3 <- R1 + R6\n8 IADD R4, R2, R4 R4 <- R2 + R4\n9 IADD R5, R5, R4 R5 <- R5 + R4\n10 IADD R0, R6, R2 R0 <- R6 + R2\n11 IADD R0, R0, R3 R0 <- R0 + R3\n12 BEQ LOOP, R0, R5 GOTO LOOP if R0 == R5\n\nTable 6: Proposed code for calculating the results of the next Swiss referendum.\n",
        "context_figures": [
            "chart_p26_0.png",
            "chart_p26_1.png"
        ],
        "question": "What is the utilization of the instruction scheduling slots (computed as the ratio of utilized slots to total execution slots throughout execution)?",
        "solution": "(12 slots used) / (13 cycles * 4 slots/cycle) = 3/13 \u2248 23.1%",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_2/a",
        "context": "Verilog [40 points]\n\nPlease answer the following four questions about Verilog.\n",
        "context_figures": [],
        "question": "Does the following code result in a sequential circuit or a combinational circuit? Please explain your answer.\n\n1\n2 module sevensegment (input [3:0] data, output reg [6:0] segments);\n3 always @ ( * )\n4 case (data)\n5 4'd0: segments = 7'b111_1110;\n6 4'd1: segments = 7'b011_0000;\n7 4'd2: segments = 7'b110_1101;\n8 4'd3: segments = 7'b111_1001;\n9 4'd4: segments = 7'b011_0011;\n10 endcase\n11 endmodule",
        "solution": "Sequential circuit.\n\nExplanation:\nThis code results in a sequential circuit, as all the left-hand side signals are not assigned in every possible condition. For example, for values of data that are more than 4, segment is not assigned to a specific value.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_2/b",
        "context": "Verilog [40 points]\n\nPlease answer the following four questions about Verilog.\n",
        "context_figures": [],
        "question": "Does the following code result in an output signal which is zero except for one clock cycle in every three clock cycles (0-0-1-0-0-1...)? If not, please enable this functionality by adding minimal changes. Explain your answer.\n\n1 module divideby3 (input clk, input reset, output q);\n2 reg [1:0] curVal, nextVal;\n3 parameter S0 = 2'b00; parameter S1 = 2'b01; parameter S2 = 2'b10;\n4 always @ (*)\n5 case (curVal)\n6 S0: nextVal = S1;\n7 S1: nextVal = S2;\n8 S2: nextVal = S0;\n9 default: nextVal = S0;\n10 endcase\n11 assign q = (curVal == S0);\n12 endmodule",
        "solution": "No.\n\nExplanation:\nThe FSM misses state register. This leads to curVal not changing to nextVal. To fix the problem, the state register should be added:\n\nalways @ (posedge clk, posedge reset)\nif (reset) curVal <= S0;\nelse curVal <= nextVal;",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_2/c",
        "context": "Verilog [40 points]\n\nPlease answer the following four questions about Verilog.\n",
        "context_figures": [],
        "question": "The following code implements a circuit and we initialize all inputs and registers of the circuit to zero. We apply the following changes to the input signals in two subsequent steps. What are the values of out and tmp after each step? Please show your work.\n\n\u2022 Step 1: sel changes to 1.\n\n\u2022 Step 2: While sel is still 1, b changes to 1.\n\n1 module mod1 (input sel, input a, input b, input c, output out);\n2 reg tmp = 1'b0;\n3 always @ (sel)\n4 if (sel)\n5 tmp <= ~(a & b);\n6 out <= tmp ^ c;\n7 else\n8 tmp <= 0;\n9 out <= 0;\n10 endmodule",
        "solution": "After step 1, tmp and out are respectively 1 and 0 . After step 2, tmp and out are respectively 1 and 0\n\nExplanation:\nAfter step 1: sel is in the sensitivity list of the always block. Therefore, the if statement executes. Since tmp and out are in the left hand side of non-blocking assignments, they execute concurrentlyi, and the second assignment in the if block does not see the new value of tmp when executing.\nAfter step 2: The values of tmp and out do not change because b is not in the sensitivity list of the always block.",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "There's a typo in the solution text. The word 'concurrentlyi' should be 'concurrently' without the 'i' at the end. This doesn't match the original PDF exactly.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_2/d",
        "context": "Verilog [40 points]\n\nPlease answer the following four questions about Verilog.\n",
        "context_figures": [],
        "question": "Is the following code syntactically correct and result in deterministic values for all signals? If not, please explain the mistake(s).\n\n1 module top (input [1:0] in1, in2 , input op, output reg [1:0] z, output reg s);\n2\n3 wire tmp;\n4 always@(*) begin\n5 tmp = in1[0] & in2[0];\n6 z[0] = tmp & op;\n7 end\n8 always@(*) begin\n9 tmp = in1[1] | in2[1];\n10 z[1] = tmp & (~p)\n11 end\n12 assign s = (z[1] > z[0])\n13 endmodule",
        "solution": "The code is not syntactically correct and does not result in deterministic values.\n\nExplanation:\n\u2022 'tmp' has to be declared as a reg since it is used in the always blocks.\n\u2022 's' should not to be declared as a reg since it is driven by the assign statement.\n\u2022 'tmp' signal is connected to multiple drivers and leads to non-deterministic values.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_3/3.1",
        "context": "Finite State Machines [40 points]\nDesigning an FSM [20 points]",
        "context_figures": [],
        "question": "Draw a Moore finite state machine for a digital circuit that has a one-bit input x and a one-bit output y. The circuit detects the bit pattern 0-1-1 on the input x. The output bit is set (i.e., y = 1) during clock cycle t only if the three following values of x happen.\n\n\u2022 x = 0 at clock cycle t\u2212 3,\n\n\u2022 x = 1 at clock cycle t\u2212 2,\n\n\u2022 x = 1 at clock cycle t\u2212 1\n\nYour state machine should use as few states as possible. Assume that the initial bit value of x is zero. Please clearly and comprehensively define each state and state transition. Note that you can lose points for ambiguity in your state machine.",
        "solution": "We need four states to keep track of the recent input values.\n\n\u2022 S0: Input was zero in the last clock cycle (the initial state). The output should be zero.\n\u2022 S1: Input was one in the last clock cycle, but it was zero before. The output should be zero.\n\u2022 S2: Input was one in the last two clock cycles, but it was zero before. The output should be one.\n\u2022 S3: Input was one in the last three clock cycles. The output should be zero.",
        "solution_figures": [
            "chart_p6_0.png"
        ],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_3/3.2",
        "context": "Finite State Machines [40 points]\nSimplifying an FSM [20 points]\n\nYou are given the state machine of a one-bit input / one-bit output digital circuit design. Answer the following questions for the given state diagram.",
        "context_figures": [],
        "question": "",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The parser failed to extract the complete question and solution for problem 3.2. The original PDF shows that problem 3.2 has three parts (a, b, c) with specific questions about whether the given state machine is a Mealy or Moore machine, if it can be simplified, and what the state machine does. The question field is empty, and the solution field is also empty. Additionally, the context is missing the state diagram figure that is referenced in the problem statement.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/1",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The integer multiplication algorithm used by the ALU.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/2",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The program counter width.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/3",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "Branch misprediction penalty.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/4",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The ability to flush the TLB from the OS.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/5",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The size of the Reorder Buffer in an Out-of-Order CPU.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/6",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The fetch width of a superscalar CPU.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/7",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "SIMD instruction support.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/8",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The memory addresses of the memory-mapped devices of the CPU (e.g., keyboard).\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/9",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The number of non-programmable registers in the CPU.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/10",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The replacement policy of the L1 data cache.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/11",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The memory controller's scheduling algorithm.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/12",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The number of bits required for the destination register of a load instruction.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/13",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "Description of the support for division and multiplication between integers.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/14",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The mechanism to enter in a system call in the OS.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_4/15",
        "context": "ISA vs. Microarchitecture [30 points]\nA new CPU has two comprehensive user manuals available for purchase as shown in Table 1.\n\nManual Title Cost Description\nthe_isa.pdf CHF 1 million describes the ISA in detail\nthe_microarchitecture.pdf CHF 10 million describes the microarchitecture in detail\n\nTable 1: Manual Costs\nUnfortunately, the manuals are extremely expensive, and you can only afford one of the two. If both manuals might be useful, you would prefer the cheaper one.\nFor each of the following questions that you would like to answer, decide which manual is more likely to help. Note: we will subtract 1 point for each incorrect answer, and award 0 points for unanswered questions.\n",
        "context_figures": [
            "chart_p8_0.png"
        ],
        "question": "The size of the addressable memory.\n\n1. the_isa.pdf 2. the_microarchitecture.pdf",
        "solution": "",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The solution field is empty. Additionally, the image 'chart_p8_0.png' is referenced but we don't know what it contains or if it's correctly associated with this question.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_5/a",
        "context": "A multi-cycle processor P1 executes load instructions in 10 cycles, store instructions in 8 cycles, arithmetic instructions in 4 cycles, and branch instructions in 4 cycles. Consider an application A where 20% of all instructions are load instructions, 20% of all instructions are store instructions, 50% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "What is the CPI of application A when executing on processor P1? Show your work.",
        "solution": "CPI = 0.2\u00d7 10 + 0.2\u00d7 8 + 0.5\u00d7 4 + 0.1\u00d7 4\nCPI = 6",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_5/b",
        "context": "A multi-cycle processor P1 executes load instructions in 10 cycles, store instructions in 8 cycles, arithmetic instructions in 4 cycles, and branch instructions in 4 cycles. Consider an application A where 20% of all instructions are load instructions, 20% of all instructions are store instructions, 50% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "A new design of the processor doubles the clock frequency of P1. However, the latencies of the load, store, arithmetic, and branch instructions increase by 2, 2, 2, and 1 cycles, respectively. We call this new processor P2. The compiler used to generate instructions for P2 is the same as for P1. Thus, it produces the same number of instructions for program A. What is the CPI of application A when executing on processor P2? Show your work.",
        "solution": "CPI = 0.2\u00d7 12 + 0.2\u00d7 10 + 0.5\u00d7 6 + 0.1\u00d7 5\nCPI = 7.9",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_5/c",
        "context": "A multi-cycle processor P1 executes load instructions in 10 cycles, store instructions in 8 cycles, arithmetic instructions in 4 cycles, and branch instructions in 4 cycles. Consider an application A where 20% of all instructions are load instructions, 20% of all instructions are store instructions, 50% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "Which processor is faster (P1 or P2)? By how much? Show your work.",
        "solution": "P2 is 1.52\u00d7 faster than P1.\n\nExplanation.\nExecution_Time_P1 = instructions\u00d7 CPIP1 \u00d7 clock_rate\n\nExecution_Time_P2 = instructions\u00d7 CPIP2 \u00d7 clock_rate/2\n\nclock_rate = 1/clock_frequency\n\nAssuming that Execution_Time_P2 < Execution_Time_P1 =\u21d2\nExecution_Time_P1/Execution_Time_P2 > 1. Thus:\n\n=\u21d2 instructions\u00d7CPIP1\u00d7clock_rate/(instructions\u00d7CPIP2\u00d7clock_rate/2)\n\n=\u21d2 6\u00d7clock_rate/(7.9\u00d7 clock_rate/2)\n\n=\u21d2 6/3.95\n\n=\u21d2 1.52",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "The context is missing information about processor P2 from part (b). Without this information, the problem is not standalone as required by condition (c). A student would need to know the details about P2 (doubled clock frequency and increased latencies) to understand the comparison being asked for.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_5/d",
        "context": "A multi-cycle processor P1 executes load instructions in 10 cycles, store instructions in 8 cycles, arithmetic instructions in 4 cycles, and branch instructions in 4 cycles. Consider an application A where 20% of all instructions are load instructions, 20% of all instructions are store instructions, 50% of all instructions are arithmetic instructions, and 10% of all instructions are branch instructions.\n",
        "context_figures": [],
        "question": "There is some extra area available in the chip of processor P1, where extra hardware can fit. You can decide to include in your processor a faster branch execution unit or a faster memory device. The faster branch execution unit reduces the latency of branch instructions by a factor of 4. The memory device reduces the latency of the memory operations by a factor of 2. Which design do you choose? Show your work.",
        "solution": "A faster memory device.\n\nExplanation.\nApplication A executes 10% of branch operations and 40% of memory operations (load and stores).\nBy Amdahl's Law, we have:\n\nSpeedupbranch = 1/((1\u22120.1)+ 0.1/4) = 1.08\n\nSpeedupmemory = 1/((1\u22120.4)+ 0.4/2) = 1.25\n\nTherefore, the new memory device provides more speedup than the faster branch execution unit, for this particular application.\n\nAlternative Solution.\nIn case we decide to reduce the latency of the branch operations, the new CPI of processor P1 will be:\nCPIbranch = 0.2\u00d7 10 + 0.2\u00d7 8 + 0.5\u00d7 4 + 0.1\u00d7 4/4\nCPIbranch = 5.7\n\nIn case we decide to reduce the latency of the memory operations, the new CPI of processor P1 will be:\nCPImemory = 0.2\u00d7 10/2 + 0.2\u00d7 8/2 + 0.5\u00d7 4 + 0.1\u00d7 4\nCPImemory = 4.2\n\nSince CPImemory < CPIbranch, improving the memory device will provide shorter cycles-per-instructions.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_6/(a)",
        "context": "Pipelining (Reverse Engineering) [45 points]\n\nAlgorithm 1 contains a piece of assembly code. Table 2 presents the execution timeline of this code.\n\n1 MOVI R1, X # R1 <- X\n2 MOVI R2, Y # R2 <- Y\n3 L1:\n4 ADD R1, R1, R2 # R1 <- R1 + R2\n5 MUL R4, R2, R3 # R4 <- R2 x R3\n6 SUBI R3, R1, 100 # R3 <- R1 - 100, set condition flags\n7 JNZ L1 # Jump to L1 if zero flag is set\n8 MUL R1, R1, R2 # R1 <- R1 x R2\n9 MUL R2, R3, R4 # R2 <- R3 x R4\n\n\n10 ADD R5, R6, R7 # R5 <- R6 + R7\n\n\nAlgorithm 1: Assembly Program\n\n\nDyn. Instr. Instructions Cycles\nNumber 1 2 3 4 5 6 7 8 9 10 11 12 13 ...\n1 MOV R1, X F D E1 E2 E3 M W\n2 MOV R2, Y F D E1 E2 E3 M W\n3 ADD R1, R1, R2 F D - - E1 E2 E3 M W\n4 MUL R4, R2, R3 F - - D E1 E2 E3 M W\n5 SUBI R3, R1, 100 F D - E1 E2 E3 M ...\n6 JNZ L1 F - D - - E1 ...\n7 ...\n\n\nTable 2: Execution timeline (F:Fetch, D:Decode, E:Execute, M:Memory, W:WriteBack)\n\n\nUse this information to reverse engineer the architecture of this microprocessor to answer the following\nquestions. Answer the questions as precisely as possible with the provided information. If the provided\ninformation is not sufficient to answer a question, answer \"Unknown\" and explain your reasoning clearly.\n",
        "context_figures": [
            "chart_p12_0.png",
            "chart_p12_1.png"
        ],
        "question": "List the necessary data forwardings between pipeline stages to exhibit this behavior.",
        "solution": "The result of E3 stage is forwarded to E1 stage (e.g., R1's value at clock cycle 10 and\nR2's value at clock cycle 7).\nThe result of E3 stage is forwarded to the condition registers (e.g., SUBI and JNZ at\nclock cycle 13).\nThere is no other information for any other data forwarding. Therefore, other data\nforwardings are unknown.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_6/(b)",
        "context": "Pipelining (Reverse Engineering) [45 points]\n\nAlgorithm 1 contains a piece of assembly code. Table 2 presents the execution timeline of this code.\n\n1 MOVI R1, X # R1 <- X\n2 MOVI R2, Y # R2 <- Y\n3 L1:\n4 ADD R1, R1, R2 # R1 <- R1 + R2\n5 MUL R4, R2, R3 # R4 <- R2 x R3\n6 SUBI R3, R1, 100 # R3 <- R1 - 100, set condition flags\n7 JNZ L1 # Jump to L1 if zero flag is set\n8 MUL R1, R1, R2 # R1 <- R1 x R2\n9 MUL R2, R3, R4 # R2 <- R3 x R4\n\n\n10 ADD R5, R6, R7 # R5 <- R6 + R7\n\n\nAlgorithm 1: Assembly Program\n\n\nDyn. Instr. Instructions Cycles\nNumber 1 2 3 4 5 6 7 8 9 10 11 12 13 ...\n1 MOV R1, X F D E1 E2 E3 M W\n2 MOV R2, Y F D E1 E2 E3 M W\n3 ADD R1, R1, R2 F D - - E1 E2 E3 M W\n4 MUL R4, R2, R3 F - - D E1 E2 E3 M W\n5 SUBI R3, R1, 100 F D - E1 E2 E3 M ...\n6 JNZ L1 F - D - - E1 ...\n7 ...\n\n\nTable 2: Execution timeline (F:Fetch, D:Decode, E:Execute, M:Memory, W:WriteBack)\n\n\nUse this information to reverse engineer the architecture of this microprocessor to answer the following\nquestions. Answer the questions as precisely as possible with the provided information. If the provided\ninformation is not sufficient to answer a question, answer \"Unknown\" and explain your reasoning clearly.\n",
        "context_figures": [
            "chart_p12_0.png",
            "chart_p12_1.png"
        ],
        "question": "Does this machine use hardware-interlocking or software-interlocking? Explain.",
        "solution": "Hardware-interlocking. It detects data dependencies and stalls the pipeline accordingly\nwithout needing any software-induced NOPs.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_6/(c)",
        "context": "Pipelining (Reverse Engineering) [45 points]\n\nAlgorithm 1 contains a piece of assembly code. Table 2 presents the execution timeline of this code.\n\n1 MOVI R1, X # R1 <- X\n2 MOVI R2, Y # R2 <- Y\n3 L1:\n4 ADD R1, R1, R2 # R1 <- R1 + R2\n5 MUL R4, R2, R3 # R4 <- R2 x R3\n6 SUBI R3, R1, 100 # R3 <- R1 - 100, set condition flags\n7 JNZ L1 # Jump to L1 if zero flag is set\n8 MUL R1, R1, R2 # R1 <- R1 x R2\n9 MUL R2, R3, R4 # R2 <- R3 x R4\n\n\n10 ADD R5, R6, R7 # R5 <- R6 + R7\n\n\nAlgorithm 1: Assembly Program\n\n\nDyn. Instr. Instructions Cycles\nNumber 1 2 3 4 5 6 7 8 9 10 11 12 13 ...\n1 MOV R1, X F D E1 E2 E3 M W\n2 MOV R2, Y F D E1 E2 E3 M W\n3 ADD R1, R1, R2 F D - - E1 E2 E3 M W\n4 MUL R4, R2, R3 F - - D E1 E2 E3 M W\n5 SUBI R3, R1, 100 F D - E1 E2 E3 M ...\n6 JNZ L1 F - D - - E1 ...\n7 ...\n\n\nTable 2: Execution timeline (F:Fetch, D:Decode, E:Execute, M:Memory, W:WriteBack)\n\n\nUse this information to reverse engineer the architecture of this microprocessor to answer the following\nquestions. Answer the questions as precisely as possible with the provided information. If the provided\ninformation is not sufficient to answer a question, answer \"Unknown\" and explain your reasoning clearly.\n",
        "context_figures": [
            "chart_p12_0.png",
            "chart_p12_1.png"
        ],
        "question": "Consider another machine that uses the opposite of your choice in the previous question.\n(e.g., if your answer is software-interlocking for the previous question, consider another machine\nusing hardware-interlocking, or vice-versa). How would the execution timeline shown in Table 2\nchange? What would be different? Fill the following table and explain your reasoning below.\n(Notice that the table below consists of two parts: the first seven cycles at the top, and the next\nseven cycles at the bottom.)",
        "solution": "We inject NOP instructions in between existing instructions to delay instructions with\ndata dependencies.\n\n\nDyn. Instr. Instructions Cycles\n\nNumber 1 2 3 4 5 6 7\n\n1 MOV R1, X F D E1 E2 E3 M W\n\n2 MOV R2, Y F D E1 E2 E3 M\n\n3 NOP F D E1 E2 E3\n\n4 NOP F D E1 E2\n\n5 ADD R1, R1, R2 F D E1\n\n6 MUL R4, R2, R3 F D\n\n7 NOP F\n\n8 SUB R3, R1, 100\n\n9 NOP\n\n10 NOP\n\n11 JNZ L1\n\n8 9 10 11 12 13 14\n\n3 NOP M W\n\n4 NOP E3 M W\n\n5 ADD R1, R1, R2 E2 E3 M W\n\n6 MUL R4, R2, R3 E1 E2 E3 M W\n\n7 NOP D E1 E2 E3 M W\n\n8 SUB R3, R1, 100 F D E1 E2 E3 M ...\n\n9 NOP F D E1 E2 E3 ...\n\n10 NOP F D E1 E2 ...\n\n11 JNZ L1 F D E1 ...",
        "solution_figures": [
            "chart_p13_0.png"
        ],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_6/(d)",
        "context": "Pipelining (Reverse Engineering) [45 points]\n\nAlgorithm 1 contains a piece of assembly code. Table 2 presents the execution timeline of this code.\n\n1 MOVI R1, X # R1 <- X\n2 MOVI R2, Y # R2 <- Y\n3 L1:\n4 ADD R1, R1, R2 # R1 <- R1 + R2\n5 MUL R4, R2, R3 # R4 <- R2 x R3\n6 SUBI R3, R1, 100 # R3 <- R1 - 100, set condition flags\n7 JNZ L1 # Jump to L1 if zero flag is set\n8 MUL R1, R1, R2 # R1 <- R1 x R2\n9 MUL R2, R3, R4 # R2 <- R3 x R4\n\n\n10 ADD R5, R6, R7 # R5 <- R6 + R7\n\n\nAlgorithm 1: Assembly Program\n\n\nDyn. Instr. Instructions Cycles\nNumber 1 2 3 4 5 6 7 8 9 10 11 12 13 ...\n1 MOV R1, X F D E1 E2 E3 M W\n2 MOV R2, Y F D E1 E2 E3 M W\n3 ADD R1, R1, R2 F D - - E1 E2 E3 M W\n4 MUL R4, R2, R3 F - - D E1 E2 E3 M W\n5 SUBI R3, R1, 100 F D - E1 E2 E3 M ...\n6 JNZ L1 F - D - - E1 ...\n7 ...\n\n\nTable 2: Execution timeline (F:Fetch, D:Decode, E:Execute, M:Memory, W:WriteBack)\n\n\nUse this information to reverse engineer the architecture of this microprocessor to answer the following\nquestions. Answer the questions as precisely as possible with the provided information. If the provided\ninformation is not sufficient to answer a question, answer \"Unknown\" and explain your reasoning clearly.\nFor the rest of this question, assume the following:\n\n\u2022 X = Y = 1 in Algorithm 1.\n\u2022 Branch conditions are resolved at the stage E1.\n\u2022 Branch predictor is static and predicts \"always taken\".\n\u2022 The machine uses hardware-interlocking.\n\nAt a given clock cycle T,\n\n\u2022 the value stored in R1 is 98.\n\u2022 the processor fetches the dynamic instruction N which is ADD R1, R1, R2",
        "context_figures": [
            "chart_p12_0.png",
            "chart_p12_1.png"
        ],
        "question": "Calculate the value of T. Show your work.",
        "solution": "T = 682.\n\nExplanation.\nSteady state throughput of an iteration is 4 instructions in 7 cycles. The first iteration\ntakes 10 cycles as shown below.\n\nIf R1 = 98, this iteration is executed for 97 times so far.\n\nSince in cycle T the first instruction of the loop is being fetched, no cycles of the 98th\niteration have executed so far.\n\nThen, T = 10 + 96\u00d7 7 + 0 = 682",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_6/(e)",
        "context": "Pipelining (Reverse Engineering) [45 points]\n\nAlgorithm 1 contains a piece of assembly code. Table 2 presents the execution timeline of this code.\n\n1 MOVI R1, X # R1 <- X\n2 MOVI R2, Y # R2 <- Y\n3 L1:\n4 ADD R1, R1, R2 # R1 <- R1 + R2\n5 MUL R4, R2, R3 # R4 <- R2 x R3\n6 SUBI R3, R1, 100 # R3 <- R1 - 100, set condition flags\n7 JNZ L1 # Jump to L1 if zero flag is set\n8 MUL R1, R1, R2 # R1 <- R1 x R2\n9 MUL R2, R3, R4 # R2 <- R3 x R4\n\n\n10 ADD R5, R6, R7 # R5 <- R6 + R7\n\n\nAlgorithm 1: Assembly Program\n\n\nDyn. Instr. Instructions Cycles\nNumber 1 2 3 4 5 6 7 8 9 10 11 12 13 ...\n1 MOV R1, X F D E1 E2 E3 M W\n2 MOV R2, Y F D E1 E2 E3 M W\n3 ADD R1, R1, R2 F D - - E1 E2 E3 M W\n4 MUL R4, R2, R3 F - - D E1 E2 E3 M W\n5 SUBI R3, R1, 100 F D - E1 E2 E3 M ...\n6 JNZ L1 F - D - - E1 ...\n7 ...\n\n\nTable 2: Execution timeline (F:Fetch, D:Decode, E:Execute, M:Memory, W:WriteBack)\n\n\nUse this information to reverse engineer the architecture of this microprocessor to answer the following\nquestions. Answer the questions as precisely as possible with the provided information. If the provided\ninformation is not sufficient to answer a question, answer \"Unknown\" and explain your reasoning clearly.\n",
        "context_figures": [
            "chart_p12_0.png",
            "chart_p12_1.png"
        ],
        "question": "Calculate the value of N. Show your work.",
        "solution": "N = 390.\n\nExplanation.\nLoop iterates for 97 times before reaching to clock cycle T.\n\nThere are two instructions before the loop starts.\n\nThen, N = 2 + 97\u00d7 4 = 390, assuming that the instruction indices start from 0.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_7/a",
        "context": "In this problem, we consider a scalar processor with in-order fetch, out-of-order dispatch, and in-order retirement execution engine that employs Tomasulo's algorithm. This processor behaves as follows:\n\n\u2022 The processor has four main pipeline stages: Fetch (F), Decode (D), Execute (E), and Write-back (W).\n\n\u2022 The processor implements a single-level data cache.\n\n\u2022 The processor has the following two types of execution units but it is unknown how many of each type the processor has.\n\n\u2013 Integer ALU: Executes integer instructions (i.e., addition, multiplication, move, branch).\n\n\u2013 Memory Unit: Executes load/store instructions.\n\n\u2022 The processor is connected to a main memory that has a fixed access latency.\n\n\u2022 Load/store instructions spend cycles in the E stage exclusively for accessing the data cache or the main memory.\n\n\u2022 There are two reservation stations, one for each execution unit type.\n\nThe reservation stations are all initially empty. The processor executes an arbitrary program. From the beginning of the program until the program execution finishes, seven dynamic instructions enter the processor pipeline. Table 3 shows the seven instructions and their execution diagram.\n\nInstruction semantics:\n\n\u2022 MV R0 \u2190 #0x1000: moves the hexademical number 0x1000 to register R0.\n\n\u2022 LD R1 \u2190 [R0]: loads the value stored at memory address R0 to register R1.\n\n\u2022 BL R1, #100, #LB1: a branch instruction that conditionally takes the path specified by label \"#LB1\" if the content of register R1 is smaller than integer value 100.\n\n\u2022 MUL R1 \u2190 R1, #5: multiplies R1 and 5 and writes the result to R1.\n\n\u2022 ST [R0] \u2190 R1: stores R1 to memory address specified by R0.\n\n\u2022 ADD R1 \u2190 R1, R0: adds R1 and R0 and writes the result to R1.\n",
        "context_figures": [
            "chart_p15_0.png"
        ],
        "question": "Using the information provided above, answer the following questions regarding the processor design. If a question has more than one correct answer or a correct answer cannot be determined using the information provided in the question, answer the question as specifically as possible. For example, use phrases such as \"at least/at most\" and try to narrow down the answer using the information that is provided in the question and can be inferred from Table 3. If nothing can be inferred, write \"Unknown\" as an answer. Explain your reasoning briefly.\n\nWhat is the cache hit latency?\n\nWhat is the cache miss latency?\n\nWhat is the cache line size?\n\nWhat is the number of entries in each reservation station (R)?\n\nHow many ALUs does the processor have?\n\nIs the integer ALU pipelined?\n\nDoes the processor perform branch prediction?\n\nAt which pipeline stage is the correct outcome of a branch evaluated?",
        "solution": "1 cycle. The last ST instruction that writes to the same memory location that is previously loaded by LD takes only 1 cycle in E stage.\n\nWhat is the cache miss latency?\n\n8 cycles. The first LD instruction spends 8 cycles in the E stage.\n\nWhat is the cache line size?\n\nUnknown. We cannot infer the cache line size from one LD and ST instructions and also we cannot determine the minimum cache line size since the register width is not given in the question.\n\nWhat is the number of entries in each reservation station (R)?\n\nALU \u2192 at least 2, MU \u2192 unknown\n\nHow many ALUs does the processor have?\n\nAt least 2 ALUs if not pipelined, otherwise at least 1 ALU. This is because we see two arithmetic instructions simultaneously in E stage in the pipeline diagram.\n\nIs the integer ALU pipelined?\n\nYes if the processor has 1 ALU, otherwise no. The explanation is similar to the above question.\n\nDoes the processor perform branch prediction?\n\nYes because there are squashed (as a result of branch misprediction) instructions in the pipeline.\n\nAt which pipeline stage is the correct outcome of a branch evaluated?\n\nAt the end of stage E4. This is because in the next cycle after the branch instruction completes E4 previously fetched instructions are killed and an instruction from the correct path is fetched.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_7/b",
        "context": "In this problem, we consider a scalar processor with in-order fetch, out-of-order dispatch, and in-order retirement execution engine that employs Tomasulo's algorithm. This processor behaves as follows:\n\n\u2022 The processor has four main pipeline stages: Fetch (F), Decode (D), Execute (E), and Write-back (W).\n\n\u2022 The processor implements a single-level data cache.\n\n\u2022 The processor has the following two types of execution units but it is unknown how many of each type the processor has.\n\n\u2013 Integer ALU: Executes integer instructions (i.e., addition, multiplication, move, branch).\n\n\u2013 Memory Unit: Executes load/store instructions.\n\n\u2022 The processor is connected to a main memory that has a fixed access latency.\n\n\u2022 Load/store instructions spend cycles in the E stage exclusively for accessing the data cache or the main memory.\n\n\u2022 There are two reservation stations, one for each execution unit type.\n\nThe reservation stations are all initially empty. The processor executes an arbitrary program. From the beginning of the program until the program execution finishes, seven dynamic instructions enter the processor pipeline. Table 3 shows the seven instructions and their execution diagram.\n\nInstruction semantics:\n\n\u2022 MV R0 \u2190 #0x1000: moves the hexademical number 0x1000 to register R0.\n\n\u2022 LD R1 \u2190 [R0]: loads the value stored at memory address R0 to register R1.\n\n\u2022 BL R1, #100, #LB1: a branch instruction that conditionally takes the path specified by label \"#LB1\" if the content of register R1 is smaller than integer value 100.\n\n\u2022 MUL R1 \u2190 R1, #5: multiplies R1 and 5 and writes the result to R1.\n\n\u2022 ST [R0] \u2190 R1: stores R1 to memory address specified by R0.\n\n\u2022 ADD R1 \u2190 R1, R0: adds R1 and R0 and writes the result to R1.\n",
        "context_figures": [
            "chart_p15_0.png"
        ],
        "question": "What is the program (i.e., static instructions) that leads to the execution diagram shown in Table 3? Fill in the blanks below with the known instructions of the program and also (if applicable) show where and how many unknown instructions there are in the program.",
        "solution": "Program:\nMV R0 \u2190 #0x1000\n\nLD R1 \u2190 [R0]\n\nBL R1 #100, #LB1\n\nMUL R1 \u2190 R1, #5\n\nST [R0] \u2190 R1\n\nAny number of unknown instructions can be here\n\nLB1: ADD R1 \u2190 R1, R0\n\nST [R0] \u2190 R1",
        "solution_figures": [
            "chart_p17_0.png"
        ],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_8/a",
        "context": "GPUs and SIMD [40 points]\n\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are\nkept busy with active threads during the run of a program. As we saw in lecture and practice exercises,\nthe SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. A warp in the GPU consists of 64 threads, and there are\n64 SIMD lanes in the GPU. Each thread executes a single iteration of the shown loop. Assume that\nthe data values of the arrays A and B are already in vector registers so there are no loads and stores in\nthis program. Both A and B are arrays of integers. (Hint Notice that there are 6 instructions in each\nthread.)\n\nfor (i = 0; i < 4096; i++) {\nif (B[i] < 8888) { // Instruction 1\n\nA[i] = A[i] * C[i]; // Instruction 2\nA[i] = A[i] + B[i] // Instruction 3\nC[i] = B[i] + 1; // Instruction 4\n\n}\nif (B[i] > 8888) { // Instruction 5\n\nA[i] = A[i] * B[i]; // Instruction 6\n}\n\n}\n",
        "context_figures": [],
        "question": "How many warps does it take to execute this program?",
        "solution": "Warps = (Number of threads) / (Number of threads per warp) Number of threads =\n212 (i.e., one thread per loop iteration) Number of threads per warp = 64 = 26 (given)\nWarps = 212/26 = 26",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_8/b",
        "context": "GPUs and SIMD [40 points]\n\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are\nkept busy with active threads during the run of a program. As we saw in lecture and practice exercises,\nthe SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. A warp in the GPU consists of 64 threads, and there are\n64 SIMD lanes in the GPU. Each thread executes a single iteration of the shown loop. Assume that\nthe data values of the arrays A and B are already in vector registers so there are no loads and stores in\nthis program. Both A and B are arrays of integers. (Hint Notice that there are 6 instructions in each\nthread.)\n\nfor (i = 0; i < 4096; i++) {\nif (B[i] < 8888) { // Instruction 1\n\nA[i] = A[i] * C[i]; // Instruction 2\nA[i] = A[i] + B[i] // Instruction 3\nC[i] = B[i] + 1; // Instruction 4\n\n}\nif (B[i] > 8888) { // Instruction 5\n\nA[i] = A[i] * B[i]; // Instruction 6\n}\n\n}\n",
        "context_figures": [],
        "question": "When we measure the SIMD utilization for this program with one input set, we find\nthat it is 134/320. What can you say about arrays A,B, and C? Be precise. (Hint: Look at the\n\"if\" branch).",
        "solution": "A. Nothing.\nB. 2 in every 64 consecutive elements of B are less than 8888, the rest are exactly 8888.\nC. Nothing.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_8/c",
        "context": "GPUs and SIMD [40 points]\n\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are\nkept busy with active threads during the run of a program. As we saw in lecture and practice exercises,\nthe SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. A warp in the GPU consists of 64 threads, and there are\n64 SIMD lanes in the GPU. Each thread executes a single iteration of the shown loop. Assume that\nthe data values of the arrays A and B are already in vector registers so there are no loads and stores in\nthis program. Both A and B are arrays of integers. (Hint Notice that there are 6 instructions in each\nthread.)\n\nfor (i = 0; i < 4096; i++) {\nif (B[i] < 8888) { // Instruction 1\n\nA[i] = A[i] * C[i]; // Instruction 2\nA[i] = A[i] + B[i] // Instruction 3\nC[i] = B[i] + 1; // Instruction 4\n\n}\nif (B[i] > 8888) { // Instruction 5\n\nA[i] = A[i] * B[i]; // Instruction 6\n}\n\n}\n",
        "context_figures": [],
        "question": "What needs to be true about array B to achieve 100% utilization? Show your work. Be\nprecise and complete. (Hint: The warp scheduler does not issue instructions where no threads are\nactive).",
        "solution": "Every 64 consecutive elements of B are either:\n(1) equal to 8888,\n(2) less than 8888,\n(3) greater than 8888.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_8/d",
        "context": "GPUs and SIMD [40 points]\n\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are\nkept busy with active threads during the run of a program. As we saw in lecture and practice exercises,\nthe SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. A warp in the GPU consists of 64 threads, and there are\n64 SIMD lanes in the GPU. Each thread executes a single iteration of the shown loop. Assume that\nthe data values of the arrays A and B are already in vector registers so there are no loads and stores in\nthis program. Both A and B are arrays of integers. (Hint Notice that there are 6 instructions in each\nthread.)\n\nfor (i = 0; i < 4096; i++) {\nif (B[i] < 8888) { // Instruction 1\n\nA[i] = A[i] * C[i]; // Instruction 2\nA[i] = A[i] + B[i] // Instruction 3\nC[i] = B[i] + 1; // Instruction 4\n\n}\nif (B[i] > 8888) { // Instruction 5\n\nA[i] = A[i] * B[i]; // Instruction 6\n}\n\n}\n",
        "context_figures": [],
        "question": "What is the minimum possible SIMD utilization of this program?",
        "solution": "132/384.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_8/e",
        "context": "GPUs and SIMD [40 points]\n\nWe define the SIMD utilization of a program that runs on a GPU as the fraction of SIMD lanes that are\nkept busy with active threads during the run of a program. As we saw in lecture and practice exercises,\nthe SIMD utilization of a program is computed across the complete run of the program.\n\nThe following code segment is run on a GPU. A warp in the GPU consists of 64 threads, and there are\n64 SIMD lanes in the GPU. Each thread executes a single iteration of the shown loop. Assume that\nthe data values of the arrays A and B are already in vector registers so there are no loads and stores in\nthis program. Both A and B are arrays of integers. (Hint Notice that there are 6 instructions in each\nthread.)\n\nfor (i = 0; i < 4096; i++) {\nif (B[i] < 8888) { // Instruction 1\n\nA[i] = A[i] * C[i]; // Instruction 2\nA[i] = A[i] + B[i] // Instruction 3\nC[i] = B[i] + 1; // Instruction 4\n\n}\nif (B[i] > 8888) { // Instruction 5\n\nA[i] = A[i] * B[i]; // Instruction 6\n}\n\n}\n",
        "context_figures": [],
        "question": "What needs to be true about array B to achieve the minimum possible SIMD utilization?\nShow your work. (Please cover all cases in your answer.)",
        "solution": "1 in every 64 of B's elements are greater than 8888, and 1 in every 64 of B's elements are\nless than 8888, and the rest of the elements are 8888.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_9/a",
        "context": "Caches (Reverse Engineering) [40 points]\n\n\nYou are trying to reverse-engineer the characteristics of a cache in a system, so that you can design\na more efficient, machine-specific implementation of an algorithm you are working on. To do so, you\nhave come up with two sequences of memory accesses to various bytes in the system in an attempt to\ndetermine the following four cache characteristics:\n\n\n\u2022 Cache block size (8, 16, 32, 64, or 128 B).\n\n\n\u2022 Cache associativity (1-, 2-, 4-, or 8-way).\n\n\n\u2022 Cache size (4 or 8 KiB).\n\n\n\u2022 Cache replacement policy (LRU or FIFO).\n\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of\nmemory accesses. Here is what you observe:\n\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n\n1. 0 32 128 73 8192 255 16384 196 1/2\n2. 127 4096 8192 32768 196 16384 0 512 3/8\n\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning\nof the second sequence. The sequences are executed back-to-back, i.e., no other accesses take place in\nbetween the two sequences. Thus, at the beginning of the second sequence, the contents are\nthe same as at the end of the first sequence.\n\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\nIf a characteristic cannot be known, then write \"Unknown\" and explain.\n",
        "context_figures": [],
        "question": "Cache block size (8, 16, 32, 64, or 128 B)?",
        "solution": "128 B.\n\nExplanation:\nCache hit rate is 1/2 in sequence 1. This means that there are 4 hits. Depending on the\ncache block size, we can group addresses that belong to the same cache block as follows:\n\n\u2022 8\u201332 B: {0}, {32}, {128}, {73}, {8192}, {255}, {16384}, {196}. \u2234 Number of\npossible hits = 0.\n\n\u2022 64 B: {0, 32}, {128}, {73}, {8192}, {255, 196}, {16484}. \u2234 Number of possible hits\n= 2.\n\n\u2022 128 B: {0, 32, 73}, {128, 255, 196}, {8192}, {16384}. \u2234 Number of possible hits\n= 4.\n\nTherefore, we can know that the cache block size is 128 B.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_9/b",
        "context": "Caches (Reverse Engineering) [40 points]\n\n\nYou are trying to reverse-engineer the characteristics of a cache in a system, so that you can design\na more efficient, machine-specific implementation of an algorithm you are working on. To do so, you\nhave come up with two sequences of memory accesses to various bytes in the system in an attempt to\ndetermine the following four cache characteristics:\n\n\n\u2022 Cache block size (8, 16, 32, 64, or 128 B).\n\n\n\u2022 Cache associativity (1-, 2-, 4-, or 8-way).\n\n\n\u2022 Cache size (4 or 8 KiB).\n\n\n\u2022 Cache replacement policy (LRU or FIFO).\n\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of\nmemory accesses. Here is what you observe:\n\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n\n1. 0 32 128 73 8192 255 16384 196 1/2\n2. 127 4096 8192 32768 196 16384 0 512 3/8\n\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning\nof the second sequence. The sequences are executed back-to-back, i.e., no other accesses take place in\nbetween the two sequences. Thus, at the beginning of the second sequence, the contents are\nthe same as at the end of the first sequence.\n\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\nIf a characteristic cannot be known, then write \"Unknown\" and explain.\n",
        "context_figures": [],
        "question": "Cache associativity (1-, 2-, 4-, or 8-way)?",
        "solution": "4-way.\n\nExplanation:\n\nCache hit rate is 3/8 in sequence 2, which means that there are 3 hits.\nWe already know that the cache block size is 128 B. Thus, there are 7 offset bits.\n\nThe access to address 196 in sequence 2 would hit because the cache block would not be\nreplaced.\nThe access to address 512 in sequence 2 would miss because address 512 does not belong\nto any cache block previously accessed.\nTherefore, the accesses to addresses 0, 127, 4096, 8192, 16834 and 32768 in sequence 2\nwould hit 2 times.\nRegardless of cache size, those addresses will never hit when the cache were 1-way or\n2-way.\nIf the cache were 8-way, those addresses would all map to set 0. With 8 ways, addresses\n127, 9182, 16384 would not be replaced, so the three addressess would hit.\nTherefore, the cache is 4-way associative.",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "There's a typo in the solution where '16834' is written instead of '16384' as in the original PDF. Also, there's a typo where '9182' is written instead of '8192'.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_9/c",
        "context": "Caches (Reverse Engineering) [40 points]\n\n\nYou are trying to reverse-engineer the characteristics of a cache in a system, so that you can design\na more efficient, machine-specific implementation of an algorithm you are working on. To do so, you\nhave come up with two sequences of memory accesses to various bytes in the system in an attempt to\ndetermine the following four cache characteristics:\n\n\n\u2022 Cache block size (8, 16, 32, 64, or 128 B).\n\n\n\u2022 Cache associativity (1-, 2-, 4-, or 8-way).\n\n\n\u2022 Cache size (4 or 8 KiB).\n\n\n\u2022 Cache replacement policy (LRU or FIFO).\n\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of\nmemory accesses. Here is what you observe:\n\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n\n1. 0 32 128 73 8192 255 16384 196 1/2\n2. 127 4096 8192 32768 196 16384 0 512 3/8\n\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning\nof the second sequence. The sequences are executed back-to-back, i.e., no other accesses take place in\nbetween the two sequences. Thus, at the beginning of the second sequence, the contents are\nthe same as at the end of the first sequence.\n\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\nIf a characteristic cannot be known, then write \"Unknown\" and explain.\n",
        "context_figures": [],
        "question": "Cache replacement policy (LRU or FIFO)?",
        "solution": "LRU.\n\nExplanation:\nFrom questions (a) and (b), we already know the following facts:\n\n\u2022 The cache block size is 128 B.\n\u2022 The cache is 4-way.\n\u2022 The accesses to addresses 0, 127, 4096, 8192, 16384, and 32768 in sequence 2 would\n  hit 2 times.\nRegardless of the cache size, 0, 127, 4096, 8192, 16834, and 32768 in sequence 2 would\nall map to set 0.\nWith the FIFO policy, accesses to addresses 127, 8192, and 16484 in sequence 2 would\nhit.\nWith the LRU policy, accesses to addresses 127 and 8192 would hit.\nTherefore, the cache adopts the LRU policy.",
        "solution_figures": [],
        "passed_llm_verification": false,
        "reasoning": "There are typos in the solution where '16834' is written instead of '16384' and '16484' is written instead of '16384' as in the original PDF.",
        "passed_human_verification": null
    },
    {
        "question_id": "digitaltechnik-s20-en-sol/Problem_9/d",
        "context": "Caches (Reverse Engineering) [40 points]\n\n\nYou are trying to reverse-engineer the characteristics of a cache in a system, so that you can design\na more efficient, machine-specific implementation of an algorithm you are working on. To do so, you\nhave come up with two sequences of memory accesses to various bytes in the system in an attempt to\ndetermine the following four cache characteristics:\n\n\n\u2022 Cache block size (8, 16, 32, 64, or 128 B).\n\n\n\u2022 Cache associativity (1-, 2-, 4-, or 8-way).\n\n\n\u2022 Cache size (4 or 8 KiB).\n\n\n\u2022 Cache replacement policy (LRU or FIFO).\n\n\nThe only statistic that you can collect on this system is cache hit rate after performing each sequence of\nmemory accesses. Here is what you observe:\n\n\nSequence Addresses Accessed (Oldest \u2192 Youngest) Hit Rate\n\n\n1. 0 32 128 73 8192 255 16384 196 1/2\n2. 127 4096 8192 32768 196 16384 0 512 3/8\n\n\nAssume that the cache is initially empty at the beginning of the first sequence, but not at the beginning\nof the second sequence. The sequences are executed back-to-back, i.e., no other accesses take place in\nbetween the two sequences. Thus, at the beginning of the second sequence, the contents are\nthe same as at the end of the first sequence.\n\n\nBased on what you observe, what are the following characteristics of the cache? Explain to get points.\nIf a characteristic cannot be known, then write \"Unknown\" and explain.\nTo identify the cache size, you execute the following sequence right after sequence 2\n(i.e., the contents are the same as at the end of the second sequence) and measure the cache hit\nrate:\n\nAddresses Accessed (Oldest \u2192 Youngest): 8192 \u2192 X \u2192 Y",
        "context_figures": [],
        "question": "Which addresses should you use for X and Y?",
        "solution": "X = 1024\u00d7 (2k \u2212 1) where k is a positive integer.\nY = 32768\n\nExplanation:\nIf the cache is 4-KiB, all addresses that are multiples of 1024 would map to set 0. If the\ncache is 8-KiB, all addresses that are multiples of 2048 would map to set 0.\nAfter the access to 8192 in sequence 3, the LRU address in set 0 is 32768.\nIf the cache is 4-KiB, access to X = 1024 \u00d7 (2k \u2212 1) would replace 32768, so access to\n32768 would miss. If the cache is 8-KiB, such access would not replace 32768, so access\nto 32768 would hit.",
        "solution_figures": [],
        "passed_llm_verification": true,
        "passed_human_verification": null
    }
]